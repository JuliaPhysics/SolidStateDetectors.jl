<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SolidStateDetectors.jl</title><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/api/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">SolidStateDetectors.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Detectors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/config_files/">Config Files</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Geometries (CSG)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../man/csg/">CSG</a></li><li><a class="tocitem" href="../man/primitives/">Primitives</a></li></ul></li><li><a class="tocitem" href="../man/electric_potentials/">Electric Potentials</a></li><li><a class="tocitem" href="../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../man/electric_fields/">Electric Fields</a></li><li><a class="tocitem" href="../man/drift_fields/">Drift Fields</a></li><li><a class="tocitem" href="../man/IO/">IO</a></li></ul></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types-1"><span>Types</span></a></li><li><a class="tocitem" href="#Functions-1"><span>Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Documentation-1"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><h2 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.AbstractConfig"><code>SolidStateDetectors.AbstractConfig</code></a></li><li><a href="#SolidStateDetectors.AbstractLine"><code>SolidStateDetectors.AbstractLine</code></a></li><li><a href="#SolidStateDetectors.Box"><code>SolidStateDetectors.Box</code></a></li><li><a href="#SolidStateDetectors.ConstantChargeDensityModel"><code>SolidStateDetectors.ConstantChargeDensityModel</code></a></li><li><a href="#SolidStateDetectors.Contact"><code>SolidStateDetectors.Contact</code></a></li><li><a href="#SolidStateDetectors.Difference"><code>SolidStateDetectors.Difference</code></a></li><li><a href="#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a></li><li><a href="#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T,T,Symbol,Symbol,Symbol,Symbol,AbstractArray{T,1}}} where T"><code>SolidStateDetectors.DiscreteAxis</code></a></li><li><a href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a></li><li><a href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cartesian}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a></li><li><a href="#SolidStateDetectors.Event"><code>SolidStateDetectors.Event</code></a></li><li><a href="#SolidStateDetectors.GeometryUnion"><code>SolidStateDetectors.GeometryUnion</code></a></li><li><a href="#SolidStateDetectors.Grid"><code>SolidStateDetectors.Grid</code></a></li><li><a href="#SolidStateDetectors.Intersection"><code>SolidStateDetectors.Intersection</code></a></li><li><a href="#SolidStateDetectors.Line"><code>SolidStateDetectors.Line</code></a></li><li><a href="#SolidStateDetectors.LineSegment"><code>SolidStateDetectors.LineSegment</code></a></li><li><a href="#SolidStateDetectors.LinearChargeDensityModel"><code>SolidStateDetectors.LinearChargeDensityModel</code></a></li><li><a href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a></li><li><a href="#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.PointTypes</code></a></li><li><a href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a></li><li><a href="#SolidStateDetectors.PotentialSimulationSetup"><code>SolidStateDetectors.PotentialSimulationSetup</code></a></li><li><a href="#SolidStateDetectors.Ray"><code>SolidStateDetectors.Ray</code></a></li><li><a href="#SolidStateDetectors.RectangularCuboid"><code>SolidStateDetectors.RectangularCuboid</code></a></li><li><a href="#SolidStateDetectors.Simulation"><code>SolidStateDetectors.Simulation</code></a></li><li><a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetectors.SolidStateDetector</code></a></li><li><a href="#SolidStateDetectors.VacuumChargeDriftModel"><code>SolidStateDetectors.VacuumChargeDriftModel</code></a></li><li><a href="#SolidStateDetectors.ZeroChargeDensityModel"><code>SolidStateDetectors.ZeroChargeDensityModel</code></a></li></ul><h2 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T"><code>SolidStateDetectors.RBArray</code></a></li><li><a href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T"><code>SolidStateDetectors.RBExtBy2Array</code></a></li><li><a href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type,Grid{T,3,:cartesian}}} where T"><code>SolidStateDetectors.RBExtBy2Array</code></a></li><li><a href="#SolidStateDetectors._drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,:cylindrical},PointTypes{T,3,:cylindrical},Grid{T,3,:cylindrical},CartesianPoint{T},T,Interpolations.Extrapolation{#s248,3,ITPT,IT,ET} where ET where IT where ITPT where #s248&lt;:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors._drift_charge!</code></a></li><li><a href="#SolidStateDetectors._drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,:cartesian},PointTypes{T,3,:cartesian},Grid{T,3,:cartesian},CartesianPoint{T},T,Interpolations.Extrapolation{#s248,3,ITPT,IT,ET} where ET where IT where ITPT where #s248&lt;:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors._drift_charge!</code></a></li><li><a href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a></li><li><a href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Grid{T,N,S} where S where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a></li><li><a href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Grid{T,N,S} where S where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_field!</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_potential!</code></a></li><li><a href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T},Int64,Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_weighting_potential!</code></a></li><li><a href="#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T,3,:cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.get_active_volume</code></a></li><li><a href="#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SArray{Tuple{3},T,1,3},3},ADLChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_electron_drift_field</code></a></li><li><a href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a></li><li><a href="#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64,Val{true},Val{true}}"><code>SolidStateDetectors.get_rbidx_right_neighbour</code></a></li><li><a href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cartesian},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T"><code>SolidStateDetectors.innerloops!</code></a></li><li><a href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cylindrical},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T"><code>SolidStateDetectors.innerloops!</code></a></li><li><a href="#SolidStateDetectors.nidx-Tuple{Int64,Val{true},Val{true}}"><code>SolidStateDetectors.nidx</code></a></li><li><a href="#SolidStateDetectors.parse_config_file-Tuple{AbstractString}"><code>SolidStateDetectors.parse_config_file</code></a></li><li><a href="#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T,CS} where CS,Grid{T,3,S} where S,CartesianPoint{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.point_type</code></a></li><li><a href="#SolidStateDetectors.readsiggen-Tuple{String}"><code>SolidStateDetectors.readsiggen</code></a></li><li><a href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{#s249,#s248,#s247} where #s247&lt;:Real where #s248&lt;:Real where #s249&lt;:Real}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{#s246,#s245,#s244} where #s244&lt;:Real where #s245&lt;:Real where #s246&lt;:Real,Tuple{#s243,#s220,#s219} where #s219&lt;:Real where #s220&lt;:Real where #s243&lt;:Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a></li><li><a href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{#s17,#s16,#s15} where #s15&lt;:Real where #s16&lt;:Real where #s17&lt;:Real}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{#s14,#s13,#s617} where #s617&lt;:Real where #s13&lt;:Real where #s14&lt;:Real,Tuple{#s618,#s619,#s620} where #s620&lt;:Real where #s619&lt;:Real where #s618&lt;:Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a></li><li><a href="#SolidStateDetectors.siggentodict-Tuple{Dict}"><code>SolidStateDetectors.siggentodict</code></a></li><li><a href="#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate!</code></a></li><li><a href="#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,S},Int64,Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where S where T"><code>SolidStateDetectors.update!</code></a></li><li><a href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.update_till_convergence!</code></a></li><li><a href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.update_till_convergence!</code></a></li></ul><h1 id="Documentation-1"><a class="docs-heading-anchor" href="#Documentation-1">Documentation</a><a class="docs-heading-anchor-permalink" href="#Documentation-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cartesian}}, Tuple{T}} where T" href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cartesian}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElectricPotential(setup::PotentialSimulationSetup{T, 3, :cartesian} ; kwargs...)::ElectricPotential{T, 3, :cartesian}</code></pre><p>Extracts the electric potential from <code>setup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/ElectricPotential.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.ElectricPotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElectricPotential(setup::PotentialSimulationSetup{T, 3, :cylindrical} ; kwargs...)::ElectricPotential{T, 3, :cylindrical}</code></pre><p>Extracts the electric potential from <code>setup</code> and extrapolate it to an 2π grid.</p><p>For 2D grids (r and z) the user has to set the keyword <code>n_points_in_φ::Int</code>, e.g.: <code>n_points_in_φ = 36</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/ElectricPotential.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Event" href="#SolidStateDetectors.Event"><code>SolidStateDetectors.Event</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Event{T &lt;: SSDFloat}</code></pre><p>Collection struct for individual events. This (mutable) struct is ment to be used to look at individual events, not to process a hugh amount of events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Event/Event.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Grid" href="#SolidStateDetectors.Grid"><code>SolidStateDetectors.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T: tick type
N: N dimensional
S: System (Cartesian, Cylindrical...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Grids/Grids.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointTypes" href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointTypes{T, N, S} &lt;: AbstractArray{T, N}</code></pre><p>PointTypes stores the point type of each grid point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Types/point_types.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.PointTypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PointTypes(setup::PotentialSimulationSetup{T, 3, :cylindrical} ; kwargs...)::PointTypes{T, 3, :cylindrical}</code></pre><p>Extracts the electric potential from <code>setup</code> and extrapolate it to an 2π grid.</p><p>For 2D grids (r and z) the user has to set the keyword <code>n_points_in_φ::Int</code>, e.g.: <code>n_points_in_φ = 36</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/WeightingPotential.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Simulation" href="#SolidStateDetectors.Simulation"><code>SolidStateDetectors.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Simulation{T &lt;: SSDFloat} &lt;: AbstractSimulation{T}</code></pre><p>Collection of all parts of a Simulation of a Solid State Detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.SolidStateDetector" href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetectors.SolidStateDetector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SolidStateDetector{T &lt;: SSDFloat, CS} &lt;: AbstractConfig{T}</code></pre><p>CS: Coordinate System: -&gt; :cartesian / :cylindrical</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/SolidStateDetector/SolidStateDetector.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.VacuumChargeDriftModel" href="#SolidStateDetectors.VacuumChargeDriftModel"><code>SolidStateDetectors.VacuumChargeDriftModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VacuumChargeDriftModel &lt;: AbstractChargeDriftModel</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDriftModels/Vacuum/Vacuum.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.add_fano_noise" href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity</code></pre><p>Add Fano noise to an energy deposition <code>E_dep</code>, assuming a detector material ionisation energy <code>E_ionisation</code> and a Fano factor <code>f_fano</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeStatistics/ChargeStatistics.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Grid{T,N,S} where S where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Grid{T,N,S} where S where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim.detector))::Nothing</code></pre><p>Applies the initial state of the electric potential calculation. It overwrites <code>sim.electric_potential</code>, <code>sim.ρ</code>, <code>sim.ρ_fix</code>, <code>sim.ϵ</code> and <code>sim.point_types</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Grid{T,N,S} where S where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Grid{T,N,S} where S where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim.detector))::Nothing</code></pre><p>Applies the initial state of the weighting potential calculation for the contact with the id <code>contact_id</code>. It overwrites <code>sim.weighting_potentials[contact_id]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_field!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculate_electric_field!(sim::Simulation{T}, args...; n_points_in_φ::Union{Missing, Int} = missing, kwargs...)::Nothing</code></pre><p>ToDo...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L597-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_potential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing</code></pre><p>Compute the electric potential for the given Simulation <code>sim</code> on an adaptive grid through successive over relaxation.</p><p>There are serveral <code>&lt;keyword arguments&gt;</code> which can be used to tune the computation:</p><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>2e-6</code> (times bias voltage).</li><li><code>max_refinements::Int</code>: Number of maximum refinements. Default is <code>2</code>. Set it to <code>0</code> to switch off refinement.</li><li><code>refinement_limits::Tuple{&lt;:Real, &lt;:Real, &lt;:Real}</code>: Tuple of refinement limits for each dimension   (in case of cylindrical coordinates the order is <code>r</code>, <code>φ</code>, <code>z</code>).   A refinement limit (e.g. <code>refinement_limits[1]</code>) times the bias voltage of the detector <code>det</code> is the   maximum allowed voltage difference between two neighbouring grid points in the respective dimension.   When the difference is larger, new points are created inbetween. Default is <code>[1e-5, 1e-5, 1e-5]</code>.</li><li><code>init_grid_spacing::Tuple{&lt;:Real, &lt;:Real, &lt;:Real}</code>: Tuple of the initial distances between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is <code>[0.005, 10.0, 0.005]</code>`.</li><li><code>min_grid_spacing::Tuple{&lt;:Real, &lt;:Real, &lt;:Real}</code>: Tuple of the mimimum allowed distance between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [<code>1e-6</code>, <code>1e-6</code>, <code>1e-6</code>].</li><li><code>grid::Grid{T, N, S}</code>: Initial grid used to start the simulation. Default is <code>Grid(detector, init_grid_spacing=init_grid_spacing)</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is false.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L553-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T},Int64,Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T},Int64,Vararg{Any,N} where N}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_weighting_potential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing</code></pre><p>Compute the weighting potential for the contact with id <code>contact_id</code> for the given Simulation <code>sim</code> on an adaptive grid through successive over relaxation.</p><p>There are serveral <code>&lt;keyword arguments&gt;</code> which can be used to tune the computation:</p><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>2e-6</code> (times bias voltage).</li><li><code>max_refinements::Int</code>: Number of maximum refinements. Default is <code>2</code>. Set it to <code>0</code> to switch off refinement.</li><li><code>refinement_limits::Tuple{&lt;:Real, &lt;:Real, &lt;:Real}</code>: Tuple of refinement limits for each dimension   (in case of cylindrical coordinates the order is <code>r</code>, <code>φ</code>, <code>z</code>).   A refinement limit (e.g. <code>refinement_limits[1]</code>) times the bias voltage of the detector <code>det</code> is the   maximum allowed voltage difference between two neighbouring grid points in the respective dimension.   When the difference is larger, new points are created inbetween. Default is <code>[1e-5, 1e-5, 1e-5]</code>.</li><li><code>init_grid_spacing::Tuple{&lt;:Real, &lt;:Real, &lt;:Real}</code>: Tuple of the initial distances between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is <code>[0.005, 10.0, 0.005]</code>`.</li><li><code>min_grid_spacing::Tuple{&lt;:Real, &lt;:Real, &lt;:Real}</code>: Tuple of the mimimum allowed distance between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [<code>1e-6</code>, <code>1e-6</code>, <code>1e-6</code>].</li><li><code>grid::Grid{T, N, S}</code>: Initial grid used to start the simulation. Default is <code>Grid(detector, init_grid_spacing=init_grid_spacing)</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is false.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L491-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T,3,:cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T,3,:cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.get_active_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_active_volume(pts::PointTypes{T}) where {T}</code></pre><p>Returns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Types/point_types.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{#s17,#s16,#s15} where #s15&lt;:Real where #s16&lt;:Real where #s17&lt;:Real}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{#s14,#s13,#s617} where #s617&lt;:Real where #s13&lt;:Real where #s14&lt;:Real,Tuple{#s618,#s619,#s620} where #s620&lt;:Real where #s619&lt;:Real where #s618&lt;:Real}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{#s17,#s16,#s15} where #s15&lt;:Real where #s16&lt;:Real where #s17&lt;:Real}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{#s14,#s13,#s617} where #s617&lt;:Real where #s13&lt;:Real where #s14&lt;:Real,Tuple{#s618,#s619,#s620} where #s620&lt;:Real where #s619&lt;:Real where #s618&lt;:Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}, minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real})</code></pre><p>Takes the current state of <code>sim.electric_potential</code> and refines it with respect to the input arguments <code>max_diffs</code> and <code>minimum_distances</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{#s249,#s248,#s247} where #s247&lt;:Real where #s248&lt;:Real where #s249&lt;:Real}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{#s246,#s245,#s244} where #s244&lt;:Real where #s245&lt;:Real where #s246&lt;:Real,Tuple{#s243,#s220,#s219} where #s219&lt;:Real where #s220&lt;:Real where #s243&lt;:Real}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{#s249,#s248,#s247} where #s247&lt;:Real where #s248&lt;:Real where #s249&lt;:Real}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{#s246,#s245,#s244} where #s244&lt;:Real where #s245&lt;:Real where #s246&lt;:Real,Tuple{#s243,#s220,#s219} where #s219&lt;:Real where #s220&lt;:Real where #s243&lt;:Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}, minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real})</code></pre><p>Takes the current state of <code>sim.weighting_potentials[contact_id]</code> and refines it with respect to the input arguments <code>max_diffs</code> and <code>minimum_distances</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L328-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.simulate!-Union{Tuple{Simulation{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T}}, Tuple{T}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function simulate!(sim::Simulation{T};  max_refinements::Int = 1, verbose::Bool = false,
                                    depletion_handling::Bool = false, convergence_limit::Real = 1e-5 ) where {T &lt;: SSDFloat}</code></pre><p>ToDo...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L659-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Real}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.update_till_convergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T</code></pre><p>Takes the current state of <code>sim.electric_potential</code> and updates it until it has converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Real}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Real}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.update_till_convergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T</code></pre><p>Takes the current state of <code>sim.weighting_potentials[contact_id]</code> and updates it until it has converged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Simulation/Simulation.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractConfig" href="#SolidStateDetectors.AbstractConfig"><code>SolidStateDetectors.AbstractConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractConfig{T &lt;: SSDFloat} end</code></pre><p>Supertype of all detector/world/object configs.</p><p>User defined geometries must be subtype of <code>AbstractConfig{T}</code>.</p><p>There are a few functions which must be defined for a user config, e.g. <code>struct UserConfig{T} &lt;: AbstractConfig{T}</code>:</p><p>For cylindrical grids:</p><ul><li>in(pt::cylindrical{T}, config::UserConfig{T})::Bool where {T &lt;: SSDFloat}</li><li>Grid(config::UserConfig{T})::Grid{T, 3, :cylindrical} where {T &lt;: SSDFloat}</li><li>get_ρ_and_ϵ(pt::cylindrical{T}, config::UserConfig{T})::Tuple{T, T} where {T &lt;: SSDFloat} </li><li>set_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, :cylindrical}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T &lt;: SSDFloat}</li></ul><p>For cartesian grids:</p><ul><li>in(pt::StaticVector{3, T}, config::UserConfig{T})::Bool </li><li>Grid(config::UserConfig{T})::Grid{T, 3, :cartesian} where {T &lt;: SSDFloat}</li><li>get_ρ_and_ϵ(pt::StaticVector{3, T}, config::UserConfig{T})::Tuple{T, T} where {T &lt;: SSDFloat} </li><li>set_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, :cartesian}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T &lt;: SSDFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Config/Config.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractLine" href="#SolidStateDetectors.AbstractLine"><code>SolidStateDetectors.AbstractLine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractLine{T, N, S} &lt;: AbstractGeometry{T, N} end</code></pre><p>T: eltype N: Dimension S: Coordinate System: <code>:cartesian</code> or <code>:cylindrical</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/LinePrimitives/LinePrimitives.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Box" href="#SolidStateDetectors.Box"><code>SolidStateDetectors.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Box{T} &lt;: AbstractGeometry{T, 3}</code></pre><p>Very simple rectengular box in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/VolumePrimitives/Box.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstantChargeDensityModel" href="#SolidStateDetectors.ConstantChargeDensityModel"><code>SolidStateDetectors.ConstantChargeDensityModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ConstantChargeDensityModel{T &lt;: SSDFloat} &lt;: AbstractChargeDensityModel{T}</code></pre><p>Returns always a fixed charge density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDensityModels/ChargeDensityModels.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Contact" href="#SolidStateDetectors.Contact"><code>SolidStateDetectors.Contact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Contact{T} &lt;: AbstractContact{T}</code></pre><p>T: Type of precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/SolidStateDetector/Contacts.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Difference" href="#SolidStateDetectors.Difference"><code>SolidStateDetectors.Difference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Difference{T, N, A, B} &lt;: AbstractSet{T, N}</code></pre><p>a &amp;&amp; !b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/Sets.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DiscreteAxis" href="#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteAxis{T, BL, BR} &lt;: AbstractAxis{T, BL, BR}</code></pre><ul><li>T: Type of ticks</li><li>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} </li><li>BL: left boundary condition</li><li>BR: right boundary condition</li><li>I: IntervalSets.Interval (closed or open boundaries)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Axes/DiscreteAxis.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T,T,Symbol,Symbol,Symbol,Symbol,AbstractArray{T,1}}} where T" href="#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T,T,Symbol,Symbol,Symbol,Symbol,AbstractArray{T,1}}} where T"><code>SolidStateDetectors.DiscreteAxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}</code></pre><ul><li>T: Type of ticks</li><li>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} </li><li>L, R {:closed, :open} </li><li>ticks: Ticks of the axis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Axes/DiscreteAxis.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.GeometryUnion" href="#SolidStateDetectors.GeometryUnion"><code>SolidStateDetectors.GeometryUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeometryUnion{T, N, A, B} &lt;: AbstractSet{T, N}</code></pre><p>a || b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/Sets.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Intersection" href="#SolidStateDetectors.Intersection"><code>SolidStateDetectors.Intersection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Intersection{T, N, A, B} &lt;: AbstractSet{T, N}</code></pre><p>a &amp;&amp; b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/Sets.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Line" href="#SolidStateDetectors.Line"><code>SolidStateDetectors.Line</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Line{T, N, S} &lt;: AbstractLine{T, N, S}</code></pre><p>&lt;––A–––––B––&gt;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/LinePrimitives/LinePrimitives.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.LineSegment" href="#SolidStateDetectors.LineSegment"><code>SolidStateDetectors.LineSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LineSegment{T, N, S} &lt;: AbstractLine{T, N, S}

[A----------B]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/LinePrimitives/LinePrimitives.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.LinearChargeDensityModel" href="#SolidStateDetectors.LinearChargeDensityModel"><code>SolidStateDetectors.LinearChargeDensityModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LinearChargeDensityModel{T &lt;: SSDFloat} &lt;: AbstractChargeDensityModel{T}</code></pre><p>Simple charge density model which assumes a linear gradient in charge density in each dimension. <code>offsets::NTuple{3, T}</code> are the charge densities at 0 and <code>gradients::NTuple{3, T}</code> are the linear slopes in each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDensityModels/ChargeDensityModels.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointType" href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const PointType = UInt8</code></pre><p>Stores certain information about a grid point via bit-flags. </p><p>Right now there are:</p><pre><code class="language-none">`const update_bit      = 0x01`
`const undepleted_bit  = 0x02`
`const pn_junction_bit = 0x04`</code></pre><p>How to get information out of a PointType variable <code>pt</code>:</p><ol><li><code>pt &amp; update_bit == 0</code> -&gt; do not update this point (for fixed points)     </li><li><code>pt &amp; update_bit &gt;  0</code> -&gt; do update this point    </li><li><code>pt &amp; undepleted_bit &gt; 0</code> -&gt; this point is undepleted</li><li><code>pt &amp; pn_junction_bit &gt; 0</code> -&gt; this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Types/point_types.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PotentialSimulationSetup" href="#SolidStateDetectors.PotentialSimulationSetup"><code>SolidStateDetectors.PotentialSimulationSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PotentialSimulationSetup{T, N, S} &lt;: AbstractPotentialSimulationSetup{T, N}</code></pre><p>Collection struct. It holds the grid, the potential, the point types, the charge density and the dielectric distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/PotentialSimulationSetups/PotentialSimulationSetups.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Ray" href="#SolidStateDetectors.Ray"><code>SolidStateDetectors.Ray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Ray{T, N, S} &lt;: AbstractLine{T, N, S}

[A----------B----&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/LinePrimitives/LinePrimitives.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RectangularCuboid" href="#SolidStateDetectors.RectangularCuboid"><code>SolidStateDetectors.RectangularCuboid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RectangularCuboid{T} &lt;: AbstractGeometry{T, 3}</code></pre><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/Geometries/VolumePrimitives/RectangularCuboid.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ZeroChargeDensityModel" href="#SolidStateDetectors.ZeroChargeDensityModel"><code>SolidStateDetectors.ZeroChargeDensityModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ZeroChargeDensityModel{T &lt;: SSDFloat} &lt;: AbstractChargeDensityModel{T}</code></pre><p>Returns always 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDensityModels/ChargeDensityModels.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T" href="#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T"><code>SolidStateDetectors.RBArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RBExtBy2Array( et::Type, g::Grid{T, N, :cylindrical} )::Array{et, N + 1} where {T, N}</code></pre><p>Returns a RedBlack array for the grid <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/RedBlack/RedBlack.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T" href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T"><code>SolidStateDetectors.RBExtBy2Array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RBExtBy2Array( et::Type, g::Grid{T, N, :cylindrical} )::Array{et, N + 1} where {T, N}</code></pre><p>Returns a RedBlack array for the grid <code>g</code>. The RedBlack array is extended in its size by 2 in each geometrical dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/RedBlack/RedBlack.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type,Grid{T,3,:cartesian}}} where T" href="#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type,Grid{T,3,:cartesian}}} where T"><code>SolidStateDetectors.RBExtBy2Array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RBExtBy2Array( et::Type, g::Grid{T, 3, :cartesian} )::Array{et, 4} where {T}</code></pre><p>Returns a RedBlack array for the grid <code>g</code>. The RedBlack array is extended in its size by 2 in each geometrical dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/RedBlack/RedBlack.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors._drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,:cartesian},PointTypes{T,3,:cartesian},Grid{T,3,:cartesian},CartesianPoint{T},T,Interpolations.Extrapolation{#s248,3,ITPT,IT,ET} where ET where IT where ITPT where #s248&lt;:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors._drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,:cartesian},PointTypes{T,3,:cartesian},Grid{T,3,:cartesian},CartesianPoint{T},T,Interpolations.Extrapolation{#s248,3,ITPT,IT,ET} where ET where IT where ITPT where #s248&lt;:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors._drift_charge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Before calling this function one should check that `startpos` is inside `det`: `in(startpos, det`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDrift/ChargeDriftCartesian.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors._drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,:cylindrical},PointTypes{T,3,:cylindrical},Grid{T,3,:cylindrical},CartesianPoint{T},T,Interpolations.Extrapolation{#s248,3,ITPT,IT,ET} where ET where IT where ITPT where #s248&lt;:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors._drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,:cylindrical},PointTypes{T,3,:cylindrical},Grid{T,3,:cylindrical},CartesianPoint{T},T,Interpolations.Extrapolation{#s248,3,ITPT,IT,ET} where ET where IT where ITPT where #s248&lt;:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors._drift_charge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_drift_charge(...)</code></pre><p>Before calling this function one should check that <code>startpos</code> is inside <code>det</code>: <code>in(startpos, det</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDrift/ChargeDriftCylindrical.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SArray{Tuple{3},T,1,3},3},ADLChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SArray{Tuple{3},T,1,3},3},ADLChargeDriftModel}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_electron_drift_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::ADLChargeDriftModel)::Array{SVector{3,T},3} where {T &lt;: SSDFloat}</code></pre><p>Applies the charge drift model onto the electric field vectors. The field vectors have to be in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/ChargeDriftModels/ADL/ADL.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_path_to_example_config_files-Tuple{}" href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_path_to_example_config_files()::String</code></pre><p>Returns the path to example config files provided by the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/examples.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64,Val{true},Val{true}}" href="#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64,Val{true},Val{true}}"><code>SolidStateDetectors.get_rbidx_right_neighbour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_rbidx_right_neighbour(rbidx::Int, ::Val{true}, ::Val{true})::Int</code></pre><p>needs docu...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/RedBlack/RedBlack.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cartesian},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T" href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cartesian},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T"><code>SolidStateDetectors.innerloops!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">innerloops!(  iz::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_x::Array{T, 2}, gw_y::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, :cartesian},
                            update_even_points::Val{even_points},
                            depletion_handling::Val{depletion_handling_enabled},
                            bulk_is_ptype::Val{_bulk_is_ptype}  )::Nothing where {T, even_points, depletion_handling_enabled, _bulk_is_ptype}</code></pre><p>(Vectorized) inner loop for Cartesian coordinates. This function does all the work in the field calculation.                            </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/SimulationAlgorithms/Cartesian3D.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cylindrical},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T" href="#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cylindrical},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T"><code>SolidStateDetectors.innerloops!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">innerloops!(  ir::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_r::Array{T, 2}, gw_φ::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, :cylindrical},
                            update_even_points::Val{even_points},
                            depletion_handling::Val{depletion_handling_enabled},
                            bulk_is_ptype::Val{_bulk_is_ptype}  )::Nothing where {T, even_points, depletion_handling_enabled, _bulk_is_ptype}</code></pre><p>(Vectorized) inner loop for Cylindrical coordinates. This function does all the work in the field calculation.                            </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/SimulationAlgorithms/Cylindrical.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.nidx-Tuple{Int64,Val{true},Val{true}}" href="#SolidStateDetectors.nidx-Tuple{Int64,Val{true},Val{true}}"><code>SolidStateDetectors.nidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nidx( rbidx::Int, ::Val{true}, ::Val{true})::Int</code></pre><p>first type argument:  type of the orgal point (for even points -&gt; <code>Val{true}()</code>, else <code>Val{false}()</code>) second type argument: is sum of other point indices even or odd -&gt; (if sum is even -&gt; <code>Val{true}()</code>, else <code>Val{false}()</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/RedBlack/RedBlack.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.parse_config_file-Tuple{AbstractString}" href="#SolidStateDetectors.parse_config_file-Tuple{AbstractString}"><code>SolidStateDetectors.parse_config_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SolidStateDetector{T}(filename::AbstractString)::SolidStateDetector{T} where {T &lt;: SSDFloat}</code></pre><p>Reads in a config-JSON file and returns an Detector struct which holds all information specified in the config file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/SolidStateDetector/DetectorGeometries.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T,CS} where CS,Grid{T,3,S} where S,CartesianPoint{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T,CS} where CS,Grid{T,3,S} where S,CartesianPoint{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.point_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">For charge drift...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/SolidStateDetector/DetectorGeometries.jl#L156-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.readsiggen-Tuple{String}" href="#SolidStateDetectors.readsiggen-Tuple{String}"><code>SolidStateDetectors.readsiggen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readsiggen(file_path::String[, T::Type=Float64])</code></pre><p>Read the &#39;*.config&#39; file in &#39;file_path&#39; for SigGen and returns a dictionary of all parameters. Non-existing parameteres are set to 0. ...</p><p><strong>Arguments</strong></p><ul><li><code>file_path::String</code>: file path for the SigGen config file.</li><li><code>T::Type=Float64</code>: type of the parameters in the output dictionary.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/SolidStateDetector/SigGenInterface.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.siggentodict-Tuple{Dict}" href="#SolidStateDetectors.siggentodict-Tuple{Dict}"><code>SolidStateDetectors.siggentodict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">siggentodict(config::Dict[, units::Dict, detector_name::String])</code></pre><p>Converts the dictionary containing the parameters from a SigGen config file to a SSD config dictionary. This dictionary can be saved as a JSON file using the JSON package and &#39;JSON.print(file, config, 4)&#39;. The &#39;detector_name&#39; is set to &quot;Public Inverted Coax&quot; by default to inherit the colour scheme. ...</p><p><strong>Arguments</strong></p><ul><li><code>config::Dict</code>: dictionary containing SigGen parameters (output of readsiggen()).</li><li><code>units::Dict</code>: units used in SigGen file (set to &#39;mm&#39;, &#39;deg&#39;, &#39;V&#39; and &#39;K&#39;).</li><li><code>detector_name::String</code>: name of the detector.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/SolidStateDetector/SigGenInterface.jl#L105-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,S},Int64,Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where S where T" href="#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,S},Int64,Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where S where T"><code>SolidStateDetectors.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(fssrb::PotentialSimulationSetupRB{T, 3, 4, S}, RBT::DataType)::Nothing</code></pre><p>Loop over <code>even</code> grid points. A point is <code>even</code> if the sum of its cartesian indicies (of the not extended grid) is even. Even points get the red black index (rbi) = 2. ( -&gt; rbpotential[ inds..., rbi ]).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/14e83c1de7c3df389e5b562782e3c82ca7dc5c4f/src/PotentialSimulation/SimulationAlgorithms/Cylindrical.jl#L1-L6">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../LICENSE/">LICENSE »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 19 March 2020 09:26">Thursday 19 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
