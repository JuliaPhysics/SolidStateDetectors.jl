<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geant4 Support Â· SolidStateDetectors.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/tutorials/geant4_ssd/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="SolidStateDetectors.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/config_files/">Configuration Files</a></li><li><a class="tocitem" href="../../man/csg/">Constructive Solid Geometry (CSG)</a></li><li><a class="tocitem" href="../../man/Grids/">Grids</a></li><li><a class="tocitem" href="../../man/electric_potential/">Electric Potential</a></li><li><a class="tocitem" href="../../man/electric_field/">Electric Field</a></li><li><a class="tocitem" href="../../man/charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../../man/capacitances/">Capacitances</a></li><li><a class="tocitem" href="../../man/IO/">IO</a></li><li><a class="tocitem" href="../../man/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../complete_simulation_chain_IVC/">Simulation Chain: Inverted Coax Detector</a></li><li><a class="tocitem" href="../custom_impurity_density_pn_junction/">Advanced Example: Custom Impurity Profile</a></li><li class="is-active"><a class="tocitem" href>Geant4 Support</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Geant4 Support</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Geant4 Support</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/main/docs/src/tutorials/geant4_ssd_lit.jl" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Geant4-Support"><a class="docs-heading-anchor" href="#Geant4-Support">Geant4 Support</a><a id="Geant4-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Geant4-Support" title="Permalink"></a></h1><p>SolidStateDetectors.jl provides an extension for Geant4.jl. This extension allows to simulate realistic event distributions resulting from particles emitted by a given source, which can be used as input to the waveform simulation.</p><p>To use the extension, both <code>SolidStateDetectors</code> and <code>Geant4</code> have to be loaded.</p><pre><code class="language-julia hljs">using SolidStateDetectors
using Geant4</code></pre><p>In order to run <code>Geant4</code> simulations, a <code>Geant4.G4JLApplication</code> needs to be defined based on the detector geometry and the particle source. The extension features a function that creates a <code>Geant4.G4JLApplcation</code> from an SSD <code>Simulation</code> object and a particle source.</p><pre><code class="language-julia hljs">using Plots
using Unitful</code></pre><p>Two types of particle source are pre-defined in <code>SolidStateDetectors</code>:</p><h4 id=".-MonoenergeticSource"><a class="docs-heading-anchor" href="#.-MonoenergeticSource">1. <code>MonoenergeticSource</code></a><a id=".-MonoenergeticSource-1"></a><a class="docs-heading-anchor-permalink" href="#.-MonoenergeticSource" title="Permalink"></a></h4><p>This source emits particles of the same type and same energy.</p><pre><code class="language-julia hljs">source_1 = MonoenergeticSource(
    &quot;gamma&quot;,                              # Type of particle beam
    2.615u&quot;MeV&quot;,                          # Energy of particle
    CartesianPoint(0.065, 0., 0.05),      # Location of the source
    CartesianVector(-1,0,0),              # Direction of the source
    10u&quot;Â°&quot;                                # Opening angle of the source emission
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MonoenergeticSource(&quot;gamma&quot;, 2.615 MeV, [0.065, 0.0, 0.05], [-1.0, 0.0, 0.0], 10Â°)</code></pre><ul><li>The particle type is given as a string (e.g. <code>&quot;e-&quot;</code> or <code>&quot;gamma&quot;</code>) and directly passed to <code>Geant4</code>. See the <code>Geant4</code> documentation on how to name the desired particle type.</li><li>The energy of the emitted particles is passed as a number with unit.</li><li>The <code>position</code> of the particle source relative to the origin is defined by a <code>CartesianPoint</code> (in units of <code>m</code>).</li><li>The source can emit particles in a given <code>direction</code> if a <code>CartesianVector</code> is provided. If not, the emission is isotropic.</li><li>If an <code>opening_angle</code> is provided, the source emits via a directed cone with the defined opening angle.</li></ul><h4 id=".-IsotopeSource"><a class="docs-heading-anchor" href="#.-IsotopeSource">2. <code>IsotopeSource</code></a><a id=".-IsotopeSource-1"></a><a class="docs-heading-anchor-permalink" href="#.-IsotopeSource" title="Permalink"></a></h4><p>This source emits particles based on the radioactive decay chain of a given isotope.</p><pre><code class="language-julia hljs">source_2 = IsotopeSource(
    82,                                # Number of protons
    212,                               # Total number of nucleons
    0.0,                               # Excitation energy
    0.0,                               # Ion charge
    CartesianPoint(0.06, 0, 0.05),     # Location of the source
    CartesianVector(-1,0,0),           # Direction of the source
    10u&quot;Â°&quot;                             # Opening angle of the source emission
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">IsotopeSource(82, 212, 0.0, 0.0, [0.06, 0.0, 0.05], [-1.0, 0.0, 0.0], 10Â°)</code></pre><p>The source is defined using</p><ul><li>The number of protons <code>Z</code> and the number of nucleons <code>A</code> in the isotope. &lt;br/&gt;</li><li>The excitation energy</li><li>The charge of the isotope</li><li>The position, direction and opening angle from the source can be defined in the same way as for a <code>MonoenergeticSource</code></li></ul><p>The particle source can now be plotted together with the detector, as well as the direction in which particles are emitted.</p><pre><code class="language-julia hljs">T = Float32
sim = Simulation{T}(SSD_examples[:InvertedCoaxInCryostat])
plot(sim.detector, size = (500,500))
plot!(source_1)</code></pre><p><a href="../detector.pdf"><img src="../detector.svg" alt="detector"/></a></p><p>A <code>Geant4.G4JLApplication</code> is built from a SSD <code>Simulation</code> <code>sim</code> and one of the previously defined particle sources, e.g. <code>source_1</code>.</p><p>Internally, a GDML file is created that is subsequently read in by <code>Geant4.jl</code>. &lt;br/&gt; If needed, the resulting GDML file can also be saved by using the <code>Geant4.G4JLDetector(sim, &quot;output_filename.gdml&quot;)</code> command.</p><pre><code class="language-julia hljs">app = G4JLApplication(sim, source_1, verbose = false);</code></pre><p>The method <code>run_geant4_simulation</code> is used to generate a given number of events.</p><pre><code class="language-julia hljs">N_events = 50000
events = run_geant4_simulation(app, N_events)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Table with 5 columns and 50000 rows:
      evtno  detno                 thit                  edep                  â‹¯
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 1  â”‚ 1      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 2  â”‚ 2      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 3  â”‚ 3      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 4  â”‚ 4      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 5  â”‚ 5      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 6  â”‚ 6      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 7  â”‚ 7      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 8  â”‚ 8      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 9  â”‚ 9      Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 10 â”‚ 10     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 11 â”‚ 11     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 12 â”‚ 12     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 13 â”‚ 13     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 14 â”‚ 14     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 15 â”‚ 15     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 16 â”‚ 16     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 17 â”‚ 17     Int32[1, 1, 1, 1, 1â€¦  Quantity{Float32, ğ“â€¦  Quantity{Float32, ğ‹â€¦  â‹¯
 â‹®  â”‚   â‹®             â‹®                     â‹®                     â‹®            â‹±</code></pre><p>Each entry of the table corresponds to one event and consists of five fields:</p><ul><li><code>evtno</code>: Event number</li><li><code>detno</code>: Index of the detector where the energy was deposited</li><li><code>thit</code>: Time of the interaction</li><li><code>edep</code>: Amount of energy that was deposited in the detector</li><li><code>pos</code>: Position where the interaction happened</li></ul><p>By extracting the position of each energy deposition from <code>events</code>, the spatial distribution of the events inside the detector can be plotted:</p><pre><code class="language-julia hljs">plot(sim.detector, show_passives = false, size = (500,500), fmt = :png)
plot!(source_1)
plot!(CartesianPoint.(broadcast(p -&gt; ustrip.(u&quot;m&quot;, p), events[1:1000].pos.data)), ms = 0.5, msw = 0, color=:black, label = &quot;&quot;)</code></pre><p><a href="../events.pdf"><img src="../events.svg" alt="events"/></a></p><p>The output of <code>run_geant4_simulation</code> can be stored using the <code>LegendHDF5IO</code> package:</p><pre><code class="nohighlight hljs">using LegendHDF5IO

lh5open(&quot;simulation_output.lh5&quot;, &quot;w&quot;) do h
     LegendHDF5IO.writedata(h.data_store, &quot;SimulationData&quot;, events)
end

events_in = lh5open(&quot;simulation_output.lh5&quot;, &quot;r&quot;) do h
    LegendHDF5IO.readdata(h.data_store, &quot;SimulationData&quot;)
end</code></pre><p>In order to visualize the energy spectrum of the events in a histogram, you can use the following code:</p><pre><code class="language-julia hljs">using StatsBase

h = fit(Histogram, ustrip.(u&quot;keV&quot;, sum.(events.edep)), Weights(fill(10,length(events.edep))), 0:10:3000)

plot(h, title = &quot;Energy spectrum&quot;, bins = 500, yscale = :log10, st = :step, label = &quot;&quot;)
xlims!(0,3000, xlabel = &quot;E in keV&quot;, ylabel = &quot;counts&quot;)</code></pre><p><a href="../spectrum.pdf"><img src="../spectrum.svg" alt="spectrum"/></a></p><p>Now that the energy depositions in the detector are simulated, they can be passed to SSD to calculate the corresponding waveforms. This requires to calculate the electric potential, the electric field and the weighting potential of the detector first.</p><pre><code class="language-julia hljs">sim.detector = SolidStateDetector(sim.detector, ADLChargeDriftModel(T=T))
calculate_electric_potential!(sim, refinement_limits = [0.4,0.2,0.1,0.06], verbose = false)
calculate_electric_field!(sim, n_points_in_Ï† = 10)
calculate_weighting_potential!(sim, 1, refinement_limits = [0.4,0.2,0.1,0.06], verbose = false)</code></pre><p>The waveforms can be simulated using <code>simulate_waveforms</code>:</p><pre><code class="language-julia hljs">wf = simulate_waveforms(events[1:100], sim, Î”t = 1u&quot;ns&quot;, max_nsteps = 2000)
plot(wf[1:20].waveform, label = &quot;&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Detector has 2 contacts
[ Info: Table has 100 physics events (4166 single charge depositions).
Progress:   2%|â–‰                                        |  ETA: 0:02:19Progress:  28%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œ                             |  ETA: 0:00:10Progress:  47%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–                     |  ETA: 0:00:05Progress:  59%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–                |  ETA: 0:00:04Progress:  74%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–          |  ETA: 0:00:02Progress:  90%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‰    |  ETA: 0:00:01Progress: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| Time: 0:00:07
[ Info: Generating waveforms...</code></pre><p><a href="../waveforms.pdf"><img src="../waveforms.svg" alt="waveforms"/></a></p><p>We can add some baseline and tail to the pulses to match their lengths (in this case to 2000ns):</p><pre><code class="language-julia hljs">w = add_baseline_and_extend_tail.(wf.waveform, 100, 2000)
plot(w[1:20], label = &quot;&quot;)</code></pre><p><a href="../wf_and_amplitude.pdf"><img src="../wf_and_amplitude.svg" alt="wf_and_amplitude"/></a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_impurity_density_pn_junction/">Â« Advanced Example: Custom Impurity Profile</a><a class="docs-footer-nextpage" href="../../api/">API Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 13 September 2024 15:09">Friday 13 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
