var documenterSearchIndex = {"docs":
[{"location":"man/config_files/#Config-Files","page":"Config Files","title":"Config Files","text":"","category":"section"},{"location":"man/config_files/#Example-Detector-Config-Files","page":"Config Files","title":"Example Detector Config Files","text":"","category":"section"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"Currently, there are four predefined example detectors. ","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"Three of them are cylindrical detectors:","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"* Coaxial detector (Coax)\r\n* Inverted coax detector (IVC)\r\n* BEGe type detector (BEGe)","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"The fourth one is in cartesian coordinates:","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"* simple cube detector (CGD)","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"They are all specified in their JSON config files, which can be found under: <package_directory>/examples/example_detector_config_files/<config_filename>.json.","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"In Julia, their path is already saved in the SolidStateDetectors.jl package in a dictionary:","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"    using SolidStateDetectors\r\n    SSD_examples # dictionary holding the full path to the corresponding config JSON files\r\n    SSD_exmpless[:Coax]","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"The keys are: :Coax, :InvertedCoax, :BEGe, :CGD.","category":"page"},{"location":"man/config_files/#Example-1)-Inverted-Coax","page":"Config Files","title":"Example 1) Inverted Coax","text":"","category":"section"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"Example minimum config file for an Inverted Coax detector (IVC) plus explanations. Remember, comments are not allowed in JSON files and have to be deleted if you want to use it.","category":"page"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"{\r\n    name = \"Example Detector\",\r\n    ToDo...\r\n}","category":"page"},{"location":"man/config_files/#UserConfigs:-Define-your-own-geometry","page":"Config Files","title":"UserConfigs: Define your own geometry","text":"","category":"section"},{"location":"man/config_files/","page":"Config Files","title":"Config Files","text":"ToDo...","category":"page"},{"location":"man/csg/#Constructive-Solid-Geometry-(CSG)","page":"CSG","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"man/csg/#Boolean-operators","page":"CSG","title":"Boolean operators","text":"","category":"section"},{"location":"man/csg/#Union","page":"CSG","title":"Union","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"\"geometry\": {\n    \"type\": \"union\",\n    \"parts\": [\n        {\n            \"name\":\"Seg1 bottom\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 13.5,\n                \"to\": 39.5\n            },\n            \"phi\": {\n                \"from\": 0.3582,\n                \"to\": 59.6419\n            },\n            \"h\": 0\n        },\n        {\n            \"name\": \"Seg1 side\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 39.5,\n                \"to\": 39.5\n            },\n            \"phi\": {\n                \"from\": 0.3582,\n                \"to\": 59.6419\n            },\n            \"h\": 40\n        },\n    }\n}","category":"page"},{"location":"man/csg/#Difference","page":"CSG","title":"Difference","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"\"geometry\": {\n    \"type\": \"difference\",\n    \"parts\": [\n        {\n            \"name\": \"Initial Cylinder\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 0.0,\n                \"to\":  35.0\n            },\n            \"phi\": {\n                \"from\": 0.0,\n                \"to\": 360.0\n            },\n            \"z\": {\n                \"from\": 0,\n                \"to\":  40\n            }\n        },\n        {\n            \"name\": \"Borehole\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 0.0,\n                \"to\":   5.0\n            },\n            \"phi\": {\n                \"from\": 0.0,\n                \"to\": 360.0\n            },\n            \"z\": {\n                \"from\": 0,\n                \"to\":  40\n            }\n        }\n    ]\n}","category":"page"},{"location":"man/csg/#Intersection","page":"CSG","title":"Intersection","text":"","category":"section"},{"location":"man/csg/","page":"CSG","title":"CSG","text":"ToDo...","category":"page"},{"location":"man/IO/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"ToDo...","category":"page"},{"location":"man/electric_potentials/#Electric-Potentials","page":"Electric Potentials","title":"Electric Potentials","text":"","category":"section"},{"location":"man/electric_potentials/#Simulation-Algorithm","page":"Electric Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The electric potential is calculated through successive over relaxation (SOR).","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The calculation is based on Gauss' law in matter","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"nabla left( epsilon_r(vecr) nabla Phi(vecr)right) = dfracrho(vecr)epsilon_0","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"where Phi is the electric potential, rho is the charge density, epsilon_r is the dielectric distribution and epsilon_0 is the dielectric constant of the vacuum.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The equation is numerically solved on a 3-dimensional adaptive red/black grid.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"Cylindrical and cartesian coordinates are supported.","category":"page"},{"location":"man/electric_potentials/#Multithreading","page":"Electric Potentials","title":"Multithreading","text":"","category":"section"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"To use multiple threads for the simulation, the environement variable JULIA_NUM_THREADS must be set before Julia is started. In case of bash this is done through","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"Note that the user still has to parse the number of threads to the function as a keyword nthreads.","category":"page"},{"location":"man/electric_potentials/","page":"Electric Potentials","title":"Electric Potentials","text":"ToDo...","category":"page"},{"location":"man/primitives/#CSG-Primitives","page":"Primitives","title":"CSG Primitives","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"CSG = Constructive Solid Geometries","category":"page"},{"location":"man/primitives/#Primitve:-Box","page":"Primitives","title":"Primitve: Box","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"box\",\n    \"x\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    },\n    \"y\":{\n        \"from\": 0.0,\n        \"to\":  10.0\n    },\n    \"z\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    }\n}","category":"page"},{"location":"man/primitives/#Primitve:-Tube","page":"Primitives","title":"Primitve: Tube","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"tube\",\n    \"r\": {\n        \"from\": 3.0,\n        \"to\":   7.0\n    },\n    \"phi\": {\n        \"from\": 0.0,\n        \"to\": 360.0\n    },\n    \"z\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    }\n}","category":"page"},{"location":"man/primitives/#Primitve:-Cone","page":"Primitives","title":"Primitve: Cone","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"cone\",\n    \"r\": {\n        \"bottom\": {\n            \"from\": 10.0,\n            \"to\": 20.0\n        },\n        \"top\": {\n            \"from\": 5.0,\n            \"to\": 25.0\n        }\n    },\n    \"phi\": {\n        \"from\": 0.0,\n        \"to\": 360.0\n    },\n    \"z\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    }\n}","category":"page"},{"location":"man/primitives/#Primitve:-Sphere","page":"Primitives","title":"Primitve: Sphere","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"sphere\",\n    \"r\": 30,\n    \"translate\": {\n        \"x\": 0,\n        \"y\": 0,\n        \"z\": 0\n    }\n}","category":"page"},{"location":"man/primitives/#Add-new-Primitive","page":"Primitives","title":"Add new Primitive","text":"","category":"section"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"If you need a primitive which is not yet implemented you can implemented yourself and make a PR on GitHub :)","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"There are a few functions you will have to define for a new primitive. Here is a layout for a new primitive. Place the struct and all the functions in a file 'NewPrimitive.jl' inside '<SSD>/src/Geometries/VolumePrimitives' and include it in the file '<SSD>/src/Geometries/VolumePrimitives/VolumePrimitives.jl'","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"Note that internally everything is in SI units. So please have a look in the already implemented primitives (Box, Sphere, Tube, ...) how the conversion from config file units to SI units is done. ","category":"page"},{"location":"man/primitives/","page":"Primitives","title":"Primitives","text":"struct NewPrimitive{T} <: AbstractVolumePrimitive{T, 3}\n    # fields of the new primitive\nend\n\nfunction in(pt::CartesianPoint{T}, g::NewPrimitive{T})::Bool where {T}\n    # pt in NewPrimitive?\nend\nfunction in(pt::CylindricalPoint{T}, g::NewPrimitive{T})::Bool where {T}\n    # pt in NewPrimitive?\nend\n\n# You also have to implement the function to obtain the primitive from a config file (so an dic)\n# You also should provide a example config file containing this new primitive\nfunction NewPrimitive{T}(dict::Union{Dict{Any, Any}, Dict{String, Any}}, inputunit_dict::Dict{String,Unitful.Units})::NewPrimitive{T} where {T <: SSDFloat}\n    # ... parse values from dict to NewPrimitive{T}(...)\n    return NewPrimitive{T}(\n        # ...\n    )\nend\nfunction Geometry(T::DataType, t::Val{:newprimitive}, dict::Dict{Any, Any}, inputunit_dict::Dict{String,Unitful.Units})\n    return NewPrimitive{T}(dict, inputunit_dict)\nend\n\n# Also a plot recipe for this new primitive should be provided:\n@recipe function f(cb::NewPrimitive{T}) where {T <: SSDFloat}\n    label --> \"NewPrimitive\"\n    # ...\nend\n\n# For proper grid creation we also need the function get_important_points:\nfunction get_important_points(g::NewPrimitive{T}, ::Val{:r})::Vector{T} where {T <: SSDFloat}\n    return T[ # ... ]\nend\nfunction get_important_points(g::NewPrimitive{T}, ::Val{:φ})::Vector{T} where {T <: SSDFloat}\n    return T[ # ... ]\nend\nfunction get_important_points(g::NewPrimitive{T}, ::Val{:z})::Vector{T} where {T <: SSDFloat}\n    return T[ # ... ]\nend\nfunction get_important_points(g::NewPrimitive{T}, ::Val{:x})::Vector{T} where {T <: SSDFloat}\n    return T[ # ... ]\nend\nfunction get_important_points(g::NewPrimitive{T}, ::Val{:y})::Vector{T} where {T <: SSDFloat}\n    return T[ # ... ]\nend\n\n# and a sample function to paint the primitive on the grid (necessary if the object is small)\nfunction sample(cb::NewPrimitive{T}, stepsize::Vector{T})  where {T <: SSDFloat}\n    samples  = CartesianPoint{T}[]\n    # ...\n    return samples\nend\n\n# add a (+) method to shift the primitive \nfunction (+)(b::NewPrimitive{T}, translate::Union{CartesianVector{T},Missing})::NewPrimitive{T} where {T <: SSDFloat}\n    # ...\n    return NewPrimitive( # ...  )\nend","category":"page"},{"location":"man/weighting_potentials/#Weighting-Potentials","page":"Weighting Potentials","title":"Weighting Potentials","text":"","category":"section"},{"location":"man/weighting_potentials/#Simulation-Algorithm","page":"Weighting Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential for an electrode is internally calculated with the same function as the electric potential.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The only difference is that the charge carrier density ρ(vecr) is set to 0 and all electrodes are fixed to 0 but the one electrode which is fixed to 1.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"ToDo...","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package is a registered package.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Install via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add SolidStateDetectors\"","category":"page"},{"location":"man/installation/#Vizualization-/-Plotting-(Optional)","page":"Installation","title":"Vizualization / Plotting (Optional)","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package provides serveral plot recipes for different outputs for the plotting package Plots.jl.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use these also install the Plots.jl package via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add Plots\"","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"It is recommended to use pyplot as backend. Install via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add PyPlot\"","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Then you can load it via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Plots; pyplot();","category":"page"},{"location":"man/drift_fields/#Drift-Fields","page":"Drift Fields","title":"Drift Fields","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"Charged particles in vacuum move along the electric field lines under Coulomb's force, bmF = q bmE, where bmF corresponds to the force experienced by the particle, q is the charge of the particle and bmE is the electric field. Charged particles in vacuum would be continuously accelerated until approaching the speed of light (called ballistic transport), however, inside a material, scattering prevents this constant acceleration and leads to a constant drift velocity ","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"v_d = mu E","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"where v_d is the drift velocity, mu the mobility and E the electric field strength.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The scattering with matter not only limits the absolute drift velocity, it might also deviate the trajectories from the electric field lines: e.g., in crystals, the principal axes orientation has an impact on the resulting drift trajectory. The influence of the scattering on the drift trajectories can be expressed by a 3x3 tensor, the so-called mobility tensor mu_ij, which transforms the electric field, E, into the drift field, v_i:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"v_i =  mu_ij cdot E_j","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The mobility varies for different materials and depends also on other parameters such as temperature, impurity concentration and on the electric field strenght, as explained later.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"Electrons and holes have different mobilities, resulting in different drift fields. There are several models for the mobility tensor of electrons and holes in certain materials. Right now, two models are implemented. The first one is a pseudo-drift model, the ElectricFieldChargeDriftModel, which just takes the electric field vectors as drift vectors, see section Electric Field Charge Drift Model. The second one, ADLChargeDriftModel, is a drift model for high purity germanium, see section ADL Charge Drift Model. However, the implementation of an own model is possible and explained in section Custom Charge Drift Model.","category":"page"},{"location":"man/drift_fields/#Electric-Field-Charge-Drift-Model","page":"Drift Fields","title":"Electric Field Charge Drift Model","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The ElectricFieldChargeDriftModel describes a system in which electrons and holes move along the electric field lines. In this case, the mobility is a scalar pm 1 m²/(Vs) (+ for holes, and - for electrons), and thus, the velocity field has the same (or opposite) direction as the electric field. Even though this model does not describe reality, it is useful in some cases to use the electric field vectors as velocity vectors.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"In order to set the ElectricFieldChargeDriftModel for the simulation, the precision type of the calculation T (Float32 or Float64) has to be given as an argument. Note that T has to be of the same precision type of the simulation:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ElectricFieldChargeDriftModel(T)\nset_charge_drift_model!(simulation, charge_drift_model) \ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/drift_fields/#ADL-Charge-Drift-Model","page":"Drift Fields","title":"ADL Charge Drift Model","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"In high-purity germanium, the mobility cannot be expressed by a simple scalar quantity. Germanium has a cubic diamond lattice structure with langle100rangle, langle110rangle and langle111rangle as principal directions. Along these axes, the charge drift is parallel to the electric field. However, the longitudinal drift velocity, v_l, is not equally fast on the three axes. ","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"On each axes, v_l can be described through the parametrization proposed by  C. Canali et al., which was later expanded by L. Mihailescu:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"v_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The parameters mu_0, E_0 and beta differ for electrons and holes and mu_n is only relevant for electrons. These parameters were obtained by B. Bruyneel by measuring the drift velocities of electrons and holes in the langle100rangle and langle111rangle directions in high purity germanium at a temperature of 78 K. These parameters are stored in a json config file, \"drift_velocity_config.json\", located in <package_directory>/src/ChargeDriftModels/ADL/. The config file is expressed as following:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"{\n\t\"phi110\": -0.785398,\n\t\"drift\": {\n\t\t\"velocity\": {\n\t\t\t\"model\": \"Bruyneel2006\",\n\t\t\t\"parameters\": {\n\t\t\t\t\"e100\": {\n\t\t\t\t\t\"mu0\": 3.8609,\n\t\t\t\t\t\"beta\": 0.805,\n\t\t\t\t\t\"E0\": 51100.0,\n\t\t\t\t\t\"mun\": -0.0171\n\t\t\t\t},\n\t\t\t\t\"e111\": {\n\t\t\t\t\t\"mu0\": 3.8536,\n\t\t\t\t\t\"beta\": 0.641,\n\t\t\t\t\t\"E0\": 53800.0,\n\t\t\t\t\t\"mun\": 0.0510\n\t\t\t\t},\n\t\t\t\t\"h100\": {\n\t\t\t\t\t\"mu0\": 6.1824,\n\t\t\t\t\t\"beta\": 0.942,\n\t\t\t\t\t\"E0\": 18500.0\n\t\t\t\t},\n\t\t\t\t\"h111\": {\n\t\t\t\t\t\"mu0\": 6.1215,\n\t\t\t\t\t\"beta\": 0.662,\n\t\t\t\t\t\"E0\": 18200.0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"where the parameters are stored under the keys e100, e111, h100 and h111, in which e and h stand for electrons and holes, respectively, and 100 and 111, for the principal axes langle100rangle and langle111rangle. Currently, in SolidStateDetectors.jl the langle001rangle axis is fixed to be the Z-axis of the coordinate system of the simulation. The orientation of the crystal is set through the phi110 parameter, which fixes the angle in radiants between the langle110rangle principal direction of the crystal and the X-axis.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"If the electric field is not aligned with any of the crystal axes, the charge drift velocity is not necessarily aligned with the electric field. In the ADLChargeDriftModel, two models are implemented to describe the charge drift of electrons and holes between the axes. Detailed information about the charge drift models is provided in the papers from L. Mihailescu et al.  for electrons and from B.Bruyneel et al. for holes.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"In order to perform the calculation of the drift field, a json config file containing the parametrization values like the \"drift_velocity_config.json\" (with Bruyneel's data or modified values), has to be passed as an argument to the ADLChargeDriftModel function. The precision of the the calculation T (Float32 or Float64) has to be given as a keyword T. Note that T has to be of the same type as the chosen in the simulation:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_ADL_json_config_file>\", T=T)\nset_charge_drift_model!(simulation, charge_drift_model) \ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The values from the default config file correspond to germanium at 78 K. Calculations of the drift field at other temperatures are also supported by the ADL charge drift model. While experimental observations suggest that the charge mobility of electrons and holes in the crystal is temperature dependent, the dependency law has not yet been established. Several models have been proposed to reproduce the experimental behaviour, and some examples of them can be found in the directory <package_directory>/src/ChargeDriftModels/ADL/. The examples include a linear model, a Boltzmann model and a power-law model. To use these models in the calculation of the drift fields, the corresponding config file, the temperature and the precision must be given to the function. E.g., in order to use the Boltzmann model at a temperature of 100 K:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_drift_velocity_config_boltzmann.json>\", T = T, temperature = 100)  \nset_charge_drift_model!(simulation, charge_drift_model) \ncalculate_drift_fields!(simulation)","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"If no temperature is given as a parameter, the calculations will be performed at a default temperature of 80 K.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"It should be noted that the correct model has not yet been identified, and the parameters inside these config files -besides the default ADL one- are just educated guesses.","category":"page"},{"location":"man/drift_fields/#Custom-Charge-Drift-Model","page":"Drift Fields","title":"Custom Charge Drift Model","text":"","category":"section"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The user can implement and use his own drift model.","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The first step is to define a struct for the model which is a subtype of SolidStateDetectors.AbstractChargeDriftModel:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"using SolidStateDetectors\nusing SolidStateDetectors: SSDFloat, AbstractChargeDriftModel\nusing StaticArrays\n\nstruct CustomChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T} \n    # optional fields to parameterize the model\nend","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"The second step is to define two methods (getVe for electrons and getVh for holes), which perform the transformation of an electric field vector, fv::SVector{3,T}, into a velocity vector. Note, that the vectors are in cartesian coordinates, independent of the coordinate system (cartesian or cylindrical) of the simulation. ","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"function SolidStateDetectors.getVe(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return -fv\nend\n\nfunction SolidStateDetectors.getVh(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return fv\nend","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"Then, one can apply the model to the simulation:","category":"page"},{"location":"man/drift_fields/","page":"Drift Fields","title":"Drift Fields","text":"T = SolidStateDetectors.get_precision_type(simulation) # e.g. Float32\ncdm = CustomChargeDriftModel{T}()\nset_charge_drift_model!(simulation, cdm)\ncalculate_drift_fields!(simulation)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup  = quote\r\n    using SolidStateDetectors\r\nend","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SolidStateDetectors]\r\nOrder = [:type, :function]","category":"page"},{"location":"api/#SolidStateDetectors.ADLChargeDriftModel","page":"API","title":"SolidStateDetectors.ADLChargeDriftModel","text":"ADLChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel\n\nFields\n\nelectrons::CarrierParameters{T}\nholes::CarrierParameters{T}\nmasses::MassParameters{T}\n`phi110::T\ngammas::SVector{4, SMatrix{3,3,T}}\ntemperaturemodel::AbstractTemperatureModel{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractConfig","page":"API","title":"SolidStateDetectors.AbstractConfig","text":"abstract type AbstractConfig{T <: SSDFloat} end\n\nSupertype of all detector/world/object configs.\n\nUser defined geometries must be subtype of AbstractConfig{T}.\n\nThere are a few functions which must be defined for a user config, e.g. struct UserConfig{T} <: AbstractConfig{T}:\n\nFor cylindrical grids:\n\nin(pt::cylindrical{T}, config::UserConfig{T})::Bool where {T <: SSDFloat}\nGrid(config::UserConfig{T})::Grid{T, 3, :cylindrical} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::cylindrical{T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, :cylindrical}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\nFor cartesian grids:\n\nin(pt::StaticVector{3, T}, config::UserConfig{T})::Bool \nGrid(config::UserConfig{T})::Grid{T, 3, :cartesian} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::StaticVector{3, T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, :cartesian}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractLine","page":"API","title":"SolidStateDetectors.AbstractLine","text":"abstract type AbstractLine{T, N, S} <: AbstractGeometry{T, N} end\n\nT: eltype N: Dimension S: Coordinate System: :cartesian or :cylindrical\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Box","page":"API","title":"SolidStateDetectors.Box","text":"mutable struct Box{T} <: AbstractGeometry{T, 3}\n\nVery simple rectengular box in cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantChargeDensityModel","page":"API","title":"SolidStateDetectors.ConstantChargeDensityModel","text":"struct ConstantChargeDensityModel{T <: SSDFloat} <: AbstractChargeDensityModel{T}\n\nReturns always a fixed charge density.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Contact","page":"API","title":"SolidStateDetectors.Contact","text":"mutable struct Contact{T} <: AbstractContact{T}\n\nT: Type of precision.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Difference","page":"API","title":"SolidStateDetectors.Difference","text":"struct Difference{T, N, A, B} <: AbstractSet{T, N}\n\na && !b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis{T, BL, BR} <: AbstractAxis{T, BL, BR}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nBL: left boundary condition\nBR: right boundary condition\nI: IntervalSets.Interval (closed or open boundaries)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T,T,Symbol,Symbol,Symbol,Symbol,AbstractArray{T,1}}} where T","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nL, R {:closed, :open} \nticks: Ticks of the axis\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricFieldChargeDriftModel","page":"API","title":"SolidStateDetectors.ElectricFieldChargeDriftModel","text":"ElectricFieldChargeDriftModel <: AbstractChargeDriftModel\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cartesian}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, :cartesian} ; kwargs...)::ElectricPotential{T, 3, :cartesian}\n\nExtracts the electric potential from setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, :cylindrical} ; kwargs...)::ElectricPotential{T, 3, :cylindrical}\n\nExtracts the electric potential from setup and extrapolate it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.Event","page":"API","title":"SolidStateDetectors.Event","text":"mutable struct Event{T <: SSDFloat}\n\nCollection struct for individual events. This (mutable) struct is ment to be used to look at individual events, not to process a hugh amount of events.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.GeometryUnion","page":"API","title":"SolidStateDetectors.GeometryUnion","text":"struct GeometryUnion{T, N, A, B} <: AbstractSet{T, N}\n\na || b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid","page":"API","title":"SolidStateDetectors.Grid","text":"T: tick type\nN: N dimensional\nS: System (Cartesian, Cylindrical...)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Intersection","page":"API","title":"SolidStateDetectors.Intersection","text":"struct Intersection{T, N, A, B} <: AbstractSet{T, N}\n\na && b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Line","page":"API","title":"SolidStateDetectors.Line","text":"struct Line{T, N, S} <: AbstractLine{T, N, S}\n\n<––A–––––B––>\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LineSegment","page":"API","title":"SolidStateDetectors.LineSegment","text":"struct LineSegment{T, N, S} <: AbstractLine{T, N, S}\n\n[A----------B]\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearChargeDensityModel","page":"API","title":"SolidStateDetectors.LinearChargeDensityModel","text":"struct LinearChargeDensityModel{T <: SSDFloat} <: AbstractChargeDensityModel{T}\n\nSimple charge density model which assumes a linear gradient in charge density in each dimension. offsets::NTuple{3, T} are the charge densities at 0 and gradients::NTuple{3, T} are the linear slopes in each dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointType","page":"API","title":"SolidStateDetectors.PointType","text":"const PointType = UInt8\n\nStores certain information about a grid point via bit-flags. \n\nRight now there are:\n\n`const update_bit      = 0x01`\n`const undepleted_bit  = 0x02`\n`const pn_junction_bit = 0x04`\n\nHow to get information out of a PointType variable pt:\n\npt & update_bit == 0 -> do not update this point (for fixed points)     \npt & update_bit >  0 -> do update this point    \npt & undepleted_bit > 0 -> this point is undepleted\npt & pn_junction_bit > 0 -> this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes{T, N, S} <: AbstractArray{T, N}\n\nPointTypes stores the point type of each grid point.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes-Union{Tuple{SolidStateDetectors.PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes(setup::PotentialSimulationSetup{T, 3, :cylindrical} ; kwargs...)::PointTypes{T, 3, :cylindrical}\n\nExtracts the electric potential from setup and extrapolate it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.PotentialSimulationSetup","page":"API","title":"SolidStateDetectors.PotentialSimulationSetup","text":"PotentialSimulationSetup{T, N, S} <: AbstractPotentialSimulationSetup{T, N}\n\nCollection struct. It holds the grid, the potential, the point types, the charge density and the dielectric distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Ray","page":"API","title":"SolidStateDetectors.Ray","text":"struct Ray{T, N, S} <: AbstractLine{T, N, S}\n\n[A----------B---->\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.RectangularCuboid","page":"API","title":"SolidStateDetectors.RectangularCuboid","text":"struct RectangularCuboid{T} <: AbstractGeometry{T, 3}\n\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Simulation","page":"API","title":"SolidStateDetectors.Simulation","text":"mutable struct Simulation{T <: SSDFloat} <: AbstractSimulation{T}\n\nCollection of all parts of a Simulation of a Solid State Detector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SolidStateDetector","page":"API","title":"SolidStateDetectors.SolidStateDetector","text":"mutable struct SolidStateDetector{T <: SSDFloat, CS} <: AbstractConfig{T}\n\nCS: Coordinate System: -> :cartesian / :cylindrical\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ZeroChargeDensityModel","page":"API","title":"SolidStateDetectors.ZeroChargeDensityModel","text":"struct ZeroChargeDensityModel{T <: SSDFloat} <: AbstractChargeDensityModel{T}\n\nReturns always 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T","page":"API","title":"SolidStateDetectors.RBArray","text":"RBExtBy2Array( et::Type, g::Grid{T, N, :cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, N, :cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type,Grid{T,3,:cartesian}}} where T","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, 3, :cartesian} )::Array{et, 4} where {T}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors._drift_charge!-Union{Tuple{S}, Tuple{T}, Tuple{Array{CartesianPoint{T},1},Array{T,1},SolidStateDetector{T,S},PointTypes{T,3,S},Grid{T,3,S},CartesianPoint{T},T,Interpolations.Extrapolation{var\"#s296\",3,ITPT,IT,ET} where ET where IT where ITPT where var\"#s296\"<:(StaticArrays.StaticArray{Tuple{3},T,1} where T)}} where S where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors._drift_charge!","text":"_drift_charge(...)\n\nBefore calling this function one should check that startpos is inside det: in(startpos, det\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.add_fano_noise","page":"API","title":"SolidStateDetectors.add_fano_noise","text":"add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity\n\nAdd Fano noise to an energy deposition E_dep, assuming a detector material ionisation energy E_ionisation and a Fano factor f_fano.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Grid{T,N,S} where S where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"function apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim.detector))::Nothing\n\nApplies the initial state of the electric potential calculation. It overwrites sim.electric_potential, sim.ρ, sim.ρ_fix, sim.ϵ and sim.point_types.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Grid{T,N,S} where S where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"function apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim.detector))::Nothing\n\nApplies the initial state of the weighting potential calculation for the contact with the id contact_id. It overwrites sim.weighting_potentials[contact_id].\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_capacitance-Union{Tuple{Simulation{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_capacitance","text":"calculate_capacitance(sim::Simulation{T})::T where {T <: SSDFloat}\n\nCalculates the capacitance of an detector in Farad.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_field!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_electric_field!","text":"calculate_electric_field!(sim::Simulation{T}, args...; n_points_in_φ::Union{Missing, Int} = missing, kwargs...)::Nothing\n\nToDo...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T},Vararg{Any,N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_electric_potential!","text":"calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing\n\nCompute the electric potential for the given Simulation sim on an adaptive grid through successive over relaxation.\n\nThere are serveral <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nmax_refinements::Int: Number of maximum refinements. Default is 2. Set it to 0 to switch off refinement.\nrefinement_limits::Tuple{<:Real, <:Real, <:Real}: Tuple of refinement limits for each dimension   (in case of cylindrical coordinates the order is r, φ, z).   A refinement limit (e.g. refinement_limits[1]) times the bias voltage of the detector det is the   maximum allowed voltage difference between two neighbouring grid points in the respective dimension.   When the difference is larger, new points are created inbetween. Default is [1e-5, 1e-5, 1e-5].\ninit_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the initial distances between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [0.005, 10.0, 0.005]`.\nmin_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the mimimum allowed distance between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [1e-6, 1e-6, 1e-6].\ngrid::Grid{T, N, S}: Initial grid used to start the simulation. Default is Grid(detector, init_grid_spacing=init_grid_spacing).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T},Int64,Vararg{Any,N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_weighting_potential!","text":"calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing\n\nCompute the weighting potential for the contact with id contact_id for the given Simulation sim on an adaptive grid through successive over relaxation.\n\nThere are serveral <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 2e-6 (times bias voltage).\nmax_refinements::Int: Number of maximum refinements. Default is 2. Set it to 0 to switch off refinement.\nrefinement_limits::Tuple{<:Real, <:Real, <:Real}: Tuple of refinement limits for each dimension   (in case of cylindrical coordinates the order is r, φ, z).   A refinement limit (e.g. refinement_limits[1]) times the bias voltage of the detector det is the   maximum allowed voltage difference between two neighbouring grid points in the respective dimension.   When the difference is larger, new points are created inbetween. Default is [1e-5, 1e-5, 1e-5].\ninit_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the initial distances between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [0.005, 10.0, 0.005]`.\nmin_grid_spacing::Tuple{<:Real, <:Real, <:Real}: Tuple of the mimimum allowed distance between two grid points for each dimension.   For normal coordinates the unit is meter. For angular coordinates, the unit is radiance.   It prevents the refinement to make the grid to fine. Default is [1e-6, 1e-6, 1e-6].\ngrid::Grid{T, N, S}: Initial grid used to start the simulation. Default is Grid(detector, init_grid_spacing=init_grid_spacing).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of cartesian coordinates only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T,3,:cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_active_volume","text":"get_active_volume(pts::PointTypes{T}) where {T}\n\nReturns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SArray{Tuple{3},T,1,3},3},SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_electron_drift_field","text":"get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the electric field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SArray{Tuple{3},T,1,3},3},SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_hole_drift_field","text":"get_hole_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the hole field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_path_to_example_config_files-Tuple{}","page":"API","title":"SolidStateDetectors.get_path_to_example_config_files","text":"get_path_to_example_config_files()::String\n\nReturns the path to example config files provided by the package.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64,Val{true},Val{true}}","page":"API","title":"SolidStateDetectors.get_rbidx_right_neighbour","text":"get_rbidx_right_neighbour(rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nneeds docu...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cartesian},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  iz::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_x::Array{T, 2}, gw_y::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, :cartesian},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                            bulk_is_ptype::Val{_bulk_is_ptype}  )::Nothing where {T, even_points, depletion_handling_enabled, _bulk_is_ptype}\n\n(Vectorized) inner loop for Cartesian coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,:cylindrical},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  ir::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_r::Array{T, 2}, gw_φ::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, :cylindrical},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                            bulk_is_ptype::Val{_bulk_is_ptype}  )::Nothing where {T, even_points, depletion_handling_enabled, _bulk_is_ptype}\n\n(Vectorized) inner loop for Cylindrical coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.nidx-Tuple{Int64,Val{true},Val{true}}","page":"API","title":"SolidStateDetectors.nidx","text":"nidx( rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nfirst type argument:  type of the orgal point (for even points -> Val{true}(), else Val{false}()) second type argument: is sum of other point indices even or odd -> (if sum is even -> Val{true}(), else Val{false}())\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.parse_config_file-Tuple{AbstractString}","page":"API","title":"SolidStateDetectors.parse_config_file","text":"SolidStateDetector{T}(filename::AbstractString)::SolidStateDetector{T} where {T <: SSDFloat}\n\nReads in a config-JSON file and returns an Detector struct which holds all information specified in the config file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T,CS} where CS,Grid{T,3,S} where S,CartesianPoint{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.point_type","text":"For charge drift...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.readsiggen-Tuple{String}","page":"API","title":"SolidStateDetectors.readsiggen","text":"readsiggen(file_path::String[, T::Type=Float64])\n\nRead the '*.config' file in 'file_path' for SigGen and returns a dictionary of all parameters. Non-existing parameteres are set to 0. ...\n\nArguments\n\nfile_path::String: file path for the SigGen config file.\nT::Type=Float64: type of the parameters in the output dictionary.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{var\"#s16\",var\"#s15\",var\"#s14\"} where var\"#s14\"<:Real where var\"#s15\"<:Real where var\"#s16\"<:Real}, Tuple{Simulation{T},Type{ElectricPotential},Tuple{var\"#s673\",var\"#s674\",var\"#s675\"} where var\"#s675\"<:Real where var\"#s674\"<:Real where var\"#s673\"<:Real,Tuple{var\"#s676\",var\"#s677\",var\"#s678\"} where var\"#s678\"<:Real where var\"#s677\"<:Real where var\"#s676\"<:Real}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"function refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.electric_potential and refines it with respect to the input arguments max_diffs and minimum_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{var\"#s299\",var\"#s298\",var\"#s297\"} where var\"#s297\"<:Real where var\"#s298\"<:Real where var\"#s299\"<:Real}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Tuple{var\"#s296\",var\"#s295\",var\"#s294\"} where var\"#s294\"<:Real where var\"#s295\"<:Real where var\"#s296\"<:Real,Tuple{var\"#s293\",var\"#s253\",var\"#s252\"} where var\"#s252\"<:Real where var\"#s253\"<:Real where var\"#s293\"<:Real}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"function refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.weighting_potentials[contact_id] and refines it with respect to the input arguments max_diffs and minimum_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.siggentodict-Tuple{Dict}","page":"API","title":"SolidStateDetectors.siggentodict","text":"siggentodict(config::Dict[, units::Dict, detector_name::String])\n\nConverts the dictionary containing the parameters from a SigGen config file to a SSD config dictionary. This dictionary can be saved as a JSON file using the JSON package and 'JSON.print(file, config, 4)'. The 'detector_name' is set to \"Public Inverted Coax\" by default to inherit the colour scheme. ...\n\nArguments\n\nconfig::Dict: dictionary containing SigGen parameters (output of readsiggen()).\nunits::Dict: units used in SigGen file (set to 'mm', 'deg', 'V' and 'K').\ndetector_name::String: name of the detector.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate!","text":"function simulate!(sim::Simulation{T};  max_refinements::Int = 1, verbose::Bool = false,\n                                    depletion_handling::Bool = false, convergence_limit::Real = 1e-5 ) where {T <: SSDFloat}\n\nToDo...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update!-Union{Tuple{only_2d}, Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{SolidStateDetectors.PotentialSimulationSetupRB{T,3,4,S},Int64,Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential},Val{only_2d}}} where only_2d where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where S where T","page":"API","title":"SolidStateDetectors.update!","text":"update!(fssrb::PotentialSimulationSetupRB{T, 3, 4, S}, RBT::DataType)::Nothing\n\nLoop over even grid points. A point is even if the sum of its cartesian indicies (of the not extended grid) is even. Even points get the red black index (rbi) = 2. ( -> rbpotential[ inds..., rbi ]).\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{ElectricPotential}}, Tuple{Simulation{T},Type{ElectricPotential},Real}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"function update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.electric_potential and updates it until it has converged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{T}, Tuple{Simulation{T},Type{WeightingPotential},Int64,Real}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"function update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.weighting_potentials[contact_id] and updates it until it has converged.\n\n\n\n\n\n","category":"method"},{"location":"man/electric_fields/#Electric-Fields","page":"Electric Fields","title":"Electric Fields","text":"","category":"section"},{"location":"man/electric_fields/","page":"Electric Fields","title":"Electric Fields","text":"ToDo...","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#SolidStateDetectors.jl","page":"Home","title":"SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SolidStateDetectors.jl is a Julia package for fast 2D and 3D simulation of Solid State Detectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/installation.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/config_files.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/csg.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/primitives.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/weighting_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_fields.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/drift_fields.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/IO.md\"]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Example-1:-Inverted-Coax-Detector","page":"Tutorial","title":"Example 1: Inverted Coax Detector","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots; pyplot(fmt = :png);\nusing SolidStateDetectors\nusing Unitful\n\nT = Float32\nsimulation = Simulation{T}(SSD_examples[:InvertedCoax])\n\nplot(simulation.detector, size = (700, 700))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"apply_initial_state!(simulation, ElectricPotential) # optional\nplot(\n    plot(simulation.electric_potential), # initial electric potential (boundary conditions)\n    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(simulation.ρ), # charge density distribution\n    plot(simulation.ϵ), # dielectric distribution\n    layout = (1, 4), size = (1400, 700)\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, calculate the electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_potential!( simulation,\n                               max_refinements = 3)\n\nplot(\n    plot(simulation.electric_potential, φ = 20), # initial electric potential (boundary conditions)\n    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(simulation.ρ), # charge density distribution\n    plot(simulation.ϵ), # dielectric distribution\n    layout = (1, 4), size = (1400, 700)\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get_active_volume(simulation.point_types) # approximation (sum of the volume of cells marked as depleted)","category":"page"},{"location":"tutorial/#Partially-depleted-detectors","page":"Tutorial","title":"Partially depleted detectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"detector_undep = deepcopy(simulation.detector)\ndetector_undep.contacts[end].potential = 500; # V  <-- Bias Voltage of Mantle\n\nsimulation_undep = Simulation(detector_undep);\n\ncalculate_electric_potential!( simulation_undep,\n                               depletion_handling = true,\n                               convergence_limit=1e-6,\n                               max_refinements = 3,\n                               verbose = false)\n\nplot(\n    plot(simulation_undep.electric_potential),\n    plot(simulation_undep.point_types),\n    layout = (1, 2), size = (800, 700)\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare both volumes:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Depleted:   \", get_active_volume(simulation.point_types))\nprintln(\"Undepleted: \", get_active_volume(simulation_undep.point_types));\nnothing #hide","category":"page"},{"location":"tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Calculate the electric field of the fully depleted detector, given the already calculated electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_field!(simulation, n_points_in_φ = 72)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plotelectricfield(simulation, size = (350, 500))","category":"page"},{"location":"tutorial/#Drift-field-calculation","page":"Tutorial","title":"Drift field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any drift field model can be used for the calculation of the electric field. If no model is explicitely given, the Bruyneel model from the Agata Data Library (ADL) is used. Other configurations are saved in their JSON configuration files and can be found under:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<package_directory>/src/ChargeDriftModels/ADL/<config_filename>.json.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set the charge drift model of the simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"charge_drift_model = ADLChargeDriftModel()\nset_charge_drift_model!(simulation, charge_drift_model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And apply the charge drift model to the electric field:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_drift_fields!(simulation)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, let's create an \"random\" (multiside) event:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),\n                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),\n                       CylindricalPoint{T}( 0.025, deg2rad(30), 0.025 ) ]\nenergy_depos = T[1460, 609, 1000] * u\"keV\" # are needed later in the signal generation\n\nevent = Event(starting_positions, energy_depos);\n\ntime_step = 5u\"ns\"\ndrift_charges!(event, simulation, Δt = time_step)\n\nplot(simulation.detector, size = (700, 700))\nplot!(event.drift_paths)","category":"page"},{"location":"tutorial/#Weighting-potential-calculation","page":"Tutorial","title":"Weighting potential calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for contact in simulation.detector.contacts\n    calculate_weighting_potential!(simulation, contact.id, max_refinements = 3, n_points_in_φ = 2, verbose = false)\nend\n\nplot(\n    plot(simulation.weighting_potentials[1]),\n    plot(simulation.weighting_potentials[2]),\n    size = (900, 700)\n)","category":"page"},{"location":"tutorial/#Detector-waveform-generation","page":"Tutorial","title":"Detector waveform generation","text":"","category":"section"},{"location":"tutorial/#Single-event-simulation","page":"Tutorial","title":"Single-event simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"simulate!(event, simulation) # drift_charges + signal generation of all channels\n\np_pc_signal = plot( event.waveforms[1], lw = 1.5, xlims = (0, 2000), xlabel = \"Time / ns\",\n                    legend = false, tickfontsize = 12, ylabel = \"Energy / eV\", guidefontsize = 14)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
