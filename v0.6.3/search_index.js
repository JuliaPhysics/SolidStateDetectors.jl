var documenterSearchIndex = {"docs":
[{"location":"man/config_files/#Configuration-Files","page":"Configuration Files","title":"Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detector, its surroundings and symmetries can be specified in configuration files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"SolidStateDetectors.jl supports YAML and JSON as formats for the configuration files.","category":"page"},{"location":"man/config_files/#Example-Configuration-Files","page":"Configuration Files","title":"Example Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Several example configuration files can be found under","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"<package_directory>/examples/example_config_files/.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They are accessible through a dictionary, SSD_examples, defined in the package:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"using SolidStateDetectors\r\nkeys(SSD_examples) # dictionary holding the full path to the corresponding configuration files","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They can be loaded via","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"path_to_config_file = SSD_examples[:InvertedCoax]\r\nsim = Simulation(path_to_config_file)","category":"page"},{"location":"man/config_files/#General-Structure","page":"Configuration Files","title":"General Structure","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The configuration files need a minimum of information in order to define the detector, its surroundings and symmetries.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"This is a minimum working example of a simple true coaxial detector with two contacts:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: Simple True Coax # optional\r\nunits:\r\n  length: mm\r\n  angle: deg\r\ngrid:\r\n  coordinates: cylindrical\r\n  axes:\r\n    r: 45\r\n    z:\r\n      from: -40\r\n      to: 40\r\nmedium: vacuum\r\ndetectors:\r\n- semiconductor:\r\n    material: HPGe\r\n    geometry:\r\n      tube:\r\n        r: \r\n          from: 0.5cm\r\n          to: 4cm\r\n        h: 6cm\r\n  contacts:\r\n  - material: HPGe\r\n    id: 1\r\n    potential: 6000\r\n    geometry:\r\n      tube:\r\n        r:\r\n          from: 5\r\n          to: 5\r\n        h: 60\r\n  - material: HPGe\r\n    id: 2\r\n    potential: 0\r\n    geometry:\r\n      tube:\r\n        r:\r\n          from: 40\r\n          to: 40\r\n        h: 60","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"It will be used to guide through the different parts of the configuration file.","category":"page"},{"location":"man/config_files/#Units","page":"Configuration Files","title":"Units","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Internally, SolidStateDetectors.jl performs its calculations in SI units. However, configuration files can be written in custom units.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The field units denotes the standard units with which values will be parsed. Standard units can be defined for length, angle, potential and temperature.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"In the example above, ","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"units:\r\n  length: mm\r\n  angle: deg","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"will lead to all length values to be parsed in units of mm, while all angle values will be parsed in units of deg (degree).","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The configuration files also allow for directly passing units to the values that will be parsed using uparse from the Unitful.jl package, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"units: \r\n  length: mm\r\n  # ....\r\ntube:\r\n  r: \r\n    from: 5\r\n    to: 40\r\n  h: 60","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"is equivalent to","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"tube:\r\n  r: \r\n    from: 5mm\r\n    to: 40mm\r\n  h: 60mm","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"or","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"tube:\r\n  r: \r\n    from: 0.5cm\r\n    to: 4cm\r\n  h: 6cm","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"In the last example, even if the length unit was set to mm, the values will be parsed in units of cm. Please note to not leave a white space between the value and the unit and to use the Unitful.jl notation.","category":"page"},{"location":"man/config_files/#Grid","page":"Configuration Files","title":"Grid","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The calculations are performed on a finite world. To define the world, SolidStateDetectors.jl requires the properties of the grid, which are the coordinate system type and the dimensions. These are defined in the grid section of the configuration file, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cartesian\r\n axes:\r\n   x: \r\n     from: -40\r\n     to: 40\r\n   y:\r\n     from: -40\r\n     to: 40\r\n   z:\r\n     from: -40\r\n     to: 40","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The coordinates of the grid can be:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"cartesian (with the axes x, y and z)\ncylindrical (with the axes r, phi and z).","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The axes field is used to define the dimensions of each axis and, optionally, the boundary handling. In the example above, the x, y and z axes range from -40 to 40 units.","category":"page"},{"location":"man/config_files/#Grid-boundary-handling","page":"Configuration Files","title":"Grid boundary handling","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Symmetries of the world can be used to reduce the calculation only to a fraction of the world. These can be passed as boundaries to the different axes.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For linear axes (x, y, z), the boundaries can be chosen infinite, periodic, reflecting, or fixed.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For radial axes (r), the boundaries can be chosen r0. If no boundaries are given, the default is r0 for the left boundary and infinite for the right boundary.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For angular axes (phi), the boundaries can be chosen reflecting or periodic. If no boundaries are given, the default is periodic for both edges.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"All varphi-symmetric configurations can be calculated in 2D if phi ranges from 0 to 0 with periodic boundary handling, i.e.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0\r\n     to: 0\r\n     boundaries: periodic\r\n   z: #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"All varphi-periodic configurations can be calculated on the fraction of the full 2pi interval, i.e. for a 120°-periodic system","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0°\r\n     to: 120°\r\n     boundaries: periodic\r\n   z: #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Different boundary handling can be chosen for the left and right end of the interval, i.e. for a 60°-periodic system with mirror symmetry at 30°","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0°\r\n     to: 30°\r\n     boundaries:\r\n       left: periodic\r\n       right: reflecting\r\n   z: #...","category":"page"},{"location":"man/config_files/#Detector-Constituents","page":"Configuration Files","title":"Detector Constituents","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detectors for the simulation are defined in an array detectors, where each entry corresponds to one detector. Each detector consists of exactly one semiconductor, a minimum of two contacts and, optionally, passives and virtual_drift_volumes.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"detectors:\r\n  - name: \"Detector 1\"\r\n    semiconductor: #...\r\n    contacts: \r\n      - # Contact 1\r\n      - # Contact 2 \r\n    passives: \r\n      - # Passive 1 (optional)\r\n    virtual_drift_volumes:\r\n      - # Virtual Drift Volume 1 (optional)\r\n  - name: \"Detector 2\"\r\n    semiconductor: #...\r\n    contacts: \r\n      - # Contact 1\r\n      - # Contact 2","category":"page"},{"location":"man/config_files/#Semiconductor","page":"Configuration Files","title":"Semiconductor","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"An example definition of the semiconductor looks like this:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"semiconductor:\r\n  material: HPGe\r\n  temperature: 78\r\n  impurity_density: # ...\r\n  charge_drift_model: # ...\r\n  geometry: # ...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of the semiconductor are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"material: the material of the semiconductor. This is important to know the electric properties of the semiconductor for the electric potential calculation. Possible choices are HPGe (high-purity germanium) and Si (silicon).\ntemperature (optional): the temperature of the semiconductor. If no temperature is given, the default is 78K for germanium and 293K for all other materials.\nimpurity_density (optional): the distribution of impurities in the semiconductor material. This has a strong impact on the electric potential calculation. If no impurity_density is given, the default is an impurity-free material (rho(vecr) = 0).\ncharge_drift_model (optional): a model to describe the drift of charge carriers in the semiconductor material. If no charge_drift_model is given, the default is ElectricFieldChargeDriftModel. Find a detailed description  on how to define an own model under Custom Charge Drift Model.\ngeometry: the geometry of the semiconductor object. Find a detailed description on how to define geometries under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Contacts","page":"Configuration Files","title":"Contacts","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"An example definition of contacts looks like this:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"contacts:\r\n  - name: \"n+ contact\"\r\n    id: 1\r\n    potential: 5000V\r\n    material: HPGe # optional\r\n    geometry: # ....\r\n  - name: \"p+ contact\"\r\n    id: 2\r\n    potential: 0\r\n    material: HPGe #optional\r\n    geometry: # ....","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"where each entry of the contacts array defines one contact.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of a contact are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name (optional): the custom name for the contacts, relevant for plotting. \nid: a unique id of the contact that will unambiguously identify the contact, for example in the signal generation. All contacts should be given an integer id, ideally from 1 to N where N is the number of contacts.\npotential: the electric potential applied to the contact that is fixed throughout the whole contact geometry. This value can be parsed with units (5000V) or without (0 with the units defined in the units section).\nmaterial (optional): the material of the contact. This is important to know the electric properties of the contact for the electric potential calculation. If no material is given, the default is HPGe (high-purity germanium).\ngeometry: the geometry of the contact. Find a detailed description on how to define geometries under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Passives-and-Charged-Surfaces","page":"Configuration Files","title":"Passives and Charged Surfaces","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Passive objects and charged surfaces can be defined through entries of the passives array for each detector, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"passives:\r\n  - name: Passivated Surface\r\n    material: HPGe\r\n    charge_density: # ...\r\n    geometry: # ...\r\n  - name: Cryostat\r\n    id: 3\r\n    potential: 0\r\n    temperature: 293K\r\n    material: Al\r\n    geometry: # ...\r\n","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of a passive are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name (optional): the name of the passive object. If no name is given, the default name is \"external part\".\nid (optional): a unique id of the contact that will unambiguously identify the passive object. If no id is given, the default is -1.\npotential (optional): the electric potential to which the passive object is fixed. This value can be parsed with units (5000V) or without (0 with the units defined in the units section). If no potential is given, the passive object will be treated as floating. \ntemperature (optional): the temperature of the passive object. This value can be parsed with units (293K) or without (78 with the units defined in the units section). If no temperature is given, the default is 293K.\nmaterial: the material of the passive object. This is important to know the electric properties of the contact for the electric potential calculation.\ncharge_density (optional): model to describe charge density distributions within the passive object, e.g. charged surfaces. Find a detailed description on how to define charge densities under Charge Density.\ngeometry: the geometry of the contact. Find a detailed description on how to define geometries in the section under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Surroundings","page":"Configuration Files","title":"Surroundings","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The medium of the world is passed as field medium, i.e.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: # ... # optional\r\nunits: #...\r\ngrid: #...\r\nmedium: vacuum\r\ndetectors: # ...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"If no medium is given, the default is vacuum. Implemented media are vacuum and LAr (liquid argon), but other media can be easily added to the material_properties dictionary in  MaterialProperties.jl.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Passive objects, especially cryostats or holding structures can be defined in an array surroundings without being assigned to a specific detector. ","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: # ... # optional\r\nunits: #...\r\ngrid: #...\r\nmedium: vacuum\r\ndetectors:\r\n- semiconductor: # ...\r\n  contacts: \r\n    - # ...\r\n    - # ...\r\n  passives:\r\n    - # ...\r\n    - # ...\r\nsurroundings:\r\n  - #...\r\n  - #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The definition of passive objects in the surroundings array is equal to that in the passives array of a detector.","category":"page"},{"location":"man/config_files/#Splitting-Configuration-Files","page":"Configuration Files","title":"Splitting Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Configuration files for complex geometries can get quite long. SolidStateDetectors.jl allows for splitting configuration files into smaller ones and loading them using the include keyword. This feature supports YAML and JSON files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"When including a separate file, the user has to add its file path in the main configuration file at the place it supposed to be added. To identify the file, set the key of this entry to include. Here, the user can also give an array of file paths. The file paths can be relative to the path of the configuration file or absolute. When including nested files and using relative paths, please always refer to the last parent file.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Including one file:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"include : \"file_to_be_included.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Including a list of files:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"include: \r\n  - \"first_file_to_be_included.yaml\"\r\n  - \"second_file_to_be_included.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Add files to an array in the main configuration file","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"detectors:\r\n  - include: \"first_file_in_array.yaml\"\r\n  - include: \"second_file_in_array.yaml\"\r\n  - include: \"thrid_file_in_array.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"A fully working example can be seen in SSD_examples[:InvertedCoaxInCryostat]. Here, the channels, the geometry and other parts are split into separate configuration files.","category":"page"},{"location":"man/csg/#Constructive-Solid-Geometry-(CSG)","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"All objects are defined through Constructive Solid Geometry (CSG), where complex geometries can be constructed by combining simple volume primitives (e.g. Tube) through Boolean operators and transformed using Transformations. ","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"The primitives which can be used are shown under Volume Primitives together with how they can be specified in the configuration files.","category":"page"},{"location":"man/csg/#Volume-Primitives","page":"Constructive Solid Geometry (CSG)","title":"Volume Primitives","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"using SolidStateDetectors\nimport SolidStateDetectors.ConstructiveSolidGeometry as CSG\nusing Plots\nT = Float64;\nnothing #hide","category":"page"},{"location":"man/csg/#List-of-YAML-example-configuration-files-for-Primitives","page":"Constructive Solid Geometry (CSG)","title":"List of YAML example configuration files for Primitives","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Under SolidStateDetectors.jl/examples/example_primitive_files there are some examples how to define the different primitives via the YAML format:","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"path_to_example_primitives_config_files = joinpath(dirname(dirname(pathof(SolidStateDetectors))), \"examples\", \"example_primitive_files\")\nexample_primitives_config_filenames = readdir(path_to_example_primitives_config_files)\nfor fn in example_primitives_config_filenames\n    println(fn)\nend","category":"page"},{"location":"man/csg/#Box","page":"Constructive Solid Geometry (CSG)","title":"Box","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Box.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"box = CSG.Geometry(T, cfn)\nplot(box)","category":"page"},{"location":"man/csg/#Cone","page":"Constructive Solid Geometry (CSG)","title":"Cone","text":"","category":"section"},{"location":"man/csg/#Tube","page":"Constructive Solid Geometry (CSG)","title":"Tube","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone_tube.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/csg/#VaryingTube","page":"Constructive Solid Geometry (CSG)","title":"VaryingTube","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/csg/#Ellipsoid","page":"Constructive Solid Geometry (CSG)","title":"Ellipsoid","text":"","category":"section"},{"location":"man/csg/#Sphere","page":"Constructive Solid Geometry (CSG)","title":"Sphere","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Ellipsoid_full_sphere.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"ellipsoid = CSG.Geometry(T, cfn)\nplot(ellipsoid)","category":"page"},{"location":"man/csg/#Torus","page":"Constructive Solid Geometry (CSG)","title":"Torus","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Torus.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"torus = CSG.Geometry(T, cfn)\nplot(torus, zlims = [-6,6], camera = (40, 55))","category":"page"},{"location":"man/csg/#Prism","page":"Constructive Solid Geometry (CSG)","title":"Prism","text":"","category":"section"},{"location":"man/csg/#Hexagonal-Prism","page":"Constructive Solid Geometry (CSG)","title":"Hexagonal Prism","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"RegularPrism_hexagon.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"prism = CSG.Geometry(T, cfn)\nplot(prism)","category":"page"},{"location":"man/csg/#Boolean-operators","page":"Constructive Solid Geometry (CSG)","title":"Boolean operators","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"The Boolean operators are union, difference and intersection:","category":"page"},{"location":"man/csg/#Union","page":"Constructive Solid Geometry (CSG)","title":"Union","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"A union of two objects A and B is defined as the set of points that are in at least one of either A or B. In the configuration files, it is defined using the union field, followed by an array of entries to construct the union, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"union: # A || B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"(Image: CSGUnion)","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If more than two geometries are passed, the union is constructed from all of them.","category":"page"},{"location":"man/csg/#Difference","page":"Constructive Solid Geometry (CSG)","title":"Difference","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"A difference of two objects A and B is defined as the set of points that are in A but not in B. Note that B is treated as open primitive. This means that points which are in A and on the surface of B will still be in the difference of A and B. In the configuration files, it is defined using the difference field, followed by an array of entries. The first entry of the array is the main geometry, from which all following geometry entries are subtracted, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"difference: # A && !B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.1","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"(Image: CSGDifference)","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Keep in mind that to discard the part of the surface of A which is on the surface of B, B should be chosen slightly bigger than A.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If more than two geometries are passed, all entries starting from the second will be subtracted from the first.","category":"page"},{"location":"man/csg/#Intersection","page":"Constructive Solid Geometry (CSG)","title":"Intersection","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"An intersection of two objects A and B is defined as the set of points that are both in A and in B. In the configuration files, it is defined using the intersection field, followed by an array of entries to construct the intersection, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"intersection: # A && B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"(Image: CSGIntersection)","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If more than two geometries are passed, the intersection is constructed from all of them.","category":"page"},{"location":"man/csg/#Transformations","page":"Constructive Solid Geometry (CSG)","title":"Transformations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"All Volume Primitives are defined such that they are centered around the origin of the coordinate system. They can be rotated in their local coordinate system and translated to their final position in the global coordinate system.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"There are two possibilities two rotate and translate volume primitives. One is to define the rotation/translation inside the primitive definition. The other one is to define it for complete sets like detectors, unions, etc.","category":"page"},{"location":"man/csg/#Rotations","page":"Constructive Solid Geometry (CSG)","title":"Rotations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Rotations are defined in the configuration files by either a 3times3 rotation matrix or a set of angles with respective rotation axes are required.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If a tube is to be rotated 45° around the x axis, the rotation is parsed to the primitive as additional rotation field in the primitive definition.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    X: 45°","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"In this case, the rotation around the x axis by 45° is parsed in the format seen above: the name of the axis to be rotated around is given as (upper-case) letter, followed by the rotation angle. If no units are given to the rotation angle, it will be parsed with units.angle.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If the rotation is to be described as multiple subsequent rotations, it can be passed using an array of angles with respective axis description as field name, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    XZ: [45°, 30°]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"will first rotate the tube 45° around the x axis, followed by a 30° rotation around the z axis.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Alternatively, a full 3times3 matrix can be passed using the M field, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    M: [1, 0, 0, 0, 0, -1, 0, 1, 0]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"will transform the primitive using the rotation matrix","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"left beginarrayccc10000-1010endarrayright","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"which corresponds to X: 45°.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Alternative naming for the rotation field can be rotate.","category":"page"},{"location":"man/csg/#Translations","page":"Constructive Solid Geometry (CSG)","title":"Translations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Translations are defined in the configuration files through a Cartesian vector.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If a tube is translated 1cm along the x axis, the translation is parsed to the primitive as additional origin field in the primitive definition.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  origin:\n    x: 1cm","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"The Cartesian vector can also be passed as a vector, i.e.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  origin: [1cm, 0, 0]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If no units are given, the translation is parsed in units of units.length.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Alternative naming for the origin field can be translate and translation.","category":"page"},{"location":"man/csg/#Combination-of-Transformations","page":"Constructive Solid Geometry (CSG)","title":"Combination of Transformations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If both a rotation and translation are defined in a primitive definition, it is first rotated and then translated.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    X: 45°\n  origin: \n    z: 1cm","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"would first rotate the tube by 45° around the x axis before translating it 1cm along the z axis.","category":"page"},{"location":"man/csg/#Transforming-Sets","page":"Constructive Solid Geometry (CSG)","title":"Transforming Sets","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If a union of two primitives should be transformed all together, the transformation can also be defined by nesting the union into a translate with respective information, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"translate: \n  z: 1\n  union:\n    - tube: \n        r: 1\n        h: 1\n    - box: \n        widths: [1,1,1]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Same applies for rotations or other sets, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"rotate: \n  X: 45°\n  difference:\n    - tube: \n        r: 1\n        h: 1\n    - box: \n        widths: [1,1,1]","category":"page"},{"location":"man/IO/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"After simulating the potentials and fields of a detector setup, the results should be saved to a file to avoid recalculating them every time the user starts a program.","category":"page"},{"location":"man/IO/#Saving-output-with-JLD2","page":"IO","title":"Saving output with JLD2","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"One easy way to do this is using JLD2.jl and FileIO.jl.","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Simulation results can be saved to a JLD file using FileIO.save:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using SolidStateDetectors\r\nsim = Simulation(\"<config-file-name>\")\r\n# ...\r\n\r\nusing FileIO\r\nFileIO.save(\"<name-of-simulation-file>.jld\", Dict(\"Simulation\" => sim))","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"It can be read back in using FileIO.load:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using FileIO\r\nsim = FileIO.load(\"<name-of-simulation.file>.jld\", \"Simulation\")","category":"page"},{"location":"man/IO/#Saving-output-with-HDF5","page":"IO","title":"Saving output with HDF5","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"One more compact way of saving simulation results is based on converting the output to a NamedTuple and saving it to a HDF5 file. This requires the HDF5.jl package, as well as the (unregistered) service packages LegendDataTypes.jl and LegendHDF5IO.jl.","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Install the required packages once by running:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using Pkg\r\nPkg.add(url=\"https://github.com/legend-exp/LegendDataTypes.jl.git\")\r\nPkg.add(url=\"https://github.com/legend-exp/LegendHDF5IO.jl.git\")\r\nPkg.add(\"HDF5\")","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Simulation output can be written to a HDF5 file using ssd_write:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using HDF5\r\nusing LegendHDF5IO\r\nusing SolidStateDetectors \r\n# ...\r\n\r\nssd_write(\"<name-of-simulation-file>.h5\", sim)","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"The data stored in the HDF5 file can be read using ssd_read:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using HDF5\r\nusing LegendHDF5IO\r\nusing SolidStateDetectors\r\nssd_read(\"<name-of-simulation-file>.h5\", Simulation)","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"!!!note    All HDF5 related packages must be loaded before loading SolidStateDetectors.jl","category":"page"},{"location":"man/charge_drift/#Charge-Drift","page":"Charge Drift","title":"Charge Drift","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Charged particles in vacuum move along the electric field lines under Coulomb's force, bmF = q bmE, where bmF corresponds to the force experienced by the particle, q is the charge of the particle and bmE is the electric field. Charged particles in vacuum would be continuously accelerated until approaching the speed of light (called ballistic transport), however, inside a material, scattering prevents this constant acceleration and leads to a constant drift velocity ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_d = mu E","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"where v_d is the drift velocity, mu the mobility and E the electric field strength.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The scattering with matter not only limits the absolute drift velocity, it might also deviate the trajectories from the electric field lines: e.g., in crystals, the principal axes orientation has an impact on the resulting drift trajectory. The influence of the scattering on the drift trajectories can be expressed by a 3x3 tensor, the so-called mobility tensor mu_ij, which transforms the electric field, E, into the drift field, v_i:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_i =  mu_ij cdot E_j","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The mobility varies for different materials and depends also on other parameters such as temperature, impurity density and the electric field strength, as explained later.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Electrons and holes have different mobilities, resulting in different drift fields. There are several models for the mobility tensor of electrons and holes in certain materials. Right now, two models are implemented. The first one is a pseudo-drift model, the ElectricFieldChargeDriftModel, which just takes the electric field vectors as drift vectors, see section Electric Field Charge Drift Model. The second one, ADLChargeDriftModel, is a drift model for high purity germanium, see section ADL Charge Drift Model. However, the implementation of an own model is possible and explained in section Custom Charge Drift Model.","category":"page"},{"location":"man/charge_drift/#Electric-Field-Charge-Drift-Model","page":"Charge Drift","title":"Electric Field Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The ElectricFieldChargeDriftModel describes a system in which electrons and holes move along the electric field lines. In this case, the mobility is a scalar pm 1 m²/(Vs) (+ for holes, and - for electrons), and thus, the velocity field has the same (or opposite) direction as the electric field. Even though this model does not describe reality, it is useful in some cases to use the electric field vectors as velocity vectors.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In order to set the ElectricFieldChargeDriftModel for the simulation, the precision type of the calculation T (Float32 or Float64) has to be given as an argument. Note that T has to be of the same precision type of the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = ElectricFieldChargeDriftModel(T)\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)\ncalculate_drift_fields!(sim)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If no charge drift model is specified for the semiconductor of the detector in the configuration files, the default is ElectricFieldChargeDriftModel.","category":"page"},{"location":"man/charge_drift/#ADL-Charge-Drift-Model","page":"Charge Drift","title":"ADL Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In high-purity germanium, the mobility cannot be expressed by a simple scalar quantity. Germanium has a cubic diamond lattice structure with langle100rangle, langle110rangle and langle111rangle as principal directions. Along these axes, the charge drift is parallel to the electric field. However, the longitudinal drift velocity, v_l, is not equally fast on the three axes. ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"On each axes, v_l can be described through the parametrization proposed by D.M. Caughey and R.E. Thomas, which was later expanded by L. Mihailescu et al.:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The parameters mu_0, E_0 and beta differ for electrons and holes, and mu_n is only relevant for electrons. These parameters were obtained by B. Bruyneel et al. by measuring the drift velocities of electrons and holes in the langle100rangle and langle111rangle directions in high purity germanium at a temperature of 78 K. These parameters are stored in a configuration file, \"drift_velocity_config.yaml\", located in <package_directory>/example/example_config_files/ADLChargeDriftModel. The configuration file is expressed as following:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"model: ADLChargeDriftModel\nphi110: -0.785398\nmaterial: HPGe\ndrift:\n  velocity:\n    model: Bruyneel2006\n    parameters:\n      e100:\n        mu0: 3.8609\n        beta: 0.805\n        E0: 51100\n        mun: -0.0171\n      e111:\n        mu0: 3.8536\n        beta: 0.641\n        E0: 53800\n        mun: 0.051\n      h100:\n        mu0: 6.1824\n        beta: 0.942\n        E0: 18500\n      h111:\n        mu0: 6.1215\n        beta: 0.662\n        E0: 18200","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"where the parameters are stored under the keys e100, e111, h100 and h111, in which e and h stand for electrons and holes, respectively, and 100 and 111, for the principal axes langle100rangle and langle111rangle.  By default, in SolidStateDetectors.jl the langle001rangle axis is aligned with the Z-axis of the coordinate system of the simulation. The crystal orientation can be set through the phi110 parameter, where the langle001rangle axis is still aligned with the Z-axis and the angle between the langle110rangle principal direction of the crystal and the X-axis is given by phi110. Alternatively, the crystal orientation can be set by passing a rotation matrix that describes the rotation from the global coordinate system to the crystal orientation system.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If the electric field is not aligned with any of the crystal axes, the charge drift velocity is not necessarily aligned with the electric field. In the ADLChargeDriftModel, two models are implemented to describe the charge drift of electrons and holes between the axes. Detailed information about the charge drift models is provided in the papers from L. Mihailescu et al.  for electrons and from B.Bruyneel et al. for holes. Find the detailed calculations and modifications from the publications as implemented in SolidStateDetectors.jl here.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In order to perform the calculation of the drift fields, a configuration file containing the parametrization values like the \"drift_velocity_config.yaml\" (with Bruyneel's data or modified values), has to be passed as an argument to the ADLChargeDriftModel function. The precision of the the calculation T (Float32 or Float64) has to be given as a keyword T. Note that T has to be of the same type as the chosen in the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_ADL_configuration_file>\", T=T)\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)\ncalculate_drift_fields!(sim)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The ÀDLChargeDriftModel can also be specified already in the configuration file as field charge_drift_model of the semiconductor of a detector, e.g.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"detectors:\n  semiconductor:\n    # ...\n    charge_drift_model:\n      model: ADLChargeDriftModel\n      phi110: -0.785398 # in radians if no units are given\n      material: HPGe\n      drift: # ...","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"or","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"detectors:\n  semiconductor:\n    # ...\n    charge_drift_model:\n      model: ADLChargeDriftModel\n      crystal_orientation:\n        X: 45° # crystal axes correspond to the global xyz coordinate system, rotated 45° around the x axis\n      material: HPGe\n      drift: # ...","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The charge_drift_model needs:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"model: the name of the charge drift model, which in this case is ADLChargeDriftModel\nphi110 or crystal_orientation: the description of the orientation of the crystal with respect to the global coordinate system. When using phi110, the \\langle001\\rangle axis is aligned with the global z axis and phi110 describes the angle between the langle110rangle axis and the x axis in radians (counterclockwise, looking from the top). If the langle001rangle axis is not aligned with the z axis, a rotation matrix to transform the global coordinate system to the crystal axes system can be given.\nmaterial (optional): the semiconductor material. If no material is given, the material of the semiconductor is taken by default.\ndrift: the parameters needed to describe the longitudinal drift velocity along the langle100rangle and langle111rangle axes, see above.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The values from the default configuration file correspond to germanium at 78 K. Calculations of the drift field at other temperatures are also supported by the ADLChargeDriftModel. While experimental observations suggest that the charge mobilities of electrons and holes in the crystal are temperature dependent, the dependency law has not yet been established. Several models have been proposed to reproduce the experimental behavior, and some examples of them can be found in the directory <package_directory>/src/ChargeDriftModels/ADL/. The examples include a linear model, a Boltzmann model and a power-law model. To use these models in the calculation of the drift fields, the corresponding configuration file, the temperature and the precision must be given to the function. As an example, in order to use the Boltzmann model at a temperature of 100 K:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_drift_velocity_config_boltzmann.yaml>\", T = T, temperature = 100) \nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)\ncalculate_drift_fields!(sim)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If no temperature is given as a parameter, the calculations will be performed at a default temperature of 78 K.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"It should be noted that the correct model has not yet been identified, and the parameters inside these configuration files -besides the default ADL ones- are just educated guesses.","category":"page"},{"location":"man/charge_drift/#Custom-Charge-Drift-Model","page":"Charge Drift","title":"Custom Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The user can implement and use his own drift model.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The first step is to define a struct for the model which is a subtype of SolidStateDetectors.AbstractChargeDriftModel:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"using SolidStateDetectors\nusing SolidStateDetectors: SSDFloat, AbstractChargeDriftModel\nusing StaticArrays\n\nstruct CustomChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T} \n    # optional fields to parameterize the model\nend","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The second step is to define two methods (getVe for electrons and getVh for holes), which perform the transformation of an electric field vector, fv::SVector{3,T}, into a velocity vector. Note, that the vectors are in cartesian coordinates, independent of the coordinate system (cartesian or cylindrical) of the simulation. ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"function SolidStateDetectors.getVe(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return -fv\nend\n\nfunction SolidStateDetectors.getVh(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return fv\nend","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Then, one can apply the model to the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = CustomChargeDriftModel{T}()\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)\ncalculate_drift_fields!(sim)","category":"page"},{"location":"man/Grids/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The electric potential is calculated via successive over relaxation on a 3-dimensional grid. SolidStateDetectors.jl can calculate the electric potential on a Cartesian or a cylindrical grid:","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"CartesianGrid: 3 axes: x-, y- and z-axis.\nCylindricalGrid: 3 axes: r-, φ- and z-axis.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The system to simulate, e.g. a cryostat with a detector inside, is called \"the world\". This world is divided into a set of discrete points, called the grid::Grid. It is defined through three axes: grid.axes. Each of the three axes is divided into a discrete number of points (ticks): N_1 N_2 N_3.   The linear combinations of those points form the set of all N_mathrmgp = N_1 times N_2 times N_3 grid points.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"Each axis is defined as a SolidStateDetectors.DiscreteAxis.","category":"page"},{"location":"man/Grids/#DiscreteAxis","page":"Grids","title":"DiscreteAxis","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"A SolidStateDetectors.DiscreteAxis defines the axis of a dimension of a grid, e.g. the x-axis of a CartesianGrid.  A DiscreteAxis, e.g. ax::DiscreteAxis, stores the boundary conditions (reflecting / periodic) at the endpoints of the axis as well as the discrete ticks, ax.ticks, of the axis in the interval ax.interval. The interval also specifies whether the endpoints of the interval are included in the ticks or not via :closed or :open in the type of the interval. The ticks do not need to be evenly spaced, allowing for an adaptive refinement of the grid in areas where the gradient of the electric potential is large.","category":"page"},{"location":"man/Grids/#Grid-Initialization","page":"Grids","title":"Grid Initialization","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The grid can be specified in the configuration files, see Grid, of sim::Simulation.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"There is a constructor method for grid: Grid(sim::Simulation).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"In calculate_electric_potential!,calculate_weighting_potential! and simulate!(sim::Simulation) the calculation of the potentials start with an initial grid, which can be passed to these functions via the keyword grid. If no grid is passed, the grid is generated via Grid(::Simulation).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The two keywords max_tick_distance and max_distance_ratio can also be passed to the functions calculate_electric_potential!,calculate_weighting_potential! and simulate!(sim::Simulation) where they are internally forwarded.","category":"page"},{"location":"man/Grids/#Initialization-of-the-Grid","page":"Grids","title":"Initialization of the Grid","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"Important points of the objects of the simulation are obtained, e.g. the corners of a Box-primitive.  The coordinates of these points are used to generate the ticks of each axis of the grid.\nFor each axis, additional ticks are added based on the keyword max_distance_ratio::Real = 5:  If the ratio between the distances of an axis tick to its neighboring ticks is larger than max_distance_ratio  (or smaller than inv(max_distance_ratio)), additional ticks are inserted such that in the end  all those ratios are within the interval [inv(max_distance_ratio), max_distance_ratio].\nFinally, additional ticks are added for each axis if the distance between two ticks is larger  than a threshold distance specified via the keyword max_tick_distance.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"max_tick_distance can either be a Quantity, e.g. 1u\"mm\", or a Tuple of Quantities, e.g. (1u\"mm\", 0.2u\"cm\", 3u\"mm\"), to set it for each axis of the grid separately. If max_tick_distance is missing, one fourth of the axis length is used.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"See also Grid(::Simulation).","category":"page"},{"location":"man/Grids/#Grid-Refinement","page":"Grids","title":"Grid Refinement","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"After the potential has converged to equilibrium on the initial grid, the grid can be refined (multiple times).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The refinement can be tuned via the keyword refinement_limits in calculate_electric_potential!,calculate_weighting_potential! and simulate!(sim::Simulation).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"It defines the maximum (relative to applied bias voltage) allowed differences of the potential values of neighbored grid points in each dimension for each refinement. It can be specified in different ways, see e.g. calculate_electric_potential!.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"One simple example would be refinement_limits = [0.2, 0.1, 0.05]. This would mean that the grid would be refined three times and the refinement limit would be the same for each dimension of the grid in each refinement. In the first refinement, the refinement limit would be 0.2. Thus, if the bias voltage of the detector in the simulation is 1000 V, the maximum allowed potential difference between two grid points would be 200 V. Let's say there is a potential difference of 500 V between the two grid points at (i,j,k) and (i,j+1,k). Then, two (floor(Int, 500 / 200) = 2) ticks are added in the second axis between the previous axis ticks, grid.axes[2].ticks[j] and grid.axes[2].ticks[j+1], which results in 2 times N_1 times N_3 new additional grid points. The potential values at the added grid points are determined through linear interpolation. Then, the potential values of all grid points are updated (through the SOR) until convergence is reached again and the next refinement with 0.1 is executed.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"Another keyword can be used to set a minimum allowed distance between to ticks: min_tick_distance, see e.g. calculate_electric_potential!, which prohibits the insertion of new ticks if the new resulting distances between the ticks would be below this limit.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"note: Note\nIt is usually favourable to make more refinements with smaller differences in the limits. Thus, for example, refinement_limits = [0.2, 0.1, 0.05, 0.03, 0.01] is usually better than refinement_limits = [0.2, 0.01].","category":"page"},{"location":"man/weighting_potentials/#Weighting-Potentials","page":"Weighting Potentials","title":"Weighting Potentials","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential is a theoretical potential that describes what fraction of a charge at position vecr is seen by a contact, C_i. The weighting potential can take values between 0, i.e. the charge is not seen by the electrode, and 1, i.e. the charge is collected by the electrode. ","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"nabla left( epsilon_r(vecr) nabla Phi_i^w(vecr)right) = 0\r\nPhi_i^w(vecr)vert_C_j = left beginarrayll 1  textif i = j  0  textif i neq j endarray right","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"where Phi_i^w is the electric potential and epsilon_r is the dielectric distribution.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The net charge induced on each electrode C_i, Q_i, by electrons and hole with absolute charge Q is given by the Schockley-Ramo theorem:","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"Q_i = Q left( sumlimits_textholes Phi_i^w(vecr_h) -  sumlimits_textelectrons Phi_i^w(vecr_e) right)","category":"page"},{"location":"man/weighting_potentials/#Simulation-Algorithm","page":"Weighting Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential for an electrode is internally calculated with the same function as the electric potential when calling calculate_weighting_potential!(sim, contact_id). The differences are that rho(vecr) is set to zero and that the boundary conditions of fixed values on the contacts are adapted.","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package is a registered package.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Install via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add SolidStateDetectors\"","category":"page"},{"location":"man/installation/#Visualization-/-Plotting-(Optional)","page":"Installation","title":"Visualization / Plotting (Optional)","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package provides serveral plot recipes for different outputs for the plotting package Plots.jl.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use these also install the Plots.jl package via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add Plots\"","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Load the Plots.jl package (and optionally the backend pyplot) via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Plots","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The backends supported by SolidStateDetectors.jl are gr and pyplot. By default, gr is loaded when importing Plots.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This documentation was build with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg, Plots # hide\r\npkgversion(m::Module) = Pkg.TOML.parsefile(joinpath(dirname(string(first(methods(m.eval)).file)), \"..\", \"Project.toml\"))[\"version\"] # hide\r\nPlots_version = pkgversion(Plots) # hide\r\nGR_version = pkgversion(GR) # hide\r\nprint(\"Plots: v$(Plots_version) - GR: v$(GR_version)\") # hide","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup  = quote\r\n    using SolidStateDetectors\r\n    using SolidStateDetectors.ConstructiveSolidGeometry\r\nend","category":"page"},{"location":"api/#Dictionaries","page":"API","title":"Dictionaries","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:constant]","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SolidStateDetectors, SolidStateDetectors.ConstructiveSolidGeometry]\r\nOrder = [:constant, :type, :function]","category":"page"},{"location":"api/#SolidStateDetectors.SSD_examples","page":"API","title":"SolidStateDetectors.SSD_examples","text":"SSD_examples::Dict{Symbol,String}\n\nDictionary with the paths to the example detector configuration files provided by the package.\n\nFind the possible keys of the dictionary with keys(SSD_examples).\n\nThe example detector configuration files can be loaded via\n\npath_to_config_file = SSD_examples[:InvertedCoax]\nsim = Simulation(path_to_config_file)\n\n\n\n\n\n","category":"constant"},{"location":"api/#SolidStateDetectors.ADLChargeDriftModel","page":"API","title":"SolidStateDetectors.ADLChargeDriftModel","text":"ADLChargeDriftModel{T <: SSDFloat, M <: AbstractDriftMaterial, N, TM <: AbstractTemperatureModel{T}} <: AbstractChargeDriftModel{T}\n\nCharge drift model for electrons and holes based on the AGATA Detector Library. Find a detailed description of the calculations in ADL Charge Drift Model.\n\nFields\n\nelectrons::CarrierParameters{T}: Parameters to describe the electron drift along the <100> and <111> axes.\nholes::CarrierParameters{T}: Parameters to describe the hole drift along the <100> and <111> axes.\ncrystal_orientation::SMatrix{3,3,T,9}: Rotation matrix that transforms the global coordinate system to the crystal coordinate system given by the <100>, <010> and <001> axes of the crystal.\nγ::SVector{N,SMatrix{3,3,T,9}}: Reciprocal mass tensors to the N valleys of the conduction band.\nparameters::ADLParameters{T}: Parameters needed for the calculation of the electron drift velocity.\ntemperaturemodel::TM: Models to scale the resulting drift velocities with respect to temperature\n\nSee also CarrierParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractChargeDensity","page":"API","title":"SolidStateDetectors.AbstractChargeDensity","text":"abstract type AbstractChargeDensity{T <: SSDFloat} end\n\nStruct defining the charge density inside a Passive.\n\nFor each charge density, there should be a method get_charge_density  which returns the charge density in SI units (C/m³) at a given point pt.\n\nExamples\n\nConstantChargeDensity\nLinearChargeDensity\nCylindricalChargeDensity\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractImpurityDensity","page":"API","title":"SolidStateDetectors.AbstractImpurityDensity","text":"abstract type AbstractImpurityDensity{T <: SSDFloat} end\n\nStruct defining an impurity density inside a Semiconductor.\n\nFor each impurity density, there should be a method get_impurity_density which returns the impurity density in SI units (1/m³) at a given point.\n\nExamples\n\nConstantImpurityDensity\nLinearImpurityDensity\nCylindricalImpurityDensity\n\nnote: Note\nThe sign of the impurity density is important. It is taken into account in the conversion to a charge density and, thus, defines where the semiconductor is n-type or p-type. \n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CarrierParameters","page":"API","title":"SolidStateDetectors.CarrierParameters","text":"struct CarrierParameters{T <: SSDFloat}\n\nParameters needed to describe the electron or hole drift along the <100> and <111> axes.\n\nFields\n\naxis100::VelocityParameters{T}: Parameters to describe the charge drift along the <100> axis.\naxis111::VelocityParameters{T}: Parameters to describe the charge drift along the <111> axis.\n\nSee also VelocityParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantChargeDensity","page":"API","title":"SolidStateDetectors.ConstantChargeDensity","text":"struct ConstantChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nCharge density model that assumes a constant charge density everywhere.\n\nFields\n\nρ::T: the constant value of the charge density.\n\nDefinition in Configuration File\n\nA ConstantChargeDensity is defined in the configuration file through the field charge_density  (of a passive or surrounding) with name: constant and a value for ρ.\n\nAn example definition of a constant charge density looks like this:\n\ncharge_density:\n  name: constant\n  value: 1.0e-10 # C/m³\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantImpurityDensity","page":"API","title":"SolidStateDetectors.ConstantImpurityDensity","text":"struct ConstantImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nImpurity density model that assumes a constant impurity density everywhere.\n\nFields\n\nρ::T: the constant value of the impurity density.\n\nDefinition in Configuration File\n\nA ConstantImpurityDensity is defined in the configuration file through the field impurity_density  (of a semiconductor) with name: constant and a value for ρ.\n\nAn example definition of a constant impurity density looks like this:\n\nimpurity_density:\n  name: constant\n  value: 1.0e10 # 1/m³\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Contact","page":"API","title":"SolidStateDetectors.Contact","text":"mutable struct Contact{T, G, MT} <: AbstractContact{T}\n\nContact of a SolidStateDetector.\n\nFor the simulation of the ElectricPotential, all contacts are fixed to a constant potential value.\n\nParametric types:\n\nT: Precision type.\nG: Type of geometry.\nMT: Type of material.\n\nFields\n\npotential::T: Potential (in V) to which the contact will be fixed during the calculation of the ElectricPotential.\nmaterial::MT: Material of the contact.\nid::Int: Unique id that will unambiguously identify the contact.\nname::String: Custom name for the contact, relevant for plotting.\ngeometry::G: Geometry of the contact, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA Contact is defined in the configuration file through an entry in the contacts array of a detector. It needs id, potential and geometry and can optionally be given a name and material.\n\nAn example definition of contacts looks like this:\n\ncontacts:\n  - name: \"n+ contact\"\n    id: 1\n    potential: 5000V\n    material: HPGe # optional\n    geometry: # ....\n  - name: \"p+ contact\"\n    id: 2\n    potential: 0\n    material: HPGe #optional\n    geometry: # ....\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalChargeDensity","page":"API","title":"SolidStateDetectors.CylindricalChargeDensity","text":"struct CylindricalChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nCharge density model which assumes a linear gradient in charge density in each spatial dimension  of a cylindrical coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: charge density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in r and z direction.\n\nDefinition in Configuration File\n\nA CylindricalChargeDensity is defined in the configuration file through the field charge_density  (of a passive or surrounding) with name: cylindrical and optional fields r and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a cylindrical charge density looks like this:\n\ncharge_density:\n  name: cylindrical\n  r:  # impurity profile with linear gradient in r\n    init: 1.0e-10     # C/m³\n    gradient: 1.0e-11 # C/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalImpurityDensity","page":"API","title":"SolidStateDetectors.CylindricalImpurityDensity","text":"struct CylindricalImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nImpurity density model which assumes a linear gradient in impurity density in each spatial dimension  of a cylindrical coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: impurity density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in r and z direction.\n\nDefinition in Configuration File\n\nA CylindricalImpurityDensity is defined in the configuration file through the field impurity_density  (of a passive or surrounding) with name: cylindrical and optional fields r and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a cylindrical impurity density looks like this:\n\nimpurity_density:\n  name: cylindrical\n  r:  # impurity profile with linear gradient in r\n    init: 1.0e10     # 1/m³\n    gradient: 1.0e11 # 1/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DeadVolume","page":"API","title":"SolidStateDetectors.DeadVolume","text":"struct DeadVolume{T, G} <: AbstractVirtualVolume{T}\n\nVolume inside which the charge drift is set to zero.\n\nParametric types\n\nT: Precision type.\nG: Type of geometry.\n\nFields\n\nname::String: Name of the dead volume, relevant for plotting.\ngeometry::G: Geometry of the dead volume, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA DeadVolume is defined through an entry in the virtual_drift_volumes array of a detector with model: dead. It needs a geometry and can optionally be given a name.\n\nAn example definition of dead volumes looks like this:\n\nvirtual_drift_volume:\n  - name: Volume 1\n    model: dead\n    geometry: # ...\n  - name: Volume 2\n    model: dead\n    geometry: # ...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DielectricDistribution","page":"API","title":"SolidStateDetectors.DielectricDistribution","text":"struct DielectricDistribution{T, N, S, AT} <: AbstractArray{T, N}\n\nDielectric distribution, or distribution of the relative permittivity, epsilon_r,  needed to calculate the ElectricPotential. The dielectric distribution is unitless.\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the dielectric distribution at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points at which the electric potential is determined.\n\nnote: Note\nThe data array contains the values of the dielectric distribution at the discrete points  between the points defined by the axes ticks of the extended grid of grid.Thus, size(data) == size(grid) .+ 1 !\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"struct DiscreteAxis{T, BL, BR, I} <: AbstractAxis{T, BL, BR, I}\n\nAxis with discrete ticks which is used to define a dimension of a Grid.\n\nParametric types\n\nT: Type of ticks\nBL: Boundary condition at the left endpoint.\nBR: Boundary condition at the right endpoint.\nI: IntervalSets.Interval (closed or open boundaries)\n\nThe boundary conditions of a DiscreteAxis can be BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}.\n\nFields\n\ninterval::I: Interval that defines the range of the axis.\nticks::Vector{T}: Array of values that correspond to the discrete ticks of the axis.\n\nSee also Grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}\n\nConstructor of a DiscreteAxis.\n\nArguments\n\nleft_endpoint::T: Left endpoint of the interval of the DiscreteAxis.\nright_endpoint::T: Right endpoint of the interval of the DiscreteAxis.\nBL::Symbol: Boundary condition at the left endpoint.\nBR::Symbol: Boundary condition at the right endpoint.\nL::Symbol: Boundary type of the left endpoint.\nR::Symbol: Boundary type of the right endpoint.\nticks::AbstractVector{T}: Array of values that correspond to the discrete ticks of the axis.\n\nThe boundary conditions of a DiscreteAxis can be BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}.\n\nThe boundary types of a DiscreteAxis can be L, R ∈ {:closed, :open}.\n\nExamples\n\nDiscreteAxis(-2.0, 2.0, :infinite, :infinite, :closed, :closed, collect(-2:0.1:2))\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.EffectiveChargeDensity","page":"API","title":"SolidStateDetectors.EffectiveChargeDensity","text":"struct EffectiveChargeDensity{T, N, S, AT} <: AbstractArray{T, N}\n\nEffective charge density needed to calculate the ElectricPotential. The effective charge density is the charge density (in C/m³) times the volume of the voxel of the respective grid point (in m³). Thus, the unit of the effective charge density is Coulomb (C).\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the effective charge density at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points at which the electric potential is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricField","page":"API","title":"SolidStateDetectors.ElectricField","text":"struct ElectricField{T, N, S, AT} <: AbstractArray{T, N}\n\nElectric field of the simulation in units of volt per meter (V/m).\n\nParametric types\n\nT: Element type of grid.axes.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.\n\nFields\n\ndata::Array{<:StaticArray{Tuple{N}, T}, N}: Array containing the field vectors of the electric field at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the electric field is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricFieldChargeDriftModel","page":"API","title":"SolidStateDetectors.ElectricFieldChargeDriftModel","text":"struct ElectricFieldChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T}\n\nCharge drift model in which the electrons and holes drift along the electric field with a mobility of ± 1m²/Vs.\n\nThis model is the default when no charge drift model is defined in the configuration file.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricPotential","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"struct ElectricPotential{T, N, S, AT} <: AbstractArray{T, N}\n\nElectric potential of the simulation in units of volt (V).\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the electric potential at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the electric potential is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Event","page":"API","title":"SolidStateDetectors.Event","text":"mutable struct Event{T <: SSDFloat}\n\nCollection struct for individual events.  This (mutable) struct is meant to be used to look at individual events, not to process a huge amount of events.\n\nFields\n\nlocations::Union{Vector{<:AbstractCoordinatePoint{T}}, Missing}: Vector of the positions of all hits of the event.\nenergies::Union{Vector{T}, Missing}: Vector of energies corresponding to the hits of the event.\ndrift_paths::Union{Vector{EHDriftPath{T}}, Missing}: Calculated drift paths of each hit position. \nwaveforms::Union{Vector{<:Any}, Missing}: Generated signals (waveforms) of the event.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid","page":"API","title":"SolidStateDetectors.Grid","text":"struct Grid{T, N, S <: AbstractCoordinateSystem, AT} <: AbstractGrid{T, N}\n\nCollection of N axes that define the dimensions of the grid needed to calculate  ElectricPotential, ElectricField or WeightingPotential.\n\nParametric types\n\nT: Tick type (element type) of the axes.\nN: Dimension of the grid.\nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.\n\nFields\n\naxes::AT: Tuple of length N containing DiscreteAxis for each dimension of the grid.\n\nSee also DiscreteAxis.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid-Union{Tuple{Simulation{T, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.Grid","text":"Grid(sim::Simulation{T, Cartesian}; kwargs...)\nGrid(sim::Simulation{T, Cylindrical}; kwargs...)\n\nInitializes a Grid based on the objects defined in a Simulation.\n\nThe important points of all objects are sampled and added to the ticks of the grid. The grid initialization can be tuned using a set of keyword arguments listed below.\n\nArguments\n\nsim::Simulation{T, S}: Simulation for which the grid will be defined.\n\nKeywords\n\nmax_tick_distance = missing: Maximum distance between neighbouring ticks of the grid.   Additional grid ticks will be added if two neighbouring ticks are too far apart.   max_tick_distance can either be a Quantity, e.g. 1u\"mm\", or a Tuple of Quantity,    e.g. (1u\"mm\", 15u\"°\", 3u\"mm\"),   to set it for each axis of the Grid separately. Note that a CartesianGrid3D requires a    Tuple{LengthQuantity, LengthQuantity, LengthQuantity} while a CylindricalGrid requires a   Tuple{LengthQuantity, AngleQuantity, LengthQuantity}.   If max_tick_distance is missing, one fourth of the axis length is used.\nmax_distance_ratio::Real = 5: If the ratio between a tick and its left and right neighbour  is greater than max_distance_ratio, additional ticks are added between the ticks that are  further apart. This prevents the ticks from being too unevenly spaced.\nadd_points_between_important_point::Bool = true: If set to true, additional points   will be added in between the important points obtained from sampling the objects of the   simulation. If some objects are too close together, this will ensure a noticeable gap   between them in the calculation of potentials and fields.\nfor_weighting_potential::Bool = false: Grid will be optimized for the calculation of    an ElectricPotential if set to true, and of a WeightingPotential   if set to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.LinearChargeDensity","page":"API","title":"SolidStateDetectors.LinearChargeDensity","text":"struct LinearChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nCharge density model which assumes a linear gradient in charge density in each dimension of a Cartesian coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: charge density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in x, y and z direction.\n\nDefinition in Configuration File\n\nA LinearChargeDensity is defined in the configuration file through the field charge_density  (of a passive or surrounding) with name: linear and optional fields x, y and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a linear charge density looks like this:\n\ncharge_density:\n  name: cylindrical\n  x:  # impurity profile with linear gradient in x\n    init: 1.0e-10     # C/m³\n    gradient: 1.0e-11 # C/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearImpurityDensity","page":"API","title":"SolidStateDetectors.LinearImpurityDensity","text":"struct LinearImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nImpurity density model which assumes a linear gradient in impurity density in each dimension of a Cartesian coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: impurity density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in x, y and z direction.\n\nDefinition in Configuration File\n\nA LinearImpurityDensity is defined in the configuration file through the field impurity_density  (of a passive or surrounding) with name: linear and optional fields x, y and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a linear impurity density looks like this:\n\nimpurity_density:\n  name: cylindrical\n  x:  # impurity profile with linear gradient in x\n    init: 1.0e10     # 1/m³\n    gradient: 1.0e11 # 1/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Passive","page":"API","title":"SolidStateDetectors.Passive","text":"mutable struct Passive{T,G,MT,CDM} <: AbstractPassive{T}\n\nPassive object, assigned to a SolidStateDetector.\n\nFor the calculation of the ElectricPotential and WeightingPotential,  passives can be fixed to a constant potential. They can additionally have a charge density  profile that has an influence on the ElectricPotential.\n\nParametric types\n\nT: Precision type.\nG: Type of geometry.\nMT: Type of material.\nCDM: Type of charge_density_model.\n\nFields\n\nname::String: Custom name for the passive, relevant for plotting.\nid::Int: Unique id that will unambiguously identify the passive.\npotential::T: Potential (in V) to which the passive will be fixed during the calculation of the electric potential.   For floating passives, the potential value is NaN.\ntemperature::T: Temperature (in K) of the passive.\nmaterial::MT: Material of the passive.\ncharge_density_model::CDM: Charge density model for the points inside the passive.\ngeometry::G: Geometry of the passive, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA Passive is defined through an entry in the passives array of a detector or an entry in the surroundings array in the configuration file. It needs material and geometry and can optionally be given a name, id, potential, temperature and charge_density.\n\nAn example definition of passives looks like this:\n\npassives:\n  - name: Passivated Surface\n    material: HPGe\n    charge_density: # ...\n    geometry: # ...\n  - name: Cryostat\n    id: 3\n    potential: 0\n    temperature: 293K\n    material: Al\n    geometry: # ...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointType","page":"API","title":"SolidStateDetectors.PointType","text":"const PointType = UInt8\n\nStores certain information about a grid point via bit-flags. \n\nRight now, there are:\n\nconst update_bit      = 0x01\nconst undepleted_bit  = 0x02\nconst pn_junction_bit = 0x04\n\nExamples\n\nHow to get information out of a PointType variable point_type:\n\npoint_type & update_bit == 0 -> do not update this point (for fixed points)     \npoint_type & update_bit >  0 -> do update this point    \npoint_type & undepleted_bit > 0 -> this point is undepleted\npoint_type & pn_junction_bit > 0 -> this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes","page":"API","title":"SolidStateDetectors.PointTypes","text":"struct PointTypes{T, N, S, AT} <: AbstractArray{T, N}\n\nInformation about the grid points used to calculate the ElectricPotential stored via bit-flags. Data is stored as PointType which is an UInt8.\n\nParametric types\n\nT: Element type of grid.axes.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{PointType, N}: Array containing the point type values at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the point types are determined.\n\nSee also PointType.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SSDInterval","page":"API","title":"SolidStateDetectors.SSDInterval","text":"struct SSDInterval{T <: SSDFloat, L, R, BL, BR} <: IntervalSets.TypedEndpointsInterval{L,R,T}\n\nInterval containing boundary conditions of left and right boundary as parametric type (BL and BR).\n\nParametric types\n\nT: Precision type.\nL: Boundary type of the left endpoint.\nR: Boundary type of the right endpoint.\nBL: Boundary condition at the left endpoint.\nBR: Boundary condition at the right endpoint.\n\nThe boundary types of an SSDInterval can be L, R ∈ {:closed, :open}.\n\nThe boundary conditions of an SSDInterval can be BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}.\n\nFields\n\nleft::T: Value of the left endpoint.\nright::T: Value of the right endpoint.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Semiconductor","page":"API","title":"SolidStateDetectors.Semiconductor","text":"struct Semiconductor{T,G,MT,CDM,IDM} <: AbstractSemiconductor{T}\n\nSemiconductor bulk of a SolidStateDetector.\n\nThis is the volume in which electrons and holes will drift during the signal development.\n\nParametric types\n\nT: Precision type.\nG: Type of geometry.\nMT: Type of material.\nCDM: Type of charge_drift_model.\nIDM: Type of impurity_density_model.\n\nFields\n\ntemperature::T: Temperature (in K) of the semiconductor.\nmaterial::MT: Material of the semiconductor.\nimpurity_density_model::IDM: Impurity density model for the points inside the semiconductor.\ncharge_drift_model::CDM: Model that describes the drift of electrons and holes inside the semiconductor.\ngeometry::G: Geometry of the semiconductor, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA Semiconductor is defined through the semiconductor field of a detector. It needs material and geometry, and can optionally be given a temperature, impurity_density and charge_drift_model.\n\nAn example definition of a semiconductor looks like this:\n\nsemiconductor:\n  material: HPGe\n  temperature: 78\n  impurity_density: # ...\n  charge_drift_model: # ...\n  geometry: # ...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Simulation","page":"API","title":"SolidStateDetectors.Simulation","text":"mutable struct Simulation{T <: SSDFloat, CS <: AbstractCoordinateSystem} <: AbstractSimulation{T}\n\nCollection of all parts of a simulation of a SolidStateDetector.\n\nParametric types\n\nT: Precision type.\nCS: Coordinate system (Cartesian or Cylindrical).\n\nFields\n\nconfig_dict::Dict: Dictionary (parsed configuration file) which initialized the simulation.\ninput_units::NamedTuple: Units with which the config_dict should be parsed.\nmedium::NamedTuple: Medium of the world.\ndetector::Union{SolidStateDetector{T}, Missing}: The SolidStateDetector of the simulation.\nworld::World{T, 3, CS}: The World of the simulation.\nq_eff_imp::Union{EffectiveChargeDensity{T}, Missing}: Effective charge resulting from the impurites in the Semiconductor of the detector.\nq_eff_fix::Union{EffectiveChargeDensity{T}, Missing}: Fixed charge resulting from fixed space charges in Passive of the detector.\nϵ_r::Union{DielectricDistribution{T}, Missing}: The DielectricDistribution of the simulation.\npoint_types::Union{PointTypes{T}, Missing}: The PointTypes of the simulation.\nelectric_potential::Union{ElectricPotential{T}, Missing}: The ElectricPotential of the simulation.\nweighting_potentials::Vector{Any}: The WeightingPotential for each Contact of the detector in the simulation.\nelectric_field::Union{ElectricField{T}, Missing}: The ElectricField of the simulation.\nelectron_drift_field::Union{ElectricField{T}, Missing}: The electron drift field of the simulation.\nhole_drift_field::Union{ElectricField{T}, Missing}: The hole drift field of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SolidStateDetector","page":"API","title":"SolidStateDetectors.SolidStateDetector","text":"struct SolidStateDetector{T,SC,CT,PT,VDM} <: AbstractConfig{T}\n\nStruct to describe all parts of a solid state detector, i.e. the Semiconductor, a set of Contact and (optionally) Passive and virtual drift volumes.\n\nThe properties of the parts (charge densities, fixed potentials, relative permittivity of the materials) will be used as input to the calculation of ElectricPotential and  WeightingPotential in the Simulation.\n\nParametric types\n\nT: Precision type.\nSC: Type of the semiconductor.\nCT: Type of the contacts.\nPT: Type of the passives.\nVDM: Type of the virtual_drift_volumes.\n\nFields\n\nname::String: Name of the detector.\nsemiconductor::SC: Semiconductor of the detector. \ncontacts::CT: Vector of Contact of the detector. \npassives::PT: Vector of Passive objects, e.g. holding structures around the detector. \nvirtual_drift_volumes::VDM: Vector of virtual drift volumes in which the drift can be modulated   by user-defined methods for modulate_driftvector, e.g. DeadVolume.\n\nSee also Semiconductor, Contact, Passive and DeadVolume.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.VelocityParameters","page":"API","title":"SolidStateDetectors.VelocityParameters","text":"struct VelocityParameters{T <: SSDFloat}\n\nValues needed to parametrize the longitudinal drift velocity of electrons or hole along a crystal axis as a function of the electric field strength.\n\nBackground information\n\nThe parameterization for the longitudinal drift velocity, v_l, as a function of the electric  field strength, E, was proposed by D.M. Caughey and R.E. Thomas and later expanded by L. Mihailescu et al.:\n\nv_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E\n\nwith the four parameters, mu_0, beta, E_0 and mu_n, which are different for electrons and holes and for the different crystal axes.\n\nnote: Note\nThe parameter mu_n accounts for the Gunn effects for electrons and should be 0 for holes.\n\nFields\n\nmu0::T: Parameter mu_0 in the parameterization shown above.\nbeta::T: Parameter beta in the parameterization shown above.\nE0::T: Parameter E_0 in the parameterization shown above.\nmun::T: Parameter mu_n in the parameterization shown above.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.WeightingPotential","page":"API","title":"SolidStateDetectors.WeightingPotential","text":"struct WeightingPotential{T, N, S, AT} <: AbstractArray{T, N}\n\nWeighting potential for a given Contact which is a unitless potential.\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the weighting potential at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the weighting potential is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.World","page":"API","title":"SolidStateDetectors.World","text":"struct World{T <: SSDFloat, N, S} <: AbstractWorld{T, N}\n\nDefinition of the finite volume on which a Simulation is performed.\n\nParametric types\n\nT: Precision type.\nN: Dimensions of the world.\nS: Coordinate system (Cartesian or Cylindrical).\n\nFields\n\nintervals::NTuple{N, SSDInterval{T}}: A set of SSDInterval defining the dimensions of the world.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.add_baseline_and_extend_tail-Union{Tuple{UV}, Tuple{TV}, Tuple{U}, Tuple{T}, Tuple{RadiationDetectorSignals.RDWaveform{T, U, TV, UV}, Int64, Int64}} where {T, U, TV, UV}","page":"API","title":"SolidStateDetectors.add_baseline_and_extend_tail","text":"add_baseline_and_extend_tail(wv::RadiationDetectorSignals.RDWaveform{T,U,TV,UV}, n_baseline_samples::Int, total_waveform_length::Int) where {T,U,TV,UV}\n\nAdds a zero-valued baseline in front of the waveform wv and extends (or cuts off) the waveform at the end with the last value of wv. A waveform of length total_waveform_length is returned.\n\nArguments\n\nwv::RadiationDetectorSignals.RDWaveform{T,U,TV,UV}: A waveform (signal over time).\nn_baseline_samples::Int: Number of samples added in front of the waveform with values 0. \ntotal_waveform_length::Int: Number of samples of the extended waveform which is returned.\n\nExamples\n\nadd_baseline_and_extend_tail(wv, 1000, 5000)\n\nnote: Note\nThis functions assumes that the time steps between the samples of the input waveform wv are the same. Thus, that the input waveform is sampled with a fixed frequency. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.add_fano_noise","page":"API","title":"SolidStateDetectors.add_fano_noise","text":"add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity\n\nAdds Fano noise to an energy deposition E_dep, assuming a detector material ionisation energy E_ionisation and a Fano factor f_fano.\n\nArguments\n\nE_dep::RealQuantity: Energy deposited in a semiconductor material.\nE_ionisation: Energy needed to create one electron-hole-pair in the semiconductor material.\nf_fano: Fano factor of the material.\n\nExample\n\nadd_fano_noise(100u\"keV\", 2.95u\"eV\", 0.129)\n\nSome material properties are stored in SolidStateDetectors.material_properties and can be used here:\n\nmaterial = SolidStateDetectors.material_properties[:HPGe]\nadd_fano_noise(100u\"keV\", material.E_ionisation, material.f_fano)\n\nnote: Note\nUsing values with units for E_dep or E_ionisation requires the package Unitful.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Grid{T, N, S, AT} where {N, S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where {T<:Union{Float16, Float32, Float64}, CS}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim);\n        not_only_paint_contacts::Bool = true, paint_contacts::Bool = true)::Nothing where {T <: SSDFloat}\n\nApplies the initial state for the calculation of the ElectricPotential. It overwrites sim.electric_potential, sim.q_eff_imp, sim.q_eff_fix, sim.ϵ and sim.point_types with the material properties and fixed potentials defined in sim.detector.\n\nArguments\n\nsim::Simulation{T}: Simulation for which the initial state should be applied.\ngrid::Grid{T}: Grid to apply the initial state on. If no grid is given,    a default Grid is determined from sim.\n\nKeywords\n\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\n\nExamples\n\napply_initial_state!(sim, ElectricPotential, paint_contacts = false)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Grid{T, N, S, AT} where {N, S<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, AT}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim))::Nothing\n\nApplies the initial state for the calculation of the WeightingPotential for the [Contact}(@ref) with the id contact_id. It overwrites sim.weighting_potentials[contact_id] with the fixed values on the [Contact}(@ref).\n\nArguments\n\nsim::Simulation{T}: Simulation for which the initial state should be applied.\ncontact_id::Int: The id of the Contact for which the WeightingPotential is to be calculated.\ngrid::Grid{T}: Grid to apply the initial state on. If no grid is given,    a default Grid is determined from sim.\n\nKeywords\n\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\n\nExamples\n\napply_initial_state!(sim, WeightingPotential, 1) # =>  applies initial state for weighting potential of contact with id 1\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_capacitance-Tuple{Simulation, Int64}","page":"API","title":"SolidStateDetectors.calculate_capacitance","text":"calculate_capacitance(sim::Simulation, contact_id::Int = 1; consider_multiplicity::Bool = true)\n\nReturns the capacitance, C, of the contact with ID contact_id in units of pF calculated via \n\nC = 2 W_WP  1 V^2\n\nwhere W_WP is the (pseudo) energy stored in the \"electric field\" (gradient) of the weighting potential of the contact. \n\nArguments\n\nsim::Simulation{T}: Simulation with sim.detector for which the capacitance is calculated.\ncontact_id::Int: The ID of the contact for which the capacitance should be calculated.\n\nKeywords\n\nconsider_multiplicity::Bool = true: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the x-axis going from [0, x_max] and the y-axis going from [0, y_max] the multiplicity is 4   and, if consider_multiplicity == true, the returned value is already multiplied by 4.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_capacitance-Tuple{Simulation}","page":"API","title":"SolidStateDetectors.calculate_capacitance","text":"calculate_capacitance(sim::Simulation; consider_multiplicity::Bool = true)\n\nReturns the capacitance, C, of a SolidStateDetector in a given Simulation in units of pF calculated via \n\nC = 2 W_E  V_BV\n\nwhere W_E is the energy stored in the electric field (calculate_stored_energy)  created by the detector with the applied bias voltage V_BV. \n\nArguments\n\nsim::Simulation{T}: Simulation with sim.detector for which the capacitance is calculated.\n\nKeywords\n\nconsider_multiplicity::Bool = true: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the x-axis going from [0, x_max] and the y-axis going from [0, y_max] the multiplicity is 4   and, if consider_multiplicity == true, the returned value is already multiplied by 4.\n\ndanger: Danger\nIn general, this method is only valid if the system, detector and its surroundings, is symmetric with respect to the contacts and the impurity density is zero and no fixed charge densities are present (or in the limit of very high bias voltages where the contribution of those densities become negligible). Then, the returned capacitance equals the capacitance of each contact.For asymmetric cases and zero impurity/charge densities,  the calculated capacitance of this method equals the contact capacitance of the contact which is not at ground.In general, use calculate_capacitance(::Simulation, ::Int)  to calculate the capacitance of a specific contact via its weighting potential.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_drift_fields!-Union{Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_drift_fields!","text":"calculate_drift_fields!(sim::Simulation{T}; use_nthreads::Int = Base.Threads.nthreads())\n\nCalculates the drift fields for electrons and holes from the ElectricField, sim.electric_field and the charge drift model sim.detector.semiconductor.charge_drift_model and stores them in sim.electron_drift_field and sim.hole_drift_field.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_field has already been calculated.\n\nKeywords\n\nuse_nthreads::Int = Base.Threads.nthreads(): Number of threads that should be used when calculating the drift fields.\n\nExamples\n\ncalculate_drift_fields!(sim, use_nthreads = 4)\n\nnote: Note\nThis method only works if sim.electric_field has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_field!-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}} where {T<:Union{Float16, Float32, Float64}, CS}","page":"API","title":"SolidStateDetectors.calculate_electric_field!","text":"calculate_electric_field!(sim::Simulation{T}; n_points_in_φ::Union{Missing, Int} = missing)::Nothing\n\nCalculates the ElectricField from the ElectricPotential stored in sim.electric_potential and stores it in sim.electric_field. \n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_potential has already been calculated.\n\nKeywords\n\nn_points_in_φ::Union{Missing, Int}: For a 2D ElectricPotential (cylindrical coordinates and symmetric in φ), sim.electric_potential   is extended to n_points_in_φ \"layers\" in φ in order to calculate a 3D [ElectricField]. If n_points_in_φ is missing, the    default value is 36.\n\nExamples\n\ncalculate_electric_field!(sim, n_points_in_φ = 32)\n\nnote: Note\nThis method only works if sim.electric_potential has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Vararg{Any, N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_electric_potential!","text":"calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing\n\nCalculates the ElectricPotential for a given Simulation sim on an adaptive grid through successive over relaxation and stores it in sim.electric_potential.\n\nThere are several keyword arguments which can be used to tune the calculation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which the ElectricPotential is calculated.\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 1e-7 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions.\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension.\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ngrid::Grid: Initial grid used to start the simulation. Default is Grid(sim).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Union{Int, Vector{Int}}: If <:Int, use_nthreads defines the maximum number of threads to be used in the computation.    Fewer threads might be used depending on the current grid size due to threading overhead. Default is Base.Threads.nthreads().   If <:Vector{Int}, use_nthreads[i] defines the number of threads used for each grid (refinement) stage of the field simulation.   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\ncalculate_electric_potential!(sim, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_stored_energy-Tuple{Simulation}","page":"API","title":"SolidStateDetectors.calculate_stored_energy","text":"calculate_stored_energy(sim::Simulation; consider_multiplicity::Bool = true)\n\nCalculates and returns the energy stored in the ElectricField of a  SolidStateDetector in a given Simulation in units of J.\n\nArguments\n\nsim::Simulation{T}: Simulation with sim.detector for which the stored energy is calculated.\n\nKeywords\n\nconsider_multiplicity::Bool = true: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the x-axis going from [0, x_max] and the y-axis going from [0, y_max] the multiplicity is 4   and, if consider_multiplicity == true, the returned value is already multiplied by 4.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Int64, Vararg{Any, N} where N}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_weighting_potential!","text":"calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing\n\nCalculates the WeightingPotential for a Contact with contact_id  given Simulation sim on an adaptive grid through successive over relaxation  and stores it in sim.weighting_potentials[contact_id].\n\nThere are several keyword arguments which can be used to tune the calculation.\n\nKeywords\n\nconvergence_limit::Real: convergence_limit sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 1e-7.\nrefinement_limits: Defines the maximum relative allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions.\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension.\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ngrid::Grid: Initial grid used to start the simulation. Default is Grid(sim).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false. This is an experimental feature:   In undepleted regions (determined in calculate_electric_potential!(sim; depletion_handling = true)), the dielectric permittivity   of the semiconductor is scaled up to mimic conductive behavior. The scale factor can be tuned via    the function scaling_factor_for_permittivity_in_undepleted_region.\nuse_nthreads::Union{Int, Vector{Int}}: If <:Int, use_nthreads defines the maximum number of threads to be used in the computation.    Fewer threads might be used depending on the current grid size due to threading overhead. Default is Base.Threads.nthreads().   If <:Vector{Int}, use_nthreads[i] defines the number of threads used for each grid (refinement) stage of the field simulation.   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\ncalculate_weighting_potential!(sim, 1, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.drift_charges!","text":"drift_charges!(evt::Event{T}, sim::Simulation{T}; max_nsteps::Int = 1000, Δt::RealQuantity = 5u\"ns\", verbose::Bool = true)::Nothing where {T <: SSDFloat}\n\nCalculates the electron and hole drift paths for the given Event and Simulation     and stores them in evt.drift_paths.\n\nArguments\n\nevt::Event{T}: Event for which the charges should be drifted.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in evt should drift.\n\nKeywords\n\nmax_nsteps::Int = 1000: Maximum number of steps in the drift of each hit. \nΔt::RealQuantity = 5u\"ns\": Time step used for the drift.\nverbose = true: Activate or deactivate additional info output.\n\nExample\n\ndrift_charges!(evt, sim, Δt = 1u\"ns\", verbose = false)\n\nnote: Note\nUsing values with units for Δt requires the package Unitful.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical, AT} where AT}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_active_volume","text":"get_active_volume(point_types::PointTypes{T}) where {T}\n\nReturns an approximation of the active volume of the detector by summing up the cell volumes of all cells marked as depleted.\n\nArguments\n\npoint_types::PointTypes{T}: Point types of a Simulation.\n\nExamples\n\nget_active_volume(sim.point_types)\n\nnote: Note\nOnly φ-symmetries are taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_charge_density","page":"API","title":"SolidStateDetectors.get_charge_density","text":"get_charge_density(cd::AbstractChargeDensity, pt::AbstractCoordinatePoint)\n\nReturns the charge density at a given point, pt, based on the charge density model cd.\n\nArguments\n\ncd::AbstractChargeDensity: The AbstractChargeDensity defining the charge density inside a Passive.\npt::AbstractCoordinatePoint: The point at which cd is to be evaluated.\n\nnote: Note\nThe value returned by get_charge_density is in units of C/m³ (SI units).\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_electron_drift_field","text":"get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the electron charge drift model onto the electric field vectors and returns the electron drift field.\n\nnote: Note\nThe field vectors in ef have to be in Cartesian coordinates. \n\nArguments\n\nef::Array{SVector{3, T},3}: Three-dimensional array with ElectricField vectors, e.g. sim.electric_field.data.\nchargedriftmodel::AbstractChargeDriftModel: Model that describes the electron drift in the Semiconductor.\n\nKeywords\n\nuse_nthreads::Int = Base.Threads.nthreads(): Number of threads that should be used when calculating the drift fields.\n\nExample\n\nget_electron_drift_field(sim.electric_field.data, sim.detector.semiconductor.charge_drift_model)\n\nnote: Note\nThis method only works if sim.electric_field has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_hole_drift_field-Union{Tuple{T}, Tuple{Array{StaticArrays.SVector{3, T}, 3}, SolidStateDetectors.AbstractChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_hole_drift_field","text":"get_hole_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::AbstractChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the hole charge drift model onto the electric field vectors and returns the hole drift field.\n\nnote: Note\nThe field vectors in ef have to be in Cartesian coordinates. \n\nArguments\n\nef::Array{SVector{3, T},3}: Three-dimensional array with ElectricField vectors, e.g. sim.electric_field.data.\nchargedriftmodel::AbstractChargeDriftModel: Model that describes the hole drift in the Semiconductor.\n\nKeywords\n\nuse_nthreads::Int = Base.Threads.nthreads(): Number of threads that should be used when calculating the drift fields.\n\nExample\n\nget_hole_drift_field(sim.electric_field.data, sim.detector.semiconductor.charge_drift_model)\n\nnote: Note\nThis method only works if sim.electric_field has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_impurity_density","page":"API","title":"SolidStateDetectors.get_impurity_density","text":"get_impurity_density(id::AbstractImpurityDensity, pt::AbstractCoordinatePoint)\n\nReturns the impurity density at a given point, pt, based on the impurity density model id.\n\nArguments\n\nid::AbstractImpurityDensity: The AbstractImpurityDensity defining the impurity density inside a Semiconductor.\npt::AbstractCoordinatePoint: The point at which id is to be evaluated.\n\nnote: Note\nThe value returned by get_impurity_density is in units of 1/m³ (SI Units).\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.get_path_to_example_config_files-Tuple{}","page":"API","title":"SolidStateDetectors.get_path_to_example_config_files","text":"get_path_to_example_config_files()::String\n\nReturns the path to the example detector configuration files provided by the package.\n\nSee also SSD_examples.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_signals!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_signals!","text":"get_signals!(evt::Event{T}, sim::Simulation{T}; Δt::RealQuantity = 5u\"ns\")::Nothing where {T <: SSDFloat}\n\nGenerates the signals/waveforms from the drift paths of an Event for each Contact, for which a WeightingPotential is specified in sim.weighting_potentials.\n\nThe output is stored in evt.waveforms.\n\nArguments\n\nevt::Event{T}: Event for which the waveforms should be generated.\nsim::Simulation{T}: Simulation which defines the setup in which the waveforms are generated.\n\nKeywords\n\nΔt::RealQuantity = 5u\"ns\": Time steps with which the drift paths were calculated.\n\nExample\n\nget_signals!(evt, sim, Δt = 1u\"ns\") # if evt.drift_paths were calculated in time steps of 1ns\n\nnote: Note\nThis method only works if evt.drift_paths has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.is_depleted-Tuple{PointTypes}","page":"API","title":"SolidStateDetectors.is_depleted","text":"is_depleted(point_types::PointTypes)::Bool\n\nReturns true if all PointType values of the PointTypes of a Simulation are marked as depleted and false if any point in the PointTypes is marked as undepleted.\n\nIt can be used to determine whether the SolidStateDetector is depleted at the provided bias voltage.\n\nArguments\n\npoint_types::PointTypes: PointTypes of a Simulation.\n\nExamples\n\nis_depleted(sim.point_types)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.parse_config_file-Tuple{AbstractString}","page":"API","title":"SolidStateDetectors.parse_config_file","text":"parse_config_file(filename::AbstractString)::Dict where {T <: SSDFloat}\n\nReads in a configuration file and returns a parsed dictionary which holds all the information specified in the configuration file.\n\nFind detailed information on configuration files in Configuration Files.\n\nArguments\n\nfilename::AbstractString: File name of the configuration file. If the file is not   in the same directory, a path to the file is required.\n\nnote: Note\nCurrently supported formats for the configuration files:     - YAML: filename ends with .yaml.     - JSON: filename ends with .json.     - SigGen: filename ends with .config.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.readsiggen-Tuple{String}","page":"API","title":"SolidStateDetectors.readsiggen","text":"readsiggen(file_path::String; T::Type)\n\nReads a SigGen configuration file (ending in .config) in 'file_path' and returns a dictionary of all parameters. Non-existing parameteres are set to 0.\n\nArguments\n\nfile_path::String: File path leading to the SigGen configuration file.\n\nKeywords\n\nT::Type: Type of the parameters in the output dictionary. Default is Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple, minimum_distances::Tuple, kwargs...)\n\nTakes the current state of sim.electric_potential and refines it with respect to the input arguments max_diffs and minimum_distances by\n\nextending the grid of sim.electric_potential to be a closed grid in all dimensions,\nrefining the axis of the grid based on max_diffs and minimum_distances: Insert new ticks between two existing ticks such that the potential difference between each tick becomes smaller than max_diff[i] (i -> dimension) but that the distances between the ticks stays larger than minimum_distances[i], and\ncreating the new data array for the refined grid and fill it by interpolation of the the initial grid.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_potential will be refined.\nmax_diffs::Tuple{<:Real,<:Real,<:Real}: Maximum potential difference between two discrete ticks of sim.electric_potential.grid after refinement.\nminimum_distances::Tuple{<:Real,<:Real,<:Real}: Minimum distance (in SI Units) between two discrete ticks of sim.electric_potential.grid after refinement.\n\nExamples\n\nSolidStateDetectors.refine!(sim, ElectricPotential, max_diffs = (100, 100, 100), minimum_distances = (0.01, 0.02, 0.01))\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.weighting_potentials[contact_id] and refines it with respect to the input arguments max_diffs and minimum_distances by\n\nextending the grid of sim.weighting_potentials[contact_id] to be a closed grid in all dimensions,\nrefining the axis of the grid based on max_diffs and minimum_distances: Insert new ticks between two existing ticks such that the potential difference between each tick becomes smaller than max_diff[i] (i -> dimension) but that the distances between the ticks stays larger than minimum_distances[i], and\ncreating the new data array for the refined grid and fill it by interpolation of the the initial grid.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.weighting_potentials[contact_id] will be refined.\ncontact_id::Int: The id of the Contact for which the WeightingPotential is refined.\nmax_diffs::Tuple{<:Real,<:Real,<:Real}: Maximum potential difference between two discrete ticks of sim.weighting_potentials[contact_id].grid after refinement.\nminimum_distances::Tuple{<:Real,<:Real,<:Real}: Minimum distance (in SI Units) between two discrete ticks of sim.weighting_potentials[contact_id].grid after refinement.\n\nExamples\n\nSolidStateDetectors.refine!(sim, WeightingPotential, 1, max_diffs = (0.01, 0.01, 0.01), minimum_distances = (0.01, 0.02, 0.01))\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T, G, MT, CDM, IDM} where {G, MT, CDM, IDM}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region","text":"scaling_factor_for_permittivity_in_undepleted_region(sc::Semiconductor{T})::T where {T}\n\nThis function is called in the calculations of weighting potentials of undepleted detectors.  The electric permittivity, ϵ_r, is scaled with this function in areas where the detector is undepleted. A value between [0, +Inf] should be returned. However, Inf should not be returned but instead a very high value should be returned in order to mimic perfect conductivity if that is desired. \n\nArguments\n\nsc::Semiconductor{T}: Semiconductor for which the dielectric permittivity should be scaled up.\n\ndanger: Experimental feature!\nThis feature is under research. The goal is to study the properties / signal response of undepleted detector.  This function is indented to be overwritten by the user to study the response. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.siggentodict-Tuple{Dict}","page":"API","title":"SolidStateDetectors.siggentodict","text":"siggentodict(config::Dict; units::Dict)\n\nConverts the dictionary containing the parameters from a SigGen configuration file to a dictionary that can be understood by SolidStateDetectors.jl. \n\nArguments\n\nconfig::Dict: Dictionary containing SigGen parameters (output of readsiggen()`).\n\nKeywords\n\nunits::Dict: Units used in SigGen configuration file (set to \"mm\", \"deg\", \"V\" and \"K\").   The dictionary needs the fields \"length\", \"angle\", \"potential\" and \"temperature\".\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T<:Union{Float16, Float32, Float64}, S}","page":"API","title":"SolidStateDetectors.simulate!","text":"simulate!( sim::Simulation{T}; kwargs...) where {T, S}\n\nPerforms a full chain simulation for a given Simulation by\n\ncalculating the ElectricPotential,\ncalculating the ElectricField,\ncalculating the electron and hole drift fields and\ncalculating the WeightingPotential for each Contact.\n\nThe output is stored in sim.electric_potential, sim.electric_field, sim.electron_drift_field, sim.hole_drift_field and sim.weighting_potentials, respectively.\n\nThere are several keyword arguments which can be used to tune the simulation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which the full chain simulation should be performed.\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 1e-7 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighboured grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions.\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension.\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nSee also calculate_electric_potential!, calculate_electric_field!, calculate_drift_fields! and calculate_weighting_potential!.\n\nExample\n\nsimulate!(sim, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate!","text":"simulate!(evt::Event{T}, sim::Simulation{T}; kwargs...)::Nothing where {T <: SSDFloat}\n\nSimulates the waveforms for the Event for a given Simulation by\n\ncalculating the drift paths of all energy hits, at evt.locations and \ngenerating the waveforms for each Contact, for which a WeightingPotential is specified in sim.weighting_potentials.\n\nThe output is stored in evt.drift_paths and evt.waveforms.\n\nArguments\n\nevt::Event{T}: Event for which the charges should be drifted.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in evt should drift.\n\nKeywords\n\nmax_nsteps::Int = 1000: Maximum number of steps in the drift of each hit. \nΔt::RealQuantity = 5u\"ns\": Time step used for the drift.\nverbose = true: Activate or deactivate additional info output.\n\nExample\n\nsimulate!(evt, sim, Δt = 1u\"ns\", verbose = false)\n\nSee also drift_charges! and get_signals!.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate_waveforms-Union{Tuple{T}, Tuple{TypedTables.Table, Simulation{T, CS} where CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate_waveforms","text":"simulate_waveforms( mcevents::TypedTables.Table, sim::Simulation{T}; kwargs...)\nsimulate_waveforms( mcevents::TypedTables.Table, sim::Simulation{T}, output_dir::AbstractString, output_base_name::AbstractString; kwargs...)\n\nSimulates the waveforms for all events defined in mcevents for a given Simulation by\n\ncalculating the drift paths of all energy hits defined in mcevents  based on the drift fields for electrons and holes stored in sim.electron_drift_field and   sim.hole_drift_field, \ndetermining the signal (waveforms) for each Contact,   for which a WeightingPotential is specified in sim.weighting_potentials.\n\nArguments\n\nmcevents::TypedTables.Table: Table with information about events in the simulated setup.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in mcevents should drift.\n\nIf HDF5.jl is loaded, this function has additional arguments. \n\nAdditional Arguments (HDF5)\n\noutput_dir::AbstractString: Directory where the HDF5 output file is saved.\noutput_base_name::AbstractString: Basename of the HDF5 output file, default is \"generated_waveforms\".\n\nKeywords\n\nmax_nsteps::Int = 1000: Maximum number of steps in the drift of each hit. \nΔt::RealQuantity = 4u\"ns\": Time step used for the drift.\nverbose = false: Activate or deactivate additional info output.\nchunk_n_physics_events::Int = 1000 (HDF5 only): Number of events that should be saved in a single HDF5 output file.\n\nExamples\n\nsimulate_waveforms(mcevents, sim, Δt = 1u\"ns\", verbose = false)\n# => returns the input table `mcevents` with an additional column `waveform` in which the generated waveforms are stored\n\nimport HDF5\nsimulate_waveforms(mcevents, sim, \"output_dir\", \"my_basename\", Δt = 1u\"ns\", verbose = false)\n# => simulates the charge drift and saves the output to \"output_dir/my_basename_evts_xx.h5\"\n\nnote: Note\nThe drift paths are just calculated temporarily and not returned.\n\nnote: Note\nUsing values with units for Δt requires the package Unitful.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ssd_read","page":"API","title":"SolidStateDetectors.ssd_read","text":"ssd_read(filename::AbstractString, ::Type{Simulation})\n\nReads a Simulation from a HDF5 file with a given filename  using LegendHDF5IO.jl.\n\nArguments\n\nfilename::AbstractString: Filename of the HDF5 file.\n\nExample\n\nusing HDF5 \nusing LegendHDF5IO\nusing SolidStateDetectors\nsim = ssd_read(\"example_sim.h5\", Simulation)\n\nnote: Note\nIn order to use this method, the packages HDF5.jl and  LegendHDF5IO.jl have to be loaded before loading SolidStateDetectors.jl.\n\nSee also ssd_write.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.ssd_write","page":"API","title":"SolidStateDetectors.ssd_write","text":"ssd_write(filename::AbstractString, sim::Simulation)\n\nConverts a Simulation to a NamedTuple and writes it to a HDF5 file  with a given filename using LegendHDF5IO.jl.\n\nArguments\n\nfilename::AbstractString: Filename of the HDF5 file.\nsim::Simulation: Simulation that should be written to the HDF5 file.\n\nExample\n\nusing HDF5 \nusing LegendHDF5IO\nusing SolidStateDetectors\nsim = Simulation(SSD_examples[:InvertedCoax])\nsimulate!(sim)\nssd_write(\"example_sim.h5\", sim)\n\nwarn: Warn\nIf a file with filename already exists, it will be overwritten by this method.\n\nnote: Note\nIn order to use this method, the packages HDF5.jl and  LegendHDF5IO.jl have to be loaded before loading SolidStateDetectors.jl.\n\nSee also ssd_read.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.electric_potential and updates it until it has converged.\n\nThere are several keyword arguments which can be used to tune the simulation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_potential will be updated.\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default is 1e-7.\n\nKeywords\n\nn_iterations_between_checks::Int: Number of iterations between checks. Default is set to 500.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is -1. If set to -1 there will be no limit.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\nSolidStateDetectors.update_till_convergence!(sim, ElectricPotential, 1e-6, depletion_handling = true)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.weighting_potentials[contact_id] and updates it until it has converged.\n\nThere are several keyword arguments which can be used to tune the simulation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.weighting_potentials[contact_id] will be updated.\ncontact_id::Int: The id of the Contact for which the WeightingPotential is to be calculated.\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default is 1e-7.\n\nKeywords\n\nn_iterations_between_checks::Int: Number of iterations between checks. Default is set to 500.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is -1. If set to -1 there will be no limit.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false. This is an experimental feature:   In undepleted regions (determined in calculate_electric_potential!(sim; depletion_handling = true)), the dielectric permittivity   of the semiconductor is scaled up to mimic conductive behavior. The scale factor can be tuned via    the function scaling_factor_for_permittivity_in_undepleted_region.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\nSolidStateDetectors.update_till_convergence!(sim, WeightingPotential, 1, 1e-6, use_nthreads = 4)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Box","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Box","text":"struct Box{T, CO} <: AbstractVolumePrimitive{T}\n\nVolume primitive describing a three-dimensional Box with its surfaces being parallel to the xy, xy and yz plane.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\n\nFields\n\nhX::T: Half of the width in x dimension (in m).\nhY::T: Half of the width in y dimension (in m).\nhZ::T: Half of the width in z dimension (in m).\norigin::CartesianPoint{T}: The position of the center of the Box.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Box around its origin.\n\nDefinition in Configuration File\n\nA Box is defined in the configuration file as part of the geometry field  of an object through the field box.\n\nExample definitions of a Box looks like this:\n\nbox:\n  widths: [2, 4, 6] # => hX = 1; hY = 2; hZ = 3;\n  origin: [0, 0, 0] # [x, y, z] - Optional; Default: [0, 0, 0]\n  rotate: # Optional; Default: no rotation\n    Z: 0 \n\nThe halfwidths hX, hY and hZ can also be defined directly in the configuration file:\n\nbox:\n  halfwidths: [1, 2, 3] # => hX = 1; hY = 2; hZ = 3;\n\nor\n\nbox:\n  hX: 1\n  hY: 2\n  hZ: 3\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","text":"struct CSGUnion{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\nA CSGDifference of two geometries a and b is defined as the set of points that are  in a but not in b (a && !b).\n\n(Image: CSGDifference)\n\nnote: Note\nNote that b is treated as open primitive. This means that points which are in  a and on the surface of b will still be in the CSGDifference of a and b.\n\nParametric types\n\nT: Precision type.\nA: Type of geometry a.\nB: Type of geometry b.\n\nFields\n\na::A: Main geometry.\nb::B: Geometry to be subtracted from a.\n\nDefinition in Configuration File\n\nA CSGDifference is defined in the configuration file as part of the geometry field  of an object through the field difference, followed by an array of geometries from which the difference is constructed. The first entry of the array is the main geometry,  from which all following geometry entries are subtracted.\n\nAn example definition of a CSGDifference looks like this:\n\ndifference: # a && !b\n  - tube: # a\n      r: 2\n      h: 1\n  - tube: # b\n      r: 1\n      h: 1.1\n\nnote: Note\nIf more than two geometries are passed, all entries starting from the second will be subtracted from the first.\n\nnote: Note\nKeep in mind that to discard the part of the surface of a which is on the surface of b,  b should be chosen slightly bigger than a.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","text":"struct CSGIntersection{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\nA CSGIntersection of two geometries a and b is defined as the set of points  that are both in a and in b (a && b).\n\n(Image: CSGIntersection)\n\nParametric types\n\nT: Precision type.\nA: Type of geometry a.\nB: Type of geometry b.\n\nFields\n\na::A: First geometry to build the intersection.\nb::B: Second geometry to build the intersection.\n\nDefinition in Configuration File\n\nA CSGIntersection is defined in the configuration file as part of the geometry field  of an object through the field intersection, followed by an array of geometries from which the intersection is constructed. \n\nAn example definition of a CSGIntersection looks like this:\n\nintersection: # a && b\n  - tube: # a\n      r: 2\n      h: 1\n  - tube: # b\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5\n\nnote: Note\nIf more than two geometries are passed, the intersection is constructed from all of them.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","text":"struct CSGUnion{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\nA CSGUnion of two geometries a and b is defined as the set of points that are in at least  one of either a or b (a || b).\n\n(Image: CSGUnion)\n\nParametric types\n\nT: Precision type.\nA: Type of geometry a.\nB: Type of geometry b.\n\nFields\n\na::A: First geometry to build the union.\nb::B: Second geometry to build the union.\n\nDefinition in Configuration File\n\nA CSGUnion is defined in the configuration file as part of the geometry field  of an object through the field union, followed by an array of geometries from which the union is constructed. \n\nAn example definition of a CSGUnion looks like this:\n\nunion: # a || b\n  - tube: # a\n      r: 2\n      h: 1\n  - tube: # b\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5\n\nnote: Note\nIf more than two geometries are passed, the union is constructed from all of them.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","text":"struct CartesianPoint{T} <: AbstractCoordinatePoint{T, Cartesian}\n\nDescribes a three-dimensional point in Cartesian coordinates.\n\nFields\n\nx: x-coordinate (in m).\ny: y-coordinate (in m).\nz: z-coordinate (in m).\n\nSee also CylindricalPoint.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","text":"struct CartesianVector{T} <: AbstractCoordinateVector{T, Cartesian}\n\nDescribes a three-dimensional vector in Cartesian coordinates.\n\nFields\n\nx: x-coordinate (in m).\ny: y-coordinate (in m).\nz: z-coordinate (in m).\n\nSee also CylindricalVector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Cone","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Cone","text":"struct Cone{T,CO,TR,TP} <: AbstractVolumePrimitive{T, CO}\n\nVolume primitive describing a Cone with its top and bottom circular base being aligned with the xy plane (before possible rotations).\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nTR: Type of the radius r.\nTR == T: Cylinder (constant radius r at all z).\nTR == Tuple{T, T}: Tube (inner radius at r[1], outer radius at r[2]).\nTR == Tuple{Tuple{T}, Tuple{T}}: Varying Cylinder (full cylinder with radius changing linearly in z from r[1] at the bottom to r[2] at the top).\nTR == Tuple{Tuple{T, T}, Tuple{T, T}}: Varying Tube (inner radius changes linearly in z from r[1][1] at the bottom to r[1][2] at the top, outer radius changes linearly in z from r[2][1] at the bottom to r[1][2] at the top).\nTR == Tuple{Nothing, Tuple{T, T}}: Cone (Tip at the bottom, top is a circular base with inner radius r[2][1] and outer radius r[2][2]).\nTR == Tuple{Tuple{T, T}, Nothing}: Cone (Tip at the top, bottom is a circular base with inner radius r[1][1] and outer radius r[1][2]).\nTP: Type of the angular range φ.\nTP == Nothing: Full 2π Cone.\nTP == Tuple{T, T}: Partial Cone ranging from φ[1] to φ[2].\n\nFields\n\nr::TR: Definition of the radius of the Cone (in m).\nφ::TP: Range in polar angle φ over which the Cone extends (in radians).\nhZ::T: Half of the height of the Cone (in m).\norigin::CartesianPoint{T}: The position of the center of the Cone at the middle height.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Cone around its origin.\n\nDefinition in Configuration File\n\nA Cone is defined in the configuration file as part of the geometry field  of an object through the field cone (or tube).\n\nExample definitions of a cylinder looks like this:\n\ntube:\n  r:\n    from: 1.0\n    to: 2.0  # => r = (1.0, 2.0)\n  h: 2.0     # => hZ = 1.0\n  origin:\n    z: 1.0   # => origin = [0.0, 0.0, 1.0]\n\nThis is a hollow cylinder with inner radius 1 at outer radius 2 with a height of 2 and extending over full 2π (no phi given), translated 1 along the z axis.\n\nIf the radius is not constant over z, the r entries are divided into bottom and top, where bottom describes the inner and outer  radius at the bottom circular base and top describes the inner and outer radius at the top circular base (before rotations)\n\ncone:\n  r:\n    bottom:\n      from: 1.0\n      to: 2.0\n    top:\n      from: 1.0\n      to: 4.0     # => r = ((1.0, 2.0), (1.0, 4.0))\n  phi:\n    from: 0.0°\n    to: 180.0°    # => φ = (0, π)\n  h: 2.0          # => hZ = 1.0\n\nThis is half a Cone (φ goes from 0 to 180°, i.e. only positive y are allowed) with a height of 2, constant inner radius of 1 and an outer radius which increases  from 2 at the bottom to 4 at the top circular base.\n\nnote: Note\nThe names tube and cone in the configuration files are interchangeable.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","text":"struct ConeMantle{T,TR,TP,D} <: AbstractCurvedSurfacePrimitive{T}\n\nSurface primitive describing the mantle of a Cone.\n\nParametric types\n\nT: Precision type.\nTR: Type of the radius r.\nTR == T: CylinderMantle (constant radius r at all z).\nTR == Tuple{T, T}: VaryingCylinderMantle (inner radius at r[1], outer radius at r[2]).\nTP: Type of the angular range φ.\nTP == Nothing: Full 2π Cone.\nTP == Tuple{T, T}: Partial Cone ranging from φ[1] to φ[2].\nD: Direction in which the normal vector points (:inwards or :outwards).\n\nFields\n\nr::TR: Definition of the radius of the ConeMantle (in m).\nφ::TP: Range in polar angle φ over which the ConeMantle extends (in radians).\nhZ::T: Half of the height of the ConeMantle (in m).\norigin::CartesianPoint{T}: Origin of the Cone which has this ConeMantle as surface.\nrotation::SMatrix{3,3,T,9}: Rotation matrix of the Cone which has this ConeMantle as surface.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","text":"struct CylindricalPoint{T} <: AbstractCoordinatePoint{T, Cylindrical}\n\nDescribes a three-dimensional point in cylindrical coordinates. \n\nFields\n\nr: Radius (in m).\nφ: Polar angle (in rad).\nz: z-coordinate (in m).\n\nnote: Note\nφ == 0 corresponds to the x-axis in the Cartesian coordinate system.\n\nSee also CartesianPoint.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","text":"struct CylindricalVector{T} <: AbstractCoordinateVector{T, Cylindrical}\n\nDescribes a three-dimensional vector in cylindrical coordinates. \n\nFields\n\nr: Radius (in m).\nφ: Polar angle (in rad).\nz: z-coordinate (in m).\n\nnote: Note\nφ == 0 corresponds to the x-axis in the Cartesian coordinate system.\n\nSee also CartesianVector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid","text":"struct Ellipsoid{T,CO,TR,TP,TT} <: AbstractVolumePrimitive{T, CO}\n\nVolume primitive describing an Ellipsoid.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nTR: Type of the radius r.\nTR == T: Sphere (constant radius r along all axes).\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\n\nFields\n\nr::TR: Definition of the radius of the Ellipsoid (in m).\nφ::TP: Range in azimuthial angle φ of the Ellipsoid.\nθ::TT: Range in polar angle θ of the Ellipsoid.\norigin::CartesianPoint{T}: The position of the center of the Ellipsoid.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Ellipsoid around its origin.\n\nDefinition in Configuration File\n\nSo far, the only Ellipsoid implemented so far is a FullSphere. A FullSphere is defined in the configuration file as part of the geometry field  of an object through the field sphere.\n\nExample definitions of a FullSphere looks like this:\n\nsphere:\n  r: 2\n\nThis is a full sphere with radius 2.\n\nTo define a sphere with inner cut-out, use CSGDifference:\n\ndifference:\n  - sphere:\n      r: 2\n  - sphere:\n      r: 1\n\nThis is a sphere with inner radius 1 and outer radius 2.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle","text":"struct EllipsoidMantle{T,TR,TP,TT,D} <: AbstractCurvedSurfacePrimitive{T}\n\nSurface primitive describing the surface of an Ellipsoid.\n\nParametric types\n\nT: Precision type.\nTR: Type of the radius r.\nTR == T: SphereMantle (constant radius r along all axes).\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\nD: Direction in which the normal vector points (:inwards or :outwards).\n\nFields\n\nr::TR: Definition of the radius of the EllipsoidMantle (in m).\nφ::TP: Range in azimuthial angle φ of the EllipsoidMantle.\nθ::TT: Range in polar angle θ of the EllipsoidMantle.\norigin::CartesianPoint{T}: Origin of the Ellipsoid which has this EllipsoidMantle as surface.\nrotation::SMatrix{3,3,T,9}: Rotation matrix of the Ellipsoid which has this EllipsoidMantle as surface.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","text":"struct EllipticalSurface{T,TR,TP} <: AbstractPlanarSurfacePrimitive{T}\n\nSurface primitive describing circular bases, e.g. the top or bottom base of a Cone.\n\nParametric types\n\nT: Precision type.\nTR: Type of the radius r.\nTR == T: Full Circle (constant radius r, no cut-out).\nTR == Tuple{T, T}: Circular Annulus (inner radius at r[1], outer radius at r[2]).\nTP: Type of the angular range φ.\nTP == Nothing: Full 2π Cone.\nTP == Tuple{T, T}: Partial Cone ranging from φ[1] to φ[2].\n\nFields\n\nr::TR: Definition of the radius of the EllipticalSurface (in m).\nφ::TP: Range in polar angle φ over which the EllipticalSurface extends (in radians).\norigin::CartesianPoint{T}: The position of the center of the EllipticalSurface.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the EllipticalSurface around its origin.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Plane","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Plane","text":"struct Plane{T} <: AbstractPlanarSurfacePrimitive{T}\n\nSurface primitive describing a two-dimensional flat plane in three-dimensional space.\n\nFields\n\norigin::CartesianPoint{T}: Point in the Plane.\nnormal::CartesianVector{T}: Normal vector of the Plane, normalized to length 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Polygon","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Polygon","text":"struct Polygon{N,T} <: AbstractPlanarSurfacePrimitive{T}\n\nSurface primitive describing a planar polygon, e.g. the base of a RegularPrism.\n\nParametric types\n\nT: Precision type.\nN: Number of vertices of the Polygon.\n\nFields\n\npoints::SVector{N, CartesianPoint{T}}: Vertices of the polygon in the order with which they are connected.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism","text":"struct RegularPrism{T,CO,N,TR} <: AbstractVolumePrimitive{T, CO}\n\nVolume primitive describing a Prism with base plates are regular polygons which are parallel to the xy plane. If the regular polygon base plate is projected to  the xy plane, one of the vertices lays on the x axis.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nN: Number of vertices of the regular polygon that defines the base of the prism.\nTR: Type of r.\nTR == T: Regular polygon base (all vertices have the same distance to the center).\n\nFields\n\nr::TR: Distance of the vertices to the center of the regular polygon base (in m).\nhZ::T: Half of the width in z dimension (in m).\norigin::CartesianPoint{T}: The position of the center of the RegularPrism.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the RegularPrism around its origin.\n\nDefinition in Configuration File\n\nSo far, only HexagonalPrism can be defined in the configuration files. A HexagonalPrism is defined in the configuration file as part of the geometry field  of an object through the field HexagonalPrism.\n\nAn example definition of a HexagonalPrism looks like this:\n\nHexagonalPrism:\n  r: 1.0 # => r = 1.0\n  h: 2.0 # => hZ = 1.0\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Torus","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Torus","text":"struct Torus{T,CO,TR,TP,TT} <: AbstractVolumePrimitive{T,CO}\n\nVolume primitive describing a Torus. It is defined as all points that are within a given radius to a circle, parallel to the xy plane, with constant radius around a given origin.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nTR: Type of r_tube.\nTR == T: Full tube without cutout (constant radius r_tube).\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\n\nFields\n\nr_torus::T: Distance of the center of the Torus to the center of the tube (in m).\nr_tube::TR: Radius of the tube of the Torus (in m).\nφ::TP: Range in azimuthial angle φ of the Torus.\nθ::TT: Range in polar angle θ of the Torus.\norigin::CartesianPoint{T}: The position of the center of the Torus.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Torus around its origin.\n\nDefinition in Configuration File\n\nSo far, the only Torus implemented so far is a FullTorus. A FullTorus is defined in the configuration file as part of the geometry field  of an object through the field torus.\n\nExample definitions of a FullTorus looks like this:\n\ntorus:\n  r_torus: 10.0   # => r_torus = 10.0\n  r_tube: 2       # => r_tube = 2.0\n  phi: \n      from: 0.0°\n      to: 360.0°  # => φ = nothing\n  theta: \n      from: 0.0°\n      to: 360.0°  # => θ = nothing\n\nThe fields phi and theta do not need to defined if they are full 2π.\n\nTo define a torus with inner cut-out, use CSGDifference:\n\ndifference:\n  - torus:\n      r_torus: 10.0   # => r_torus = 10.0\n      r_tube: 2       # => r_tube = 2.0\n  - torus:\n      r_torus: 10.0   # => r_torus = 10.0\n      r_tube: 1       # => r_tube = 1.0\n\nThis is a torus with r_tube having an inner radius of 1 and an outer radius of 2.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle","text":"struct TorusMantle{T,TP,TT,D} <: AbstractCurvedSurfacePrimitive{T}\n\nSurface primitive describing the mantle of a Torus.\n\nParametric types\n\nT: Precision type.\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\nD: Direction in which the normal vector points (:inwards or :outwards).\n\nFields\n\nr_torus::T: Distance of the center of the TorusMantle to the center of the tube (in m).\nr_tube::T: Radius of the tube of the TorusMantle (in m).\nφ::TP: Range in azimuthial angle φ of the TorusMantle.\nθ::TT: Range in polar angle θ of the TorusMantle.\norigin::CartesianPoint{T}: The position of the center of the TorusMantle.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the TorusMantle around its origin.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.extreme_points","text":"extreme_points(es::AbstractPrimitive{T}) where {T}\n\nGeneric fallback of extreme_points for any primitive.  Returns 6 CartesianPoints in both directions of each cartesian axes (x, y and z) around the origin of the primitive with distance determined by extremum(es), which returns the maximum distance of an primitive to its origin.\n\nArguments\n\nes::AbstractPrimitive{T}: Any primitive, e.g. a Box.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP, D} where {TP, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::ConeMantle{T,Tuple{T,T}}, l::Line{T}) where {T}\n\nCalculates the intersections of a Line with a ConeMantle.\n\nArguments\n\ncm::ConeMantle{T,Tuple{T,T}}: The ConeMantle.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates. If the line crosses the mantle only once, two points will be returned. The two points will be the same point (the intersection). If the line lies inside the mantle and is parallel to it. The same point will be returned which is the origin of the line. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(em::EllipsoidMantle{T}, l::Line{T}) where {T}\n\nCalculates the intersections of a Line with a EllipsoidMantle.\n\nArguments\n\ncm::EllipsoidMantle{T}: The EllipsoidMantle.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.Plane{T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(p::Plane{T}, line::Line{T}) where {T}\n\nCalculates the intersections of a Line with a Plane.\n\nArguments\n\ncm::Plane{T}: The Plane.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return one Point as a Tuple. If the line is parallel to the plane, the point will have NaN's/Inf's as values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP, TT, D} where {TP, TT, D}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(tm::TorusMantle{T}, l::Line{T}) where {T}\n\nCalculates the intersections of a Line with a TorusMantle.\n\nArguments\n\ncm::TorusMantle{T}: The TorusMantle.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return 4 CartesianPoint's. If the line just touches the mantle, the points will be the same.  If the line does not touch the mantle at all, the points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/electric_field/#Electric-Field","page":"Electric Field","title":"Electric Field","text":"","category":"section"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The electric field is calculated from the electric potential for each grid point (ijk) when calling calculate_electric_field!(sim). The field vector components on each grid point are the means of the electric field in each direction calculated as finite differences.","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"On a Cartesian grid, this results in:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"vecE^ijk = left( mathcalE_x^ijk mathcalE_y^ijk mathcalE_z^ijk right)^mathsfThspace10pt","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"where","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"beginaligned\n\tmathcalE_x^ijk = dfrac12left( dfracPhi_i+1jk-Phi_i+1jkx_i+1 - x_i + dfracPhi_ijk-Phi_i-1jkx_i - x_i-1 right)hspace10pt\n\tmathcalE_y^ijk = dfrac12left( dfracPhi_ij+1k-Phi_ijky_j+1 - y_j + dfracPhi_ijk-Phi_ij-1ky_j - y_j-1 right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"On a cylindrical grid, the calculation is:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"vecE^ijk = left( mathcalE_r^ijk mathcalE_varphi^ijk mathcalE_z^ijk right)^mathsfThspace10pt","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"where","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"beginaligned\n\tmathcalE_r^ijk = dfrac12left(dfracPhi_i+1jk-Phi_ijkr_i+1 - r_i + dfracPhi_ijk-Phi_i-1jkr_i - r_i-1right)hspace10pt\n\tmathcalE_varphi^ijk = dfrac12 r_ileft(dfracPhi_ij+1k-Phi_ijkvarphi_j+1 - varphi_j + dfracPhi_ijk-Phi_ij-1kvarphi_j - varphi_j-1right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"This discrete electric field is interpolated (via Interpolations.jl)  during the drift in order to get the electric field at the current position of the charge carrier.","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The calculated electric field is stored as a field in the Simulation object, i.e. sim.electric_field, consisting of the actual field vectors for each grid point stored in sim.electric_field.data and the corresponding grid in sim.electric_field.grid. ","category":"page"},{"location":"man/electric_field/#Visualization","page":"Electric Field","title":"Visualization","text":"","category":"section"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The electric field can be plotted using the Plots.jl package. The electric field strength is plotted using plot(sim.electric_field), whereas the electric field lines can be plotted on top of that using  plot_electric_fieldlines!(sim).","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"Minimum working example:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"using SolidStateDetectors\nusing Plots\nsim = Simulation(SSD_examples[:InvertedCoax])\ncalculate_electric_potential!(sim)\ncalculate_electric_field!(sim)\nplot(sim.electric_field, full_det = true)\nplot_electric_fieldlines!(sim, full_det = true)","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#SolidStateDetectors.jl","page":"Home","title":"SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SolidStateDetectors.jl is a Julia package for fast 2D and 3D simulation of Solid State Detectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/installation.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/config_files.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/csg.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/Grids.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_potential.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/weighting_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_field.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/charge_drift.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/IO.md\"]","category":"page"},{"location":"#Citing-SolidStateDetectors.jl","page":"Home","title":"Citing SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using SolidStateDetectors.jl for research, teaching or similar, please cite the paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Abt:2021SSD,\r\n  author        = {Abt, I. and Fischer, F. and Hagemann, F. and Hauertmann, L. and Schulz, O. and Schuster, M. and Zsigmond, A. J.},\r\n  title         = {Simulation of semiconductor detectors in 3D with SolidStateDetectors.jl},\r\n  year          = {2021},\r\n  month         = {8},\r\n  journal       = {Journal of Instrumentation},\r\n  publisher     = {{IOP} Publishing},\r\n  volume        = {16},\r\n  number        = {08},\r\n  pages         = {P08007},\r\n  doi           = {10.1088/1748-0221/16/08/p08007},\r\n  url           = {https://doi.org/10.1088/1748-0221/16/08/p08007}\r\n}","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Example-1:-Inverted-Coax-Detector","page":"Tutorial","title":"Example 1: Inverted Coax Detector","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\n\nT = Float32\nsim = Simulation{T}(SSD_examples[:InvertedCoax])\n\nplot(sim.detector, size = (700, 700))\nsavefig(\"tutorial_det.pdf\") # hide\nsavefig(\"tutorial_det.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_det)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"apply_initial_state!(sim, ElectricPotential) # optional\nplot(\n    plot(sim.electric_potential), # initial electric potential (boundary conditions)\n    plot(sim.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(sim.q_eff_imp), # charge density distribution\n    plot(sim.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_initial_condition.pdf\") # hide\nsavefig(\"tutorial_initial_condition.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_initial_condition)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, calculate the electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_potential!( sim,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.01])\n\nplot(\n    plot(sim.electric_potential, φ = 20), # initial electric potential (boundary conditions)\n    plot(sim.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(sim.q_eff_imp), # charge density distribution\n    plot(sim.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_calculated_potential.pdf\") # hide\nsavefig(\"tutorial_calculated_potential.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_calculated_potential)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is_depleted(sim.point_types)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"get_active_volume(sim.point_types) # approximation (sum of the volume of cells marked as depleted)","category":"page"},{"location":"tutorial/#Partially-depleted-detectors","page":"Tutorial","title":"Partially depleted detectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sim_undep = deepcopy(sim)\nsim_undep.detector = SolidStateDetector(sim_undep.detector, contact_id = 2, contact_potential = 500); # V  <-- Bias Voltage of Mantle\n\ncalculate_electric_potential!( sim_undep,\n                               depletion_handling = true,\n                               convergence_limit = 1e-6,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.01],\n                               verbose = false)\n\n\nplot(\n    plot(sim_undep.electric_potential),\n    plot(sim_undep.point_types),\n    layout = (1, 2), size = (800, 700)\n)\nsavefig(\"tutorial_calculated_potential_undep.pdf\") # hide\nsavefig(\"tutorial_calculated_potential_undep.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_calculated_potential_undep)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"is_depleted(sim_undep.point_types)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare both volumes:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Depleted:   \", get_active_volume(sim.point_types))\nprintln(\"Undepleted: \", get_active_volume(sim_undep.point_types));\nnothing #hide","category":"page"},{"location":"tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Calculate the electric field of the fully depleted detector, given the already calculated electric potential:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_electric_field!(sim, n_points_in_φ = 72)\n\nplot(sim.electric_field, full_det = true, φ = 0.0, size = (700, 700))\nplot_electric_fieldlines!(sim, full_det = true, φ = 0.0)\nsavefig(\"tutorial_electric_field.pdf\") # hide\nsavefig(\"tutorial_electric_field.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_electric_field)","category":"page"},{"location":"tutorial/#Drift-field-calculation","page":"Tutorial","title":"Drift field calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any drift field model can be used for the calculation of the electric field. If no model is explicitely given, the ElectricFieldChargeDriftModel is used. Other configurations are saved in their configuration files and can be found under:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<package_directory>/examples/example_config_files/ADLChargeDriftModel/<config_filename>.yaml.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Set the charge drift model of the simulation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"charge_drift_model = ADLChargeDriftModel()\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And apply the charge drift model to the electric field:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate_drift_fields!(sim)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, let's create an \"random\" multi-site event:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),\n                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),\n                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]\nenergy_depos = T[1460, 609, 1000] * u\"keV\" # are needed later in the signal generation\n\nevt = Event(starting_positions, energy_depos);\n\ntime_step = 5u\"ns\"\ndrift_charges!(evt, sim, Δt = time_step)\n\nplot(sim.detector, size = (700, 700))\nplot!(evt.drift_paths)\nsavefig(\"tutorial_drift_paths.pdf\") # hide\nsavefig(\"tutorial_drift_paths.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_drift_paths)","category":"page"},{"location":"tutorial/#Weighting-potential-calculation","page":"Tutorial","title":"Weighting potential calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"for contact in sim.detector.contacts\n    calculate_weighting_potential!(sim, contact.id, refinement_limits = [0.2, 0.1, 0.05, 0.01], n_points_in_φ = 2, verbose = false)\nend\n\nplot(\n    plot(sim.weighting_potentials[1]),\n    plot(sim.weighting_potentials[2]),\n    size = (900, 700)\n)\nsavefig(\"tutorial_weighting_potentials.pdf\") # hide\nsavefig(\"tutorial_weighting_potentials.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_weighting_potentials)","category":"page"},{"location":"tutorial/#Detector-waveform-generation","page":"Tutorial","title":"Detector waveform generation","text":"","category":"section"},{"location":"tutorial/#Single-event-simulation","page":"Tutorial","title":"Single-event simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"simulate!(evt, sim) # drift_charges + signal generation of all channels\n\np_pc_signal = plot( evt.waveforms[1], lw = 1.5, xlims = (0, 1100), xlabel = \"Time / ns\",\n                    legend = false, tickfontsize = 12, ylabel = \"Energy / eV\", guidefontsize = 14)\nsavefig(\"tutorial_waveforms.pdf\") # hide\nsavefig(\"tutorial_waveforms.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: tutorial_waveforms)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/electric_potential/#Electric-Potential","page":"Electric Potential","title":"Electric Potential","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The electric potential is given by Gauss' law in matter","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"nabla left( epsilon_r(vecr) nabla Phi(vecr)right) = - dfracrho(vecr)epsilon_0","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"where Phi is the electric potential, rho is the charge density, epsilon_r is the dielectric distribution and epsilon_0 is the dielectric constant of the vacuum.","category":"page"},{"location":"man/electric_potential/#Simulation-Algorithm","page":"Electric Potential","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The electric potential is calculated through successive over relaxation when calling calculate_electric_potential!(sim). The equation is numerically solved on a three-dimensional adaptive red/black grid. The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical. To use multiple threads for the simulation, the environment variable JULIA_NUM_THREADS must be set before Julia is started. In case of bash this is done through","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"At the beginning of the simulation, each grid point, (ijk) is assigned its dielectric constant, epsilon_r(vecr_ijk), as well as its effective charge, Q_texteff = rho(vecr_ijk) cdot V_ijk epsilon_0, where V_ijk is the volume assigned to the grid point (ijk).","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"These quantities are stored in the fields sim.q_eff_imp and sim.ϵ_r and can be plotted using","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors\r\nusing Plots \r\nsim = Simulation(SSD_examples[:InvertedCoax])\r\napply_initial_state!(sim, ElectricPotential)\r\nplot(\r\n  plot(sim.q_eff_imp),\r\n  plot(sim.ϵ_r)\r\n)","category":"page"},{"location":"man/electric_potential/#Impurity-Densities","page":"Electric Potential","title":"Impurity Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"One contribution to the charge density rho(vecr) is the impurity density of the semiconductor of a detector. Some simple impurity density profiles are already implemented in SolidStateDetectors.jl and can be easily accessed in the configuration files. Note that all impurity densities are given in units of atoms / particles per volume.","category":"page"},{"location":"man/electric_potential/#Constant-Impurity-Density","page":"Electric Potential","title":"Constant Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"A constant impurity density throughout the detector volume can be modeled with ConstantImpurityDensity. In the configuration files, constant impurity densities are defined with the value of the constant impurity density, i.e.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: constant\r\n  value: 1e10cm^-3 # => 10¹⁹ m⁻³","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"If no units are given, value is interpreted in units of units.length^-3. They are converted is SI units (m^(-3)) internally.","category":"page"},{"location":"man/electric_potential/#Linear-Impurity-Density","page":"Electric Potential","title":"Linear Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"An impurity density with a linear gradient can be modeled with LinearImpurityDensity. In the configuration files, linear impurity densities are defined with an init (initial) value and gradient along each Cartesian direction (x, y and z), e.g.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: linear\r\n  z:\r\n    init: 1e10cm^-3\r\n    gradient: 1e10cm^-4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"or","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: linear\r\n  x:\r\n    init: 0\r\n    gradient: 1e10\r\n  z:\r\n    init: 0\r\n    gradient: 1e10","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"In the first example, the init value corresponds to the value at z = 0 whereas the gradient points towards positive z. In the second example, the impurity density is 0 at the origin of the coordinate system, whereas the gradient of the impurity density profile points in langle101rangle direction. If no units are given, init is parsed in units of units.length^-3 and gradient in units of units.length^-4.","category":"page"},{"location":"man/electric_potential/#Cylindrical-Impurity-Density","page":"Electric Potential","title":"Cylindrical Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"An impurity density with a radial gradient can be modeled with CylindricalImpurityDensity. In the configuration files, cylindrical impurity densities are defined with an init (initial) value and gradient along each cylindrical spatial direction (r and z), e.g.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: cylindrical\r\n  r:\r\n    init: 1e10cm^-3\r\n    gradient: 1e10cm^-4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Here, the impurity density at the origin is 10^10cm^-3 and it increases radially with the gradient 10^10cm^-4. If no units are given, init is parsed in units of units.length^-3 and gradient in units of units.length^-4.","category":"page"},{"location":"man/electric_potential/#Custom-Impurity-Density","page":"Electric Potential","title":"Custom Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The source code for the previously introduced impurity densities can be found here. More complex impurity density profiles can be defined by the user. Each custom impurity density is a new struct and subtype of SolidStateDetectors.AbstractImpurityDensity and needs a method SolidStateDetectors.get_impurity_density that returns the impurity density at a given point pt.","category":"page"},{"location":"man/electric_potential/#Example-1:-Radially-Oscillating-Impurity-Density","page":"Electric Potential","title":"Example 1: Radially Oscillating Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors: AbstractChargeDensity, CartesianVector, AbstractCoordinatePoint\r\nimport SolidStateDetectors: get_impurity_density\r\n\r\n# new struct for translated impurity densities\r\nstruct OscillatingImpurityDensity{T} <: AbstractImpurityDensity{T}\r\n    wavelength::T \r\n    amplitude::T\r\n    offset::T\r\nend\r\n\r\n# add get_charge_density for the newly defined charge density model\r\nfunction SolidStateDetectors.get_impurity_density(tcdm::TranslatedChargeDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}\r\n    cyl_pt = CylindricalPoint(pt) # convert point to a CylindricalPoint\r\n    return offset + amplitude * sin(2π * cyl_pt.r / wavelength)\r\nend","category":"page"},{"location":"man/electric_potential/#Example-2:-Translating-Existing-Impurity-Densities","page":"Electric Potential","title":"Example 2: Translating Existing Impurity Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors: AbstractImpurityDensity, CartesianVector, AbstractCoordinatePoint\r\nimport SolidStateDetectors: get_impurity_density\r\n\r\n# new struct for translated impurity densities\r\nstruct TranslatedImpurityDensity{T} <: AbstractImpurityDensity{T}\r\n    charge_density_model::AbstractImpurityDensity{T}\r\n    translate::CartesianVector{T}\r\nend\r\n\r\n# add get_impurity_density for the newly defined impurity density model\r\nfunction SolidStateDetectors.get_impurity_density(tcdm::TranslatedImpurityDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}\r\n    translated_pt::CartesianPoint{T} = CartesianPoint(pt) - tcdm.translate\r\n    return get_impurity_density(tcdm.charge_density_model, translated_pt)\r\nend","category":"page"},{"location":"man/electric_potential/#Charge-Densities","page":"Electric Potential","title":"Charge Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Another contribution to the charge density rho(vecr) can be charged surfaces or volumes that can be modeled using passive objects. The same profiles as for impurity densities are defined here that can be accessed similarly, i.e.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"charge_density:\r\n  name: constant\r\n  value: 1e-10 # => 10⁻¹⁰ C/m⁻³","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Note that, in contrast to impurity densities, charge densities are given in units of the elementary charge per volume.","category":"page"}]
}
