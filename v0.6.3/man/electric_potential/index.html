<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Electric Potential · SolidStateDetectors.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/man/electric_potential/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../config_files/">Configuration Files</a></li><li><a class="tocitem" href="../csg/">Constructive Solid Geometry (CSG)</a></li><li><a class="tocitem" href="../Grids/">Grids</a></li><li class="is-active"><a class="tocitem" href>Electric Potential</a><ul class="internal"><li><a class="tocitem" href="#Simulation-Algorithm"><span>Simulation Algorithm</span></a></li><li><a class="tocitem" href="#Impurity-Densities"><span>Impurity Densities</span></a></li><li><a class="tocitem" href="#Charge-Densities"><span>Charge Densities</span></a></li></ul></li><li><a class="tocitem" href="../weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../electric_field/">Electric Field</a></li><li><a class="tocitem" href="../charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../IO/">IO</a></li></ul></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Electric Potential</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Electric Potential</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/man/electric_potential.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Electric-Potential"><a class="docs-heading-anchor" href="#Electric-Potential">Electric Potential</a><a id="Electric-Potential-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-Potential" title="Permalink"></a></h1><p>The electric potential is given by Gauss&#39; law in matter</p><p class="math-container">\[\nabla \left( \epsilon_r(\vec{r}) \nabla \Phi(\vec{r})\right) = - \dfrac{\rho(\vec{r})}{\epsilon_0}\,,\]</p><p>where <span>$\Phi$</span> is the electric potential, <span>$\rho$</span> is the charge density, <span>$\epsilon_r$</span> is the dielectric distribution and <span>$\epsilon_0$</span> is the dielectric constant of the vacuum.</p><h2 id="Simulation-Algorithm"><a class="docs-heading-anchor" href="#Simulation-Algorithm">Simulation Algorithm</a><a id="Simulation-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Algorithm" title="Permalink"></a></h2><p>The electric potential is calculated through <a href="https://en.wikipedia.org/wiki/Successive_over-relaxation">successive over relaxation</a> when calling <code>calculate_electric_potential!(sim)</code>. The equation is numerically solved on a three-dimensional adaptive red/black grid. The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical. To use multiple threads for the simulation, the environment variable <code>JULIA_NUM_THREADS</code> must be set before Julia is started. In case of bash this is done through</p><pre><code class="language-bash hljs">export JULIA_NUM_THREADS=4</code></pre><p>At the beginning of the simulation, each grid point, <span>$(i,j,k)$</span> is assigned its dielectric constant, <span>$\epsilon_r(\vec{r}_{i,j,k})$</span>, as well as its effective charge, <span>$Q_\text{eff} = \rho(\vec{r}_{i,j,k}) \cdot V_{i,j,k} \,\epsilon_0$</span>, where <span>$V_{i,j,k}$</span> is the volume assigned to the grid point <span>$(i,j,k)$</span>.</p><p>These quantities are stored in the fields <code>sim.q_eff_imp</code> and <code>sim.ϵ_r</code> and can be plotted using</p><pre><code class="language-julia hljs">using SolidStateDetectors
using Plots 
sim = Simulation(SSD_examples[:InvertedCoax])
apply_initial_state!(sim, ElectricPotential)
plot(
  plot(sim.q_eff_imp),
  plot(sim.ϵ_r)
)</code></pre><h2 id="Impurity-Densities"><a class="docs-heading-anchor" href="#Impurity-Densities">Impurity Densities</a><a id="Impurity-Densities-1"></a><a class="docs-heading-anchor-permalink" href="#Impurity-Densities" title="Permalink"></a></h2><p>One contribution to the charge density <span>$\rho(\vec{r})$</span> is the impurity density of the semiconductor of a detector. Some simple impurity density profiles are already implemented in SolidStateDetectors.jl and can be easily accessed in the configuration files. Note that all impurity densities are given in units of <strong>atoms / particles</strong> per volume.</p><h3 id="Constant-Impurity-Density"><a class="docs-heading-anchor" href="#Constant-Impurity-Density">Constant Impurity Density</a><a id="Constant-Impurity-Density-1"></a><a class="docs-heading-anchor-permalink" href="#Constant-Impurity-Density" title="Permalink"></a></h3><p>A constant impurity density throughout the detector volume can be modeled with <code>ConstantImpurityDensity</code>. In the configuration files, <code>constant</code> impurity densities are defined with the <code>value</code> of the constant impurity density, i.e.</p><pre><code class="language-yaml hljs">impurity_density:
  name: constant
  value: 1e10cm^-3 # =&gt; 10¹⁹ m⁻³</code></pre><p>If no units are given, <code>value</code> is interpreted in units of <code>units.length</code><span>$^{-3}$</span>. They are converted is SI units (m<span>$^(-3)$</span>) internally.</p><h3 id="Linear-Impurity-Density"><a class="docs-heading-anchor" href="#Linear-Impurity-Density">Linear Impurity Density</a><a id="Linear-Impurity-Density-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Impurity-Density" title="Permalink"></a></h3><p>An impurity density with a linear gradient can be modeled with <code>LinearImpurityDensity</code>. In the configuration files, <code>linear</code> impurity densities are defined with an <code>init</code> (initial) value and <code>gradient</code> along each Cartesian direction (<code>x</code>, <code>y</code> and <code>z</code>), e.g.</p><pre><code class="language-yaml hljs">impurity_density:
  name: linear
  z:
    init: 1e10cm^-3
    gradient: 1e10cm^-4</code></pre><p>or</p><pre><code class="language-yaml hljs">impurity_density:
  name: linear
  x:
    init: 0
    gradient: 1e10
  z:
    init: 0
    gradient: 1e10</code></pre><p>In the first example, the <code>init</code> value corresponds to the value at <code>z = 0</code> whereas the gradient points towards positive <code>z</code>. In the second example, the impurity density is 0 at the origin of the coordinate system, whereas the gradient of the impurity density profile points in <span>$\langle101\rangle$</span> direction. If no units are given, <code>init</code> is parsed in units of <code>units.length</code><span>$^{-3}$</span> and <code>gradient</code> in units of <code>units.length</code><span>$^{-4}$</span>.</p><h3 id="Cylindrical-Impurity-Density"><a class="docs-heading-anchor" href="#Cylindrical-Impurity-Density">Cylindrical Impurity Density</a><a id="Cylindrical-Impurity-Density-1"></a><a class="docs-heading-anchor-permalink" href="#Cylindrical-Impurity-Density" title="Permalink"></a></h3><p>An impurity density with a radial gradient can be modeled with <code>CylindricalImpurityDensity</code>. In the configuration files, <code>cylindrical</code> impurity densities are defined with an <code>init</code> (initial) value and <code>gradient</code> along each cylindrical spatial direction (<code>r</code> and <code>z</code>), e.g.</p><pre><code class="language-yaml hljs">impurity_density:
  name: cylindrical
  r:
    init: 1e10cm^-3
    gradient: 1e10cm^-4</code></pre><p>Here, the impurity density at the origin is <span>$10^{10}$</span>cm<span>$^{-3}$</span> and it increases radially with the gradient <span>$10^{10}$</span>cm<span>$^{-4}$</span>. If no units are given, <code>init</code> is parsed in units of <code>units.length</code><span>$^{-3}$</span> and <code>gradient</code> in units of <code>units.length</code><span>$^{-4}$</span>.</p><h3 id="Custom-Impurity-Density"><a class="docs-heading-anchor" href="#Custom-Impurity-Density">Custom Impurity Density</a><a id="Custom-Impurity-Density-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Impurity-Density" title="Permalink"></a></h3><p>The source code for the previously introduced impurity densities can be found <a href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/src/ImpurityDensities">here</a>. More complex impurity density profiles can be defined by the user. Each custom impurity density is a new <code>struct</code> and subtype of <code>SolidStateDetectors.AbstractImpurityDensity</code> and needs a method <code>SolidStateDetectors.get_impurity_density</code> that returns the impurity density at a given point <code>pt</code>.</p><h4 id="Example-1:-Radially-Oscillating-Impurity-Density"><a class="docs-heading-anchor" href="#Example-1:-Radially-Oscillating-Impurity-Density">Example 1: Radially Oscillating Impurity Density</a><a id="Example-1:-Radially-Oscillating-Impurity-Density-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Radially-Oscillating-Impurity-Density" title="Permalink"></a></h4><pre><code class="language-julia hljs">using SolidStateDetectors: AbstractChargeDensity, CartesianVector, AbstractCoordinatePoint
import SolidStateDetectors: get_impurity_density

# new struct for translated impurity densities
struct OscillatingImpurityDensity{T} &lt;: AbstractImpurityDensity{T}
    wavelength::T 
    amplitude::T
    offset::T
end

# add get_charge_density for the newly defined charge density model
function SolidStateDetectors.get_impurity_density(tcdm::TranslatedChargeDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}
    cyl_pt = CylindricalPoint(pt) # convert point to a CylindricalPoint
    return offset + amplitude * sin(2π * cyl_pt.r / wavelength)
end</code></pre><h4 id="Example-2:-Translating-Existing-Impurity-Densities"><a class="docs-heading-anchor" href="#Example-2:-Translating-Existing-Impurity-Densities">Example 2: Translating Existing Impurity Densities</a><a id="Example-2:-Translating-Existing-Impurity-Densities-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Translating-Existing-Impurity-Densities" title="Permalink"></a></h4><pre><code class="language-julia hljs">using SolidStateDetectors: AbstractImpurityDensity, CartesianVector, AbstractCoordinatePoint
import SolidStateDetectors: get_impurity_density

# new struct for translated impurity densities
struct TranslatedImpurityDensity{T} &lt;: AbstractImpurityDensity{T}
    charge_density_model::AbstractImpurityDensity{T}
    translate::CartesianVector{T}
end

# add get_impurity_density for the newly defined impurity density model
function SolidStateDetectors.get_impurity_density(tcdm::TranslatedImpurityDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}
    translated_pt::CartesianPoint{T} = CartesianPoint(pt) - tcdm.translate
    return get_impurity_density(tcdm.charge_density_model, translated_pt)
end</code></pre><h2 id="Charge-Densities"><a class="docs-heading-anchor" href="#Charge-Densities">Charge Densities</a><a id="Charge-Densities-1"></a><a class="docs-heading-anchor-permalink" href="#Charge-Densities" title="Permalink"></a></h2><p>Another contribution to the charge density <span>$\rho(\vec{r})$</span> can be charged surfaces or volumes that can be modeled using passive objects. The same profiles as for impurity densities are defined here that can be accessed similarly, i.e.</p><pre><code class="language-yaml hljs">charge_density:
  name: constant
  value: 1e-10 # =&gt; 10⁻¹⁰ C/m⁻³</code></pre><p>Note that, in contrast to impurity densities, charge densities are given in units of the <strong>elementary charge</strong> per volume.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Grids/">« Grids</a><a class="docs-footer-nextpage" href="../weighting_potentials/">Weighting Potentials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Tuesday 14 September 2021 08:31">Tuesday 14 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
