<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Grids · SolidStateDetectors.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/man/Grids/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../config_files/">Configuration Files</a></li><li><a class="tocitem" href="../csg/">Constructive Solid Geometry (CSG)</a></li><li class="is-active"><a class="tocitem" href>Grids</a><ul class="internal"><li><a class="tocitem" href="#DiscreteAxis"><span>DiscreteAxis</span></a></li><li><a class="tocitem" href="#Grid-Initialization"><span>Grid Initialization</span></a></li><li><a class="tocitem" href="#Grid-Refinement"><span>Grid Refinement</span></a></li></ul></li><li><a class="tocitem" href="../electric_potential/">Electric Potential</a></li><li><a class="tocitem" href="../electric_field/">Electric Field</a></li><li><a class="tocitem" href="../charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../capacitances/">Capacitances</a></li><li><a class="tocitem" href="../IO/">IO</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Grids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/master/docs/src/man/Grids.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h1><p>The electric potential is calculated via <a href="https://en.wikipedia.org/wiki/Successive_over-relaxation">successive over relaxation</a> on a 3-dimensional grid. SolidStateDetectors.jl can calculate the electric potential on a Cartesian or a cylindrical grid:</p><ul><li><code>CartesianGrid</code>: 3 axes: <code>x</code>-, <code>y</code>- and <code>z</code>-axis.</li><li><code>CylindricalGrid</code>: 3 axes: <code>r</code>-, <code>φ</code>- and <code>z</code>-axis.</li></ul><p>The system to simulate, e.g. a cryostat with a detector inside, is called &quot;the world&quot;. This world is divided into a set of discrete points, called the <code>grid::Grid</code>. It is defined through three axes: <code>grid.axes</code>. Each of the three axes is divided into a discrete number of points (ticks): <span>$N_1, N_2, N_3$</span>.   The linear combinations of those points form the set of all <span>$N_\mathrm{gp} = N_1 \times N_2 \times N_3$</span> grid points.</p><p>Each axis is defined as a <a href="../../api/#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a>.</p><h2 id="DiscreteAxis"><a class="docs-heading-anchor" href="#DiscreteAxis">DiscreteAxis</a><a id="DiscreteAxis-1"></a><a class="docs-heading-anchor-permalink" href="#DiscreteAxis" title="Permalink"></a></h2><p>A <a href="../../api/#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a> defines the axis of a dimension of a grid, e.g. the <code>x</code>-axis of a <code>CartesianGrid</code>.  A <code>DiscreteAxis</code>, e.g. <code>ax::DiscreteAxis</code>, stores the boundary conditions (reflecting / periodic) at the endpoints of the axis as well as the discrete ticks, <code>ax.ticks</code>, of the axis in the interval <code>ax.interval</code>. The interval also specifies whether the endpoints of the interval are included in the ticks or not via <code>:closed</code> or <code>:open</code> in the type of the interval. The ticks do not need to be evenly spaced, allowing for an adaptive refinement of the grid in areas where the gradient of the electric potential is large.</p><h2 id="Grid-Initialization"><a class="docs-heading-anchor" href="#Grid-Initialization">Grid Initialization</a><a id="Grid-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Initialization" title="Permalink"></a></h2><p>The grid can be specified in the configuration files, see <a href="../config_files/#Grid">Grid</a>, of <code>sim::Simulation</code>.</p><p>There is a constructor method for grid: <a href="../../api/#SolidStateDetectors.Grid"><code>Grid(sim::Simulation)</code></a>.</p><p>In <a href="../../api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_electric_potential!</code></a>,<a href="../../api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_weighting_potential!</code></a> and <a href="../../api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>simulate!(sim::Simulation)</code></a> the calculation of the potentials start with an initial grid, which can be passed to these functions via the keyword <code>grid</code>. If no grid is passed, the grid is generated via <a href="../../api/#SolidStateDetectors.Grid"><code>Grid(::Simulation)</code></a>.</p><p>The two keywords <code>max_tick_distance</code> and <code>max_distance_ratio</code> can also be passed to the functions <a href="../../api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_electric_potential!</code></a>,<a href="../../api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_weighting_potential!</code></a> and <a href="../../api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>simulate!(sim::Simulation)</code></a> where they are internally forwarded.</p><h3 id="Initialization-of-the-Grid"><a class="docs-heading-anchor" href="#Initialization-of-the-Grid">Initialization of the Grid</a><a id="Initialization-of-the-Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-of-the-Grid" title="Permalink"></a></h3><ol><li>Important points of the objects of the simulation are obtained, e.g. the corners of a <code>Box</code>-primitive.  The coordinates of these points are used to generate the ticks of each axis of the grid.</li><li>For each axis, additional ticks are added based on the keyword <code>max_distance_ratio::Real = 5</code>:  If the ratio between the distances of an axis tick to its neighboring ticks is larger than <code>max_distance_ratio</code>  (or smaller than <code>inv(max_distance_ratio)</code>), additional ticks are inserted such that in the end  all those ratios are within the interval [<code>inv(max_distance_ratio)</code>, <code>max_distance_ratio</code>].</li><li>Finally, additional ticks are added for each axis if the distance between two ticks is larger  than a threshold distance specified via the keyword <code>max_tick_distance</code>.</li></ol><p><code>max_tick_distance</code> can either be a <code>Quantity</code>, e.g. <code>1u&quot;mm&quot;</code>, or a Tuple of Quantities, e.g. <code>(1u&quot;mm&quot;, 0.2u&quot;cm&quot;, 3u&quot;mm&quot;)</code>, to set it for each axis of the grid separately. If <code>max_tick_distance</code> is <code>missing</code>, one fourth of the axis length is used.</p><p>See also <a href="../../api/#SolidStateDetectors.Grid"><code>Grid(::Simulation)</code></a>.</p><h2 id="Grid-Refinement"><a class="docs-heading-anchor" href="#Grid-Refinement">Grid Refinement</a><a id="Grid-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Refinement" title="Permalink"></a></h2><p>After the potential has converged to equilibrium on the initial grid, the grid can be refined (multiple times).</p><p>The refinement can be tuned via the keyword <code>refinement_limits</code> in <a href="../../api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_electric_potential!</code></a>,<a href="../../api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_weighting_potential!</code></a> and <a href="../../api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>simulate!(sim::Simulation)</code></a>.</p><p>It defines the maximum (relative to applied bias voltage) allowed differences of the potential values of neighbored grid points in each dimension for each refinement. It can be specified in different ways, see e.g. <a href="../../api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_electric_potential!</code></a>.</p><p>One simple example would be <code>refinement_limits = [0.2, 0.1, 0.05]</code>. This would mean that the grid would be refined three times and the refinement limit would be the same for each dimension of the grid in each refinement. In the first refinement, the refinement limit would be 0.2. Thus, if the bias voltage of the detector in the simulation is <code>1000 V</code>, the maximum allowed potential difference between two grid points would be <code>200 V</code>. Let&#39;s say there is a potential difference of <code>500 V</code> between the two grid points at <code>(i,j,k)</code> and <code>(i,j+1,k)</code>. Then, two (<code>floor(Int, 500 / 200) = 2</code>) ticks are added in the second axis between the previous axis ticks, <code>grid.axes[2].ticks[j]</code> and <code>grid.axes[2].ticks[j+1]</code>, which results in <span>$2 \times N_1 \times N_3$</span> new additional grid points. The potential values at the added grid points are determined through linear interpolation. Then, the potential values of all grid points are updated (through the SOR) until convergence is reached again and the next refinement with <code>0.1</code> is executed.</p><p>Another keyword can be used to set a minimum allowed distance between to ticks: <code>min_tick_distance</code>, see e.g. <a href="../../api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_electric_potential!</code></a>, which prohibits the insertion of new ticks if the new resulting distances between the ticks would be below this limit.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is usually favourable to make more refinements with smaller differences in the limits. Thus, for example, <code>refinement_limits = [0.2, 0.1, 0.05, 0.03, 0.01]</code> is usually better than <code>refinement_limits = [0.2, 0.01]</code>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../csg/">« Constructive Solid Geometry (CSG)</a><a class="docs-footer-nextpage" href="../electric_potential/">Electric Potential »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Tuesday 8 March 2022 16:13">Tuesday 8 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
