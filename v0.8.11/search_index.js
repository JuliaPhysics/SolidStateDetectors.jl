var documenterSearchIndex = {"docs":
[{"location":"man/config_files/#Configuration-Files","page":"Configuration Files","title":"Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detector, its surroundings and symmetries can be specified in configuration files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"SolidStateDetectors.jl supports YAML and JSON as formats for the configuration files.","category":"page"},{"location":"man/config_files/#Example-Configuration-Files","page":"Configuration Files","title":"Example Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Several example configuration files can be found under","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"<package_directory>/examples/example_config_files/.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They are accessible through a dictionary, SSD_examples, defined in the package:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"using SolidStateDetectors\r\nkeys(SSD_examples) # dictionary holding the full path to the corresponding configuration files","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"They can be loaded via","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"path_to_config_file = SSD_examples[:InvertedCoax]\r\nsim = Simulation(path_to_config_file)","category":"page"},{"location":"man/config_files/#General-Structure","page":"Configuration Files","title":"General Structure","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The configuration files need a minimum of information in order to define the detector, its surroundings and symmetries.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"This is a minimum working example of a simple true coaxial detector with two contacts:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: Simple True Coax # optional\r\nunits:\r\n  length: mm\r\n  angle: deg\r\ngrid:\r\n  coordinates: cylindrical\r\n  axes:\r\n    r: 45\r\n    z:\r\n      from: -40\r\n      to: 40\r\nmedium: vacuum\r\ndetectors:\r\n- semiconductor:\r\n    material: HPGe\r\n    geometry:\r\n      tube:\r\n        r: \r\n          from: 0.5cm\r\n          to: 4cm\r\n        h: 6cm\r\n  contacts:\r\n  - material: HPGe\r\n    id: 1\r\n    potential: 6000\r\n    geometry:\r\n      tube:\r\n        r:\r\n          from: 5\r\n          to: 5\r\n        h: 60\r\n  - material: HPGe\r\n    id: 2\r\n    potential: 0\r\n    geometry:\r\n      tube:\r\n        r:\r\n          from: 40\r\n          to: 40\r\n        h: 60","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"It will be used to guide through the different parts of the configuration file.","category":"page"},{"location":"man/config_files/#Units","page":"Configuration Files","title":"Units","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Internally, SolidStateDetectors.jl performs its calculations in SI units. However, configuration files can be written in custom units.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The field units denotes the standard units with which values will be parsed. Standard units can be defined for length, angle, potential and temperature.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"In the example above, ","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"units:\r\n  length: mm\r\n  angle: deg","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"will lead to all length values to be parsed in units of mm, while all angle values will be parsed in units of deg (degree).","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The configuration files also allow for directly passing units to the values that will be parsed using uparse from the Unitful.jl package, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"units: \r\n  length: mm\r\n  # ....\r\ntube:\r\n  r: \r\n    from: 5\r\n    to: 40\r\n  h: 60","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"is equivalent to","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"tube:\r\n  r: \r\n    from: 5mm\r\n    to: 40mm\r\n  h: 60mm","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"or","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"tube:\r\n  r: \r\n    from: 0.5cm\r\n    to: 4cm\r\n  h: 6cm","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"In the last example, even if the length unit was set to mm, the values will be parsed in units of cm. Please note to not leave a white space between the value and the unit and to use the Unitful.jl notation.","category":"page"},{"location":"man/config_files/#Grid","page":"Configuration Files","title":"Grid","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The calculations are performed on a finite world. To define the world, SolidStateDetectors.jl requires the properties of the grid, which are the coordinate system type and the dimensions. These are defined in the grid section of the configuration file, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cartesian\r\n axes:\r\n   x: \r\n     from: -40\r\n     to: 40\r\n   y:\r\n     from: -40\r\n     to: 40\r\n   z:\r\n     from: -40\r\n     to: 40","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The coordinates of the grid can be:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"cartesian (with the axes x, y and z)\ncylindrical (with the axes r, phi and z).","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The axes field is used to define the dimensions of each axis and, optionally, the boundary handling. In the example above, the x, y and z axes range from -40 to 40 units.","category":"page"},{"location":"man/config_files/#Grid-boundary-handling","page":"Configuration Files","title":"Grid boundary handling","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Symmetries of the world can be used to reduce the calculation only to a fraction of the world. These can be passed as boundaries to the different axes.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For linear axes (x, y, z), the boundaries can be chosen infinite, periodic, reflecting, or fixed.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For radial axes (r), the boundaries can be chosen r0 for the left boundary and infinite, reflecting or fixed on the right boundary. If no boundaries are given, the default is r0 for the left boundary and infinite for the right boundary.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"For angular axes (phi), the boundaries can be chosen reflecting or periodic. If no boundaries are given, the default is periodic for both edges.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"All varphi-symmetric configurations can be calculated in 2D if phi ranges from 0 to 0 with periodic boundary handling, i.e.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0\r\n     to: 0\r\n     boundaries: periodic\r\n   z: #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"All varphi-periodic configurations can be calculated on the fraction of the full 2pi interval, i.e. for a 120°-periodic system","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0°\r\n     to: 120°\r\n     boundaries: periodic\r\n   z: #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Different boundary handling can be chosen for the left and right end of the interval, i.e. for a 60°-periodic system with mirror symmetry at 30°","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"grid:\r\n coordinates: cylindrical\r\n axes:\r\n   r: #...\r\n   phi:\r\n     from: 0°\r\n     to: 30°\r\n     boundaries:\r\n       left: periodic\r\n       right: reflecting\r\n   z: #...","category":"page"},{"location":"man/config_files/#Detector-Constituents","page":"Configuration Files","title":"Detector Constituents","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The detectors for the simulation are defined in an array detectors, where each entry corresponds to one detector. Each detector consists of exactly one semiconductor, a minimum of two contacts and, optionally, passives and virtual_drift_volumes.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"detectors:\r\n  - name: \"Detector 1\"\r\n    semiconductor: #...\r\n    contacts: \r\n      - # Contact 1\r\n      - # Contact 2 \r\n    passives: \r\n      - # Passive 1 (optional)\r\n    virtual_drift_volumes:\r\n      - # Virtual Drift Volume 1 (optional)\r\n  - name: \"Detector 2\"\r\n    semiconductor: #...\r\n    contacts: \r\n      - # Contact 1\r\n      - # Contact 2","category":"page"},{"location":"man/config_files/#Semiconductor","page":"Configuration Files","title":"Semiconductor","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"An example definition of the semiconductor looks like this:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"semiconductor:\r\n  material: HPGe\r\n  temperature: 78\r\n  impurity_density: # ...\r\n  charge_drift_model: # ...\r\n  geometry: # ...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of the semiconductor are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"material: the material of the semiconductor. This is important to know the electric properties of the semiconductor for the electric potential calculation. Possible choices are HPGe (high-purity germanium) and Si (silicon).\ntemperature (optional): the temperature of the semiconductor. If no temperature is given, the default is 78K for germanium and 293K for all other materials.\nimpurity_density (optional): the distribution of impurities in the semiconductor material. This has a strong impact on the electric potential calculation. If no impurity_density is given, the default is an impurity-free material (rho(vecr) = 0). Find a selection of implemented impurity density models and how to define an own model under Impurity Densities.\ncharge_drift_model (optional): a model to describe the drift of charge carriers in the semiconductor material. If no charge_drift_model is given, the default is ElectricFieldChargeDriftModel. Find a detailed description on how to define an own model under Custom Charge Drift Model.\ngeometry: the geometry of the semiconductor object. Find a detailed description on how to define geometries under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Contacts","page":"Configuration Files","title":"Contacts","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"An example definition of contacts looks like this:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"contacts:\r\n  - name: \"n+ contact\"\r\n    id: 1\r\n    potential: 5000V\r\n    material: HPGe # optional\r\n    geometry: # ....\r\n  - name: \"p+ contact\"\r\n    id: 2\r\n    potential: 0\r\n    material: HPGe #optional\r\n    geometry: # ....","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"where each entry of the contacts array defines one contact.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of a contact are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name (optional): the custom name for the contacts, relevant for plotting. \nid: a unique id of the contact that will unambiguously identify the contact, for example in the signal generation. All contacts should be given an integer id from 1 to N where N is the number of contacts.\npotential: the electric potential applied to the contact that is fixed throughout the whole contact geometry. This value can be parsed with units (5000V) or without (0 with the units defined in the units section).\nmaterial (optional): the material of the contact. This is important to know the electric properties of the contact for the electric potential calculation. If no material is given, the default is HPGe (high-purity germanium).\ngeometry: the geometry of the contact. Find a detailed description on how to define geometries under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Passives-and-Charged-Surfaces","page":"Configuration Files","title":"Passives and Charged Surfaces","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Passive objects and charged surfaces can be defined through entries of the passives array for each detector, e.g.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"passives:\r\n  - name: Passivated Surface\r\n    material: HPGe\r\n    charge_density: # ...\r\n    geometry: # ...\r\n  - name: Cryostat\r\n    id: 3\r\n    potential: 0\r\n    temperature: 293K\r\n    material: Al\r\n    geometry: # ...\r\n","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The different fields of a passive are:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name (optional): the name of the passive object. If no name is given, the default name is \"external part\".\nid (optional): a unique id of the contact that will unambiguously identify the passive object. If no id is given, the default is -1.\npotential (optional): the electric potential to which the passive object is fixed. This value can be parsed with units (5000V) or without (0 with the units defined in the units section). If no potential is given, the passive object will be treated as floating. \ntemperature (optional): the temperature of the passive object. This value can be parsed with units (293K) or without (78 with the units defined in the units section). If no temperature is given, the default is 293K.\nmaterial: the material of the passive object. This is important to know the electric properties of the passive object for the electric potential calculation.\ncharge_density (optional): model to describe charge density distributions within the passive object, e.g. charged surfaces. Find a detailed description on how to define charge densities under Charge Densities.\ngeometry: the geometry of the contact. Find a detailed description on how to define geometries in the section under Constructive Solid Geometry (CSG).","category":"page"},{"location":"man/config_files/#Surroundings","page":"Configuration Files","title":"Surroundings","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The medium of the world is passed as field medium, i.e.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: # ... # optional\r\nunits: #...\r\ngrid: #...\r\nmedium: vacuum\r\ndetectors: # ...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"If no medium is given, the default is vacuum. Implemented media are vacuum and LAr (liquid argon), but other media can be easily added to the material_properties dictionary in MaterialProperties.jl.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Passive objects, especially cryostats or holding structures can be defined in an array surroundings without being assigned to a specific detector. ","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"name: # ... # optional\r\nunits: #...\r\ngrid: #...\r\nmedium: vacuum\r\ndetectors:\r\n- semiconductor: # ...\r\n  contacts: \r\n    - # ...\r\n    - # ...\r\n  passives:\r\n    - # ...\r\n    - # ...\r\nsurroundings:\r\n  - #...\r\n  - #...","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"The definition of passive objects in the surroundings array is equal to that in the passives array of a detector.","category":"page"},{"location":"man/config_files/#Splitting-Configuration-Files","page":"Configuration Files","title":"Splitting Configuration Files","text":"","category":"section"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Configuration files for complex geometries can get quite long. SolidStateDetectors.jl allows for splitting configuration files into smaller ones and loading them using the include keyword. This feature supports YAML and JSON files.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"When including a separate file, the user has to add its file path in the main configuration file at the place it is supposed to be added. To identify the file, set the key of this entry to include. Here, the user can also give an array of file paths. The file paths can be relative to the path of the configuration file or absolute. When including nested files and using relative paths, please always refer to the last parent file.","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Including one file:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"include : \"file_to_be_included.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Including a list of files:","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"include: \r\n  - \"first_file_to_be_included.yaml\"\r\n  - \"second_file_to_be_included.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"Add files to an array in the main configuration file","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"detectors:\r\n  - include: \"first_file_in_array.yaml\"\r\n  - include: \"second_file_in_array.yaml\"\r\n  - include: \"thrid_file_in_array.yaml\"","category":"page"},{"location":"man/config_files/","page":"Configuration Files","title":"Configuration Files","text":"A fully working example can be seen in SSD_examples[:InvertedCoaxInCryostat]. Here, the channels, the geometry and other parts are split into separate configuration files.","category":"page"},{"location":"man/csg/#Constructive-Solid-Geometry-(CSG)","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"All objects are defined through Constructive Solid Geometry (CSG), where complex geometries can be constructed by combining simple volume primitives (e.g. Tube) through Boolean operators and transformed using Transformations. ","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"The primitives which can be used are shown under Volume Primitives together with how they can be specified in the configuration files.","category":"page"},{"location":"man/csg/#Volume-Primitives","page":"Constructive Solid Geometry (CSG)","title":"Volume Primitives","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"using SolidStateDetectors\nimport SolidStateDetectors.ConstructiveSolidGeometry as CSG\nusing Plots\nT = Float64;\nnothing #hide","category":"page"},{"location":"man/csg/#List-of-YAML-example-configuration-files-for-Primitives","page":"Constructive Solid Geometry (CSG)","title":"List of YAML example configuration files for Primitives","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Under SolidStateDetectors.jl/examples/example_primitive_files there are some examples how to define the different primitives via the YAML format:","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"path_to_example_primitives_config_files = joinpath(dirname(dirname(pathof(SolidStateDetectors))), \"examples\", \"example_primitive_files\")\nexample_primitives_config_filenames = readdir(path_to_example_primitives_config_files)\nfor fn in example_primitives_config_filenames\n    println(fn)\nend","category":"page"},{"location":"man/csg/#Box","page":"Constructive Solid Geometry (CSG)","title":"Box","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Box.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"box = CSG.Geometry(T, cfn)\nplot(box)","category":"page"},{"location":"man/csg/#Cone","page":"Constructive Solid Geometry (CSG)","title":"Cone","text":"","category":"section"},{"location":"man/csg/#Tube","page":"Constructive Solid Geometry (CSG)","title":"Tube","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone_tube.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/csg/#VaryingTube","page":"Constructive Solid Geometry (CSG)","title":"VaryingTube","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Cone.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cone = CSG.Geometry(T, cfn)\nplot(cone)","category":"page"},{"location":"man/csg/#Ellipsoid","page":"Constructive Solid Geometry (CSG)","title":"Ellipsoid","text":"","category":"section"},{"location":"man/csg/#Sphere","page":"Constructive Solid Geometry (CSG)","title":"Sphere","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Ellipsoid_full_sphere.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"ellipsoid = CSG.Geometry(T, cfn)\nplot(ellipsoid)","category":"page"},{"location":"man/csg/#Torus","page":"Constructive Solid Geometry (CSG)","title":"Torus","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"Torus.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"torus = CSG.Geometry(T, cfn)\nplot(torus, zlims = [-6,6], camera = (40, 55))","category":"page"},{"location":"man/csg/#Prism","page":"Constructive Solid Geometry (CSG)","title":"Prism","text":"","category":"section"},{"location":"man/csg/#Hexagonal-Prism","page":"Constructive Solid Geometry (CSG)","title":"Hexagonal Prism","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"cfn = joinpath(path_to_example_primitives_config_files, \"RegularPrism_hexagon.yaml\")\nprint(open(f -> read(f, String), cfn))","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Load the primitive from the configuration file via CSG.Geometry","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"prism = CSG.Geometry(T, cfn)\nplot(prism)","category":"page"},{"location":"man/csg/#Boolean-operators","page":"Constructive Solid Geometry (CSG)","title":"Boolean operators","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"The Boolean operators are union, difference and intersection:","category":"page"},{"location":"man/csg/#Union","page":"Constructive Solid Geometry (CSG)","title":"Union","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"A union of two objects A and B is defined as the set of points that are in at least one of either A or B. In the configuration files, it is defined using the union field, followed by an array of entries to construct the union, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"union: # A || B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"(Image: CSGUnion)","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If more than two geometries are passed, the union is constructed from all of them.","category":"page"},{"location":"man/csg/#Difference","page":"Constructive Solid Geometry (CSG)","title":"Difference","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"A difference of two objects A and B is defined as the set of points that are in A but not in B. Note that B is treated as open primitive. This means that points which are in A and on the surface of B will still be in the difference of A and B. In the configuration files, it is defined using the difference field, followed by an array of entries. The first entry of the array is the main geometry, from which all following geometry entries are subtracted, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"difference: # A && !B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.1","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"(Image: CSGDifference)","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Keep in mind that to discard the part of the surface of A which is on the surface of B, B should be chosen slightly bigger than A.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If more than two geometries are passed, all entries starting from the second will be subtracted from the first.","category":"page"},{"location":"man/csg/#Intersection","page":"Constructive Solid Geometry (CSG)","title":"Intersection","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"An intersection of two objects A and B is defined as the set of points that are both in A and in B. In the configuration files, it is defined using the intersection field, followed by an array of entries to construct the intersection, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"intersection: # A && B\n  - tube: # A\n      r: 2\n      h: 1\n  - tube: # B\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"(Image: CSGIntersection)","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If more than two geometries are passed, the intersection is constructed from all of them.","category":"page"},{"location":"man/csg/#Transformations","page":"Constructive Solid Geometry (CSG)","title":"Transformations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"All Volume Primitives are defined such that they are centered around the origin of the coordinate system. They can be rotated in their local coordinate system and translated to their final position in the global coordinate system.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"There are two possibilities two rotate and translate volume primitives. One is to define the rotation/translation inside the primitive definition. The other one is to define it for complete sets like detectors, unions, etc.","category":"page"},{"location":"man/csg/#Rotations","page":"Constructive Solid Geometry (CSG)","title":"Rotations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Rotations are defined in the configuration files by either a 3times3 rotation matrix or a set of angles with respective rotation axes are required.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If a tube is to be rotated 45° around the x axis, the rotation is parsed to the primitive as additional rotation field in the primitive definition.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    X: 45°","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"In this case, the rotation around the x axis by 45° is parsed in the format seen above: the name of the axis to be rotated around is given as (upper-case) letter, followed by the rotation angle. If no units are given to the rotation angle, it will be parsed with units.angle.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If the rotation is to be described as multiple subsequent rotations, it can be passed using an array of angles with respective axis description as field name, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    XZ: [45°, 30°]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"will first rotate the tube 45° around the x axis, followed by a 30° rotation around the z axis.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Alternatively, a full 3times3 matrix can be passed using the M field, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    M: [1, 0, 0, 0, 0, -1, 0, 1, 0]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"will transform the primitive using the rotation matrix","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"left beginarrayccc10000-1010endarrayright","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"which corresponds to X: 90°.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Alternative naming for the rotation field can be rotate.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"note: Note\nIf varphi is specified for a certain interval, the interval is internally converted into a rotation, R_varphi, of the primitive. This rotation is applied prior to the rotation specified in the rotation field, R.  Thus, internally, both rotations are calculated into the final rotation matrix of the primitive, R_f, via R_f = R cdot R_varphi. ","category":"page"},{"location":"man/csg/#Translations","page":"Constructive Solid Geometry (CSG)","title":"Translations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Translations are defined in the configuration files through a Cartesian vector.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If a tube is translated 1cm along the x axis, the translation is parsed to the primitive as additional origin field in the primitive definition.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  origin:\n    x: 1cm","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"The Cartesian vector can also be passed as a vector, i.e.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  origin: [1cm, 0, 0]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If no units are given, the translation is parsed in units of units.length.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Alternative naming for the origin field can be translate and translation.","category":"page"},{"location":"man/csg/#Combination-of-Transformations","page":"Constructive Solid Geometry (CSG)","title":"Combination of Transformations","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If both a rotation and translation are defined in a primitive definition, it is first rotated and then translated.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"tube:\n  r: 1\n  h: 1\n  rotation:\n    X: 45°\n  origin: \n    z: 1cm","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"would first rotate the tube by 45° around the x axis before translating it 1cm along the z axis.","category":"page"},{"location":"man/csg/#Transforming-Sets","page":"Constructive Solid Geometry (CSG)","title":"Transforming Sets","text":"","category":"section"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"If a union of two primitives should be transformed all together, the transformation can also be defined by nesting the union into a translate with respective information, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"translate: \n  z: 1\n  union:\n    - tube: \n        r: 1\n        h: 1\n    - box: \n        widths: [1,1,1]","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"Same applies for rotations or other sets, e.g.","category":"page"},{"location":"man/csg/","page":"Constructive Solid Geometry (CSG)","title":"Constructive Solid Geometry (CSG)","text":"rotate: \n  X: 45°\n  difference:\n    - tube: \n        r: 1\n        h: 1\n    - box: \n        widths: [1,1,1]","category":"page"},{"location":"man/IO/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"After simulating the potentials and fields of a detector setup, the results should be saved to a file to avoid recalculating them every time the user starts a program.","category":"page"},{"location":"man/IO/#Saving-output-with-JLD2","page":"IO","title":"Saving output with JLD2","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"One easy way to do this is using JLD2.jl and FileIO.jl.","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Simulation results can be saved to a JLD file using FileIO.save:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using SolidStateDetectors\r\nsim = Simulation(\"<config-file-name>\")\r\n# ...\r\n\r\nusing FileIO\r\nFileIO.save(\"<name-of-simulation-file>.jld\", Dict(\"Simulation\" => sim))","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"It can be read back in using FileIO.load:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using FileIO\r\nsim = FileIO.load(\"<name-of-simulation.file>.jld\", \"Simulation\")","category":"page"},{"location":"man/IO/#Saving-output-with-HDF5","page":"IO","title":"Saving output with HDF5","text":"","category":"section"},{"location":"man/IO/","page":"IO","title":"IO","text":"One more compact way of saving simulation results is based on converting the output to a NamedTuple and saving it to a HDF5 file. This requires the HDF5.jl package, as well as the (unregistered) service packages LegendDataTypes.jl and LegendHDF5IO.jl.","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Install the required packages once by running:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using Pkg\r\nPkg.add(url=\"https://github.com/legend-exp/LegendDataTypes.jl.git\")\r\nPkg.add(url=\"https://github.com/legend-exp/LegendHDF5IO.jl.git\")\r\nPkg.add(\"HDF5\")","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"Simulation output can be written to a HDF5 file using ssd_write:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using HDF5\r\nusing LegendHDF5IO\r\nusing SolidStateDetectors \r\n# ...\r\n\r\nssd_write(\"<name-of-simulation-file>.h5\", sim)","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"The data stored in the HDF5 file can be read using ssd_read:","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"using HDF5\r\nusing LegendHDF5IO\r\nusing SolidStateDetectors\r\nssd_read(\"<name-of-simulation-file>.h5\", Simulation)","category":"page"},{"location":"man/IO/","page":"IO","title":"IO","text":"note: Note\nAll HDF5 related packages must be loaded before loading SolidStateDetectors.jl","category":"page"},{"location":"man/capacitances/#Capacitances","page":"Capacitances","title":"Capacitances","text":"","category":"section"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"The mutual capacitance, c_ij, between two contacts i and j can be calculated via","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"calculate_mutual_capacitance(sim, (i, j))","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"The weighting potentials of the two contacts must have already been calculated as they are needed in the calculation:","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"c_ij = epsilon_0 int_World nabla Phi_i^w(vecr) ϵ_r(vecr) nabla Phi_j^w(vecr) dvecr","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"The function returns the elements of the Maxwell capacitance matrix, mathbfC, which fulfills","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"vecmathbfQ = mathbfC cdot vecmathbfV","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"The whole matrix can also be obtained via","category":"page"},{"location":"man/capacitances/","page":"Capacitances","title":"Capacitances","text":"calculate_capacitance_matrix(sim)","category":"page"},{"location":"man/charge_drift/#Charge-Drift","page":"Charge Drift","title":"Charge Drift","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Charged particles in vacuum move along the electric field lines under Coulomb's force, vecF = q vecE, where vecF corresponds to the force experienced by the particle, q is the charge of the particle and vecE is the electric field. Charged particles in vacuum would be continuously accelerated until approaching the speed of light (called ballistic transport). However, inside a material, scattering prevents this constant acceleration and leads to a constant drift velocity ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_d = mu E","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"where v_d is the drift velocity, mu the mobility and E the electric field strength.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The scattering with matter not only limits the absolute drift velocity, it might also deviate the trajectories from the electric field lines: e.g., in crystals, the principal axes orientation has an impact on the resulting drift trajectory. The influence of the scattering on the drift trajectories can be expressed by a 3x3 tensor, the so-called mobility tensor mu_ij, which transforms the electric field, E, into the drift velocity, v_i:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_i =  mu_ij cdot E_j","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The mobility varies for different materials and depends also on other parameters such as temperature, impurity density and the electric field strength, as explained later.","category":"page"},{"location":"man/charge_drift/#Charge-Drift-Models","page":"Charge Drift","title":"Charge Drift Models","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Electrons and holes have different mobilities, resulting in different drift velocities. There are several models for the mobility tensor of electrons and holes in certain materials. Right now, two models are implemented. The first one is a pseudo-drift model, the ElectricFieldChargeDriftModel, which just takes the electric field vectors as drift vectors, see section Electric Field Charge Drift Model. The second one, ADLChargeDriftModel, is a drift model for high purity germanium, see section ADL Charge Drift Model. However, the implementation of an own model is possible and explained in section Custom Charge Drift Model.","category":"page"},{"location":"man/charge_drift/#Electric-Field-Charge-Drift-Model","page":"Charge Drift","title":"Electric Field Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The ElectricFieldChargeDriftModel describes a system in which electrons and holes move along the electric field lines. In this case, the mobility is a scalar pm 1 m²/(Vs) (+ for holes, and - for electrons), and thus, the velocity field has the same (or opposite) direction as the electric field. Even though this model does not describe reality, it is useful in some cases to use the electric field vectors as velocity vectors.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In order to set the ElectricFieldChargeDriftModel for the simulation, the precision type of the calculation T (Float32 or Float64) has to be given as an argument. Note that T has to be of the same precision type of the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = ElectricFieldChargeDriftModel(T)\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If no charge drift model is specified for the semiconductor of the detector in the configuration files, the default is ElectricFieldChargeDriftModel.","category":"page"},{"location":"man/charge_drift/#ADL-Charge-Drift-Model","page":"Charge Drift","title":"ADL Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In high-purity germanium, the mobility cannot be expressed by a simple scalar quantity. Germanium has a cubic diamond lattice structure with langle100rangle, langle110rangle and langle111rangle as principal directions. Along these axes, the charge drift is parallel to the electric field. However, the longitudinal drift velocity, v_l, is not equally fast on the three axes. ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"On each axes, v_l can be described through the parametrization proposed by D.M. Caughey and R.E. Thomas, which was later expanded by L. Mihailescu et al.:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"v_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The parameters mu_0, E_0 and beta differ for electrons and holes, and mu_n is only relevant for electrons. These parameters were obtained by B. Bruyneel et al. by measuring the drift velocities of electrons and holes in the langle100rangle and langle111rangle directions in high purity germanium at a temperature of 78 K. These parameters are stored in a configuration file, \"drift_velocity_config.yaml\", located in <package_directory>/example/example_config_files/ADLChargeDriftModel. The configuration file is expressed as following:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"model: ADLChargeDriftModel\nphi110: -0.785398\nmaterial: HPGe\ndrift:\n  velocity:\n    model: Bruyneel2006\n    parameters:\n      e100:\n        mu0: 3.8609\n        beta: 0.805\n        E0: 51100\n        mun: -0.0171\n      e111:\n        mu0: 3.8536\n        beta: 0.641\n        E0: 53800\n        mun: 0.051\n      h100:\n        mu0: 6.1824\n        beta: 0.942\n        E0: 18500\n      h111:\n        mu0: 6.1215\n        beta: 0.662\n        E0: 18200","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"where the parameters are stored under the keys e100, e111, h100 and h111, in which e and h stand for electrons and holes, respectively, and 100 and 111, for the principal axes langle100rangle and langle111rangle.  By default, in SolidStateDetectors.jl the langle001rangle axis is aligned with the Z-axis of the coordinate system of the simulation. The crystal orientation can be set through the phi110 parameter, where the langle001rangle axis is still aligned with the Z-axis and the angle between the langle110rangle principal direction of the crystal and the X-axis is given by phi110. Alternatively, the crystal orientation can be set by passing a rotation matrix that describes the rotation from the global coordinate system to the crystal orientation system.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If the electric field is not aligned with any of the crystal axes, the charge drift velocity is not necessarily aligned with the electric field. In the ADLChargeDriftModel, two models are implemented to describe the charge drift of electrons and holes between the axes. Detailed information about the charge drift models is provided in the papers from L. Mihailescu et al.  for electrons and from B.Bruyneel et al. for holes. Find the detailed calculations and modifications from the publications as implemented in SolidStateDetectors.jl here.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"In order to perform the calculation of the drift velocities, a configuration file containing the parametrization values like the \"drift_velocity_config.yaml\" (with Bruyneel's data or modified values), has to be passed as an argument to the ADLChargeDriftModel function. The precision of the the calculation T (Float32 or Float64) has to be given as a keyword T. Note that T has to be of the same type as the chosen in the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_ADL_configuration_file>\", T=T)\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The ÀDLChargeDriftModel can also be specified already in the configuration file as field charge_drift_model of the semiconductor of a detector, e.g.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"detectors:\n  semiconductor:\n    # ...\n    charge_drift_model:\n      model: ADLChargeDriftModel\n      phi110: -0.785398 # in radians if no units are given\n      material: HPGe\n      drift: # ...","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"or","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"detectors:\n  semiconductor:\n    # ...\n    charge_drift_model:\n      model: ADLChargeDriftModel\n      crystal_orientation:\n        X: 45° # crystal axes correspond to the global xyz coordinate system, rotated 45° around the x axis\n      material: HPGe\n      drift: # ...","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The charge_drift_model needs:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"model: the name of the charge drift model, which in this case is ADLChargeDriftModel\nphi110 or crystal_orientation: the description of the orientation of the crystal with respect to the global coordinate system. When using phi110, the langle001rangle axis is aligned with the global z axis and phi110 describes the angle between the langle110rangle axis and the x axis in radians (counterclockwise, looking from the top). If the langle001rangle axis is not aligned with the z axis, a rotation matrix to transform the global coordinate system to the crystal axes system can be given.\nmaterial (optional): the semiconductor material. If no material is given, the material of the semiconductor is taken by default.\ndrift: the parameters needed to describe the longitudinal drift velocity along the langle100rangle and langle111rangle axes, see above.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The values from the default configuration file correspond to germanium at 78 K. Calculations of the drift velocities at other temperatures are also supported by the ADLChargeDriftModel. While experimental observations suggest that the charge mobilities of electrons and holes in the crystal are temperature dependent, the dependency law has not yet been established. Several models have been proposed to reproduce the experimental behavior, and some examples of them can be found in the directory <package_directory>/src/ChargeDriftModels/ADL/. The examples include a linear model, a Boltzmann model and a power-law model. To use these models in the calculation of the drift velocities, the corresponding configuration file, the temperature and the precision must be given to the function. As an example, in order to use the Boltzmann model at a temperature of 100 K:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = ADLChargeDriftModel(\"<path_to_drift_velocity_config_boltzmann.yaml>\", T = T, temperature = 100) \nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If no temperature is given as a parameter, the calculations will be performed at a default temperature of 78 K.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"It should be noted that the correct model has not yet been identified, and the parameters inside these configuration files -besides the default ADL ones- are just educated guesses.","category":"page"},{"location":"man/charge_drift/#Custom-Charge-Drift-Model","page":"Charge Drift","title":"Custom Charge Drift Model","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The user can implement and use his own drift model.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The first step is to define a struct for the model which is a subtype of SolidStateDetectors.AbstractChargeDriftModel:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"using SolidStateDetectors\nusing SolidStateDetectors: SSDFloat, AbstractChargeDriftModel\nusing StaticArrays\n\nstruct CustomChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T} \n    # optional fields to parameterize the model\nend","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The second step is to define two methods (getVe for electrons and getVh for holes), which perform the transformation of an electric field vector, fv::SVector{3,T}, into a velocity vector. Note, that the vectors are in cartesian coordinates, independent of the coordinate system (cartesian or cylindrical) of the simulation. ","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"function SolidStateDetectors.getVe(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return -fv\nend\n\nfunction SolidStateDetectors.getVh(fv::SVector{3, T}, cdm::CustomChargeDriftModel)::SVector{3, T} where {T <: SSDFloat}\n    # arbitrary transformation of fv\n    return fv\nend","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Then, one can apply the model to the simulation:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"T = SolidStateDetectors.get_precision_type(sim) # e.g. Float32\ncharge_drift_model = CustomChargeDriftModel{T}()\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)","category":"page"},{"location":"man/charge_drift/#Group-Effects","page":"Charge Drift","title":"Group Effects","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The movement of electrons and holes is not only given by the forces resulting from external electric fields. In addition, diffusion and self-repulsion of the charge carriers can play a significant role when simulating drift paths. To simulate this, electron and holes cannot be described as single point-like charges anymore, but as charge clouds consisting of multiple point-like charges. SolidStateDetectors.jl offers different models for the Initial Charge Cloud Distribution. Right now, Diffusion and Self-Repulsion are implemented as experimental features.","category":"page"},{"location":"man/charge_drift/#Initial-Charge-Cloud-Distribution","page":"Charge Drift","title":"Initial Charge Cloud Distribution","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Electron and hole clouds can be easily constructed using NBodyChargeCloud. An NBodyChargeCloud consists of a center point charge, surrounded by shells of equally distributed point charges. SolidStateDetectors.jl provides two constructors for an NBodyChargeCloud, depending on how the charges in the shells should be distributed. For charge clouds consisting of few charges (less than around 50), the shells should consist of Platonic Solids, whereas for higher numbers of charges, the points in the shells should be Equally Distributed on a Regular Sphere.","category":"page"},{"location":"man/charge_drift/#Platonic-Solids","page":"Charge Drift","title":"Platonic Solids","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"One way of defining an NBodyChargeCloud is having a center point charge surrounded by shells with point charges on the vertices of platonic solids. For now, all shells will have the same number of charges and be oriented the same way.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"using SolidStateDetectors #hide\nusing Unitful #hide\nusing Plots #hide\nT = Float64 #hide\ncenter = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nnbcc = NBodyChargeCloud(center, energy)\nplot(nbcc)\nplot(nbcc, color = :red, size = (500,500), xlims = (-0.0012, 0.0012), ylims = (-0.0012,0.0012), zlims = (-0.0012,0.0012)) #hide","category":"page"},{"location":"man/charge_drift/#Equally-Distributed-on-a-Regular-Sphere","page":"Charge Drift","title":"Equally Distributed on a Regular Sphere","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"For an NBodyChargeCloud consisting of more than around 50 charges, the shells should consist of more than 20 point charges and the approach with using Platonic Solids for the shell structure might not be favored anymore. For this, a second algorithm was implemented that generates point charges equally distributed on the surface of a regular sphere. The approximate number of charges needs to be passed to the constructor of NBodyChargeCloud to use this method.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"center = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nnbcc = NBodyChargeCloud(center, energy, 100)\nplot(nbcc)\nplot(nbcc, color = :red, size = (500,500), xlims = (-0.0012, 0.0012), ylims = (-0.0012,0.0012), zlims = (-0.0012,0.0012)) #hide","category":"page"},{"location":"man/charge_drift/#Diffusion","page":"Charge Drift","title":"Diffusion","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Diffusion describes the random thermal motion of charge carriers. In SolidStateDetectors.jl, diffusion is simulated using a random walk algorithm. To account for possible anisotropies in the charge drift model, diffusion is simulated via an effective electric field vector (with a fixed magnitude and random orientation) which is added to the external electric field. In this way, the anisotropy in the charge drift model is also applied to the diffusion field vector.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"center = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nnbcc = NBodyChargeCloud(center, energy, 100)\nevt = Event(nbcc)\nsimulate!(evt, sim, diffusion = true)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"(Image: Diffusion)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The magnitude of the diffusion field vector influences the diffusion constant, D, with which the charge carriers diffuse. In the abscence of an external electric field, the size (standard deviation sigma) of the charge cloud is expected to evolve with sigma = sqrt2 D t, where t is the time. Thus, the diffusion constant can be estimated from the time evolution of the charge cloud size.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"For an initial charge cloud of 100 point charges, all located at the origin of the coordinate system, and an effective diffusion field vector of 1000textVm, the random walk algorithm results in the expected sqrtt dependence. From a fit of sigma = sqrt2Dt to the simulation results, the effective diffusion constant was estimated to be around 315textcm^2texts.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"(Image: Electron_diffusion)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"The diffusion field vectors are stored in SolidStateDetectors.material_properties. For high-purity germanium, the diffusion constants for electrons and holes are reported to be D_e = 101textcm^2texts and D_h = 49textcm^2texts. Using the ADL Charge Drift Model with standard parameters, the diffusion field vectors (in units of textVm) are","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"SolidStateDetectors.material_properties[:HPGe]\nprintln(\"Electrons: $(SolidStateDetectors.material_properties[:HPGe].diffusion_fieldvector_electrons)\") #hide \nprintln(\"Holes:     $(SolidStateDetectors.material_properties[:HPGe].diffusion_fieldvector_holes)\") #hide\nnothing #hide","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"If other Charge Drift Models or other materials are to be used, the diffusion field vectors should be determined accordingly and saved to SolidStateDetectors.material_properties.","category":"page"},{"location":"man/charge_drift/#Self-Repulsion","page":"Charge Drift","title":"Self-Repulsion","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"After the creation electron-hole pairs, both the electron and the hole clouds repel each other. The electric field of a point-charge, q, at a distance to the charge, vecr, is given by","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"vecE = frac14piepsilon_0epsilon_r fracqr^2 vece_r","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"SolidStateDetectors.jl does not account for attraction of electron and holes but only for repulsion of charge carriers of the same type. The determination of the electric field vector is calculated pair-wise for each pair of charge carriers.","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"center = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nnbcc = NBodyChargeCloud(center, energy, 100)\nevt = Event(nbcc)\nsimulate!(evt, sim, self_repulsion = true)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"(Image: SelfRepulsion)","category":"page"},{"location":"man/charge_drift/#Combination-of-Group-Effects","page":"Charge Drift","title":"Combination of Group Effects","text":"","category":"section"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"Diffusion and Self-Repulsion can be simulated both at once to get the most realistic picture:","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"center = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nnbcc = NBodyChargeCloud(center, energy, 100)\nevt = Event(nbcc)\nsimulate!(evt, sim, diffusion = true, self_repulsion = true)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"(Image: GroupEffects)","category":"page"},{"location":"man/charge_drift/","page":"Charge Drift","title":"Charge Drift","text":"However, be aware that simulations including group effects will result in significantly longer simulation times.","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/main/docs/src/tutorials/complete_simulation_chain_IVC_lit.jl\"","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Simulation-Chain:-Inverted-Coax-Detector","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\n\nT = Float32\nsim = Simulation{T}(SSD_examples[:InvertedCoax])\n\nplot(sim.detector, size = (700, 700))\nsavefig(\"tutorial_det.pdf\") # hide\nsavefig(\"tutorial_det.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_det)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"apply_initial_state!(sim, ElectricPotential) # optional\nplot(\n    plot(sim.electric_potential), # initial electric potential (boundary conditions)\n    plot(sim.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(sim.q_eff_imp), # charge density distribution\n    plot(sim.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_initial_condition.pdf\") # hide\nsavefig(\"tutorial_initial_condition.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_initial_condition)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Next, calculate the electric potential:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"calculate_electric_potential!( sim,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.01])\n\nplot(\n    plot(sim.electric_potential, φ = 20), # initial electric potential (boundary conditions)\n    plot(sim.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted\n    plot(sim.q_eff_imp), # charge density distribution\n    plot(sim.ϵ_r), # dielectric distribution\n    layout = (1, 4), size = (1600, 500)\n)\nsavefig(\"tutorial_calculated_potential.pdf\") # hide\nsavefig(\"tutorial_calculated_potential.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_calculated_potential)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"is_depleted(sim.point_types)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"get_active_volume(sim.point_types) # approximation (sum of the volume of cells marked as depleted)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Partially-depleted-detectors","page":"Simulation Chain: Inverted Coax Detector","title":"Partially depleted detectors","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"sim_undep = deepcopy(sim)\nsim_undep.detector = SolidStateDetector(sim_undep.detector, contact_id = 2, contact_potential = 500); # V  <-- Bias Voltage of Mantle\n\ncalculate_electric_potential!( sim_undep,\n                               depletion_handling = true,\n                               convergence_limit = 1e-6,\n                               refinement_limits = [0.2, 0.1, 0.05, 0.01],\n                               verbose = false)\n\n\nplot(\n    plot(sim_undep.electric_potential),\n    plot(sim_undep.point_types),\n    plot(sim_undep.imp_scale),\n    layout = (1, 3), size = (1200, 600)\n)\nsavefig(\"tutorial_calculated_potential_undep.pdf\") # hide\nsavefig(\"tutorial_calculated_potential_undep.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_calculated_potential_undep)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"is_depleted(sim_undep.point_types)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Compare both volumes:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"println(\"Depleted:   \", get_active_volume(sim.point_types))\nprintln(\"Undepleted: \", get_active_volume(sim_undep.point_types));\nnothing #hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"The depletion voltage can also be estimated from the simulation.","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"estimate_depletion_voltage(sim)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Electric-field-calculation","page":"Simulation Chain: Inverted Coax Detector","title":"Electric field calculation","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Calculate the electric field of the fully depleted detector, given the already calculated electric potential:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"calculate_electric_field!(sim, n_points_in_φ = 72)\n\nplot(sim.electric_field, full_det = true, φ = 0.0, size = (700, 700))\nplot_electric_fieldlines!(sim, full_det = true, φ = 0.0)\nsavefig(\"tutorial_electric_field.pdf\") # hide\nsavefig(\"tutorial_electric_field.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_electric_field)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Simulation-of-charge-drifts","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation of charge drifts","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Any charge drift model can be used for the calculation of the electric field. If no model is explicitely given, the ElectricFieldChargeDriftModel is used. Other configurations are saved in their configuration files and can be found under:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"<package_directory>/examples/example_config_files/ADLChargeDriftModel/<config_filename>.yaml.","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Set the charge drift model of the simulation:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"charge_drift_model = ADLChargeDriftModel()\nsim.detector = SolidStateDetector(sim.detector, charge_drift_model)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Now, let's create an \"random\" multi-site event:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"starting_positions = [ CylindricalPoint{T}( 0.020, deg2rad(10), 0.015 ),\n                       CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ),\n                       CylindricalPoint{T}( 0.022, deg2rad(35), 0.025 ) ]\nenergy_depos = T[1460, 609, 1000] * u\"keV\" # are needed later in the signal generation\n\nevt = Event(starting_positions, energy_depos);\n\ntime_step = 5u\"ns\"\ndrift_charges!(evt, sim, Δt = time_step)\n\nplot(sim.detector, size = (700, 700))\nplot!(evt.drift_paths)\nsavefig(\"tutorial_drift_paths.pdf\") # hide\nsavefig(\"tutorial_drift_paths.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_drift_paths)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Weighting-potential-calculation","page":"Simulation Chain: Inverted Coax Detector","title":"Weighting potential calculation","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"for contact in sim.detector.contacts\n    calculate_weighting_potential!(sim, contact.id, refinement_limits = [0.2, 0.1, 0.05, 0.01], n_points_in_φ = 2, verbose = false)\nend\n\nplot(\n    plot(sim.weighting_potentials[1]),\n    plot(sim.weighting_potentials[2]),\n    size = (900, 700)\n)\nsavefig(\"tutorial_weighting_potentials.pdf\") # hide\nsavefig(\"tutorial_weighting_potentials.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_weighting_potentials)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Detector-Capacitance-Matrix","page":"Simulation Chain: Inverted Coax Detector","title":"Detector Capacitance Matrix","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"After the weighting potentials are calculated, the detector capacitance matrix can be calculated in the Maxwell Capacitance Matrix Notation:","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"calculate_capacitance_matrix(sim)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"See Capacitances for more information.","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/#Detector-waveform-generation","page":"Simulation Chain: Inverted Coax Detector","title":"Detector waveform generation","text":"","category":"section"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"Given an interaction at an arbitrary point in the detector, we can now simulate the charge drift and the resulting detector charge signals (e.g. at the point contact):","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"simulate!(evt, sim) # drift_charges + signal generation of all channels\n\np_pc_signal = plot( evt.waveforms[1], lw = 1.5, xlims = (0, 1100), xlabel = \"Time\", unitformat = :slash,\n                    legend = false, tickfontsize = 12, ylabel = \"Charge\", guidefontsize = 14)\nsavefig(\"tutorial_waveforms.pdf\") # hide\nsavefig(\"tutorial_waveforms.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_waveforms)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"SolidStateDetectors.jl also allows to separate the waveform into the two contributions from electrons and holes","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"contact_id = 1\nplot_electron_and_hole_contribution(evt, sim, contact_id, xlims = (0, 1100), xlabel = \"Time\",\n                    legend = :topleft, tickfontsize = 12, ylabel = \"Charge\", guidefontsize = 14)\nsavefig(\"tutorial_waveform_contributions.pdf\") # hide\nsavefig(\"tutorial_waveform_contributions.svg\"); nothing # hide","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"(Image: tutorial_waveform_contributions)","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"","category":"page"},{"location":"tutorials/complete_simulation_chain_IVC/","page":"Simulation Chain: Inverted Coax Detector","title":"Simulation Chain: Inverted Coax Detector","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/Grids/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The electric potential is calculated via successive over relaxation on a 3-dimensional grid. SolidStateDetectors.jl can calculate the electric potential on a Cartesian or a cylindrical grid:","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"CartesianGrid: 3 axes: x-, y- and z-axis.\nCylindricalGrid: 3 axes: r-, φ- and z-axis.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The system to simulate, e.g. a cryostat with a detector inside, is called \"the world\". This world is divided into a set of discrete points, called the grid::Grid. It is defined through three axes: grid.axes. Each of the three axes is divided into a discrete number of points (ticks): N_1 N_2 N_3.   The linear combinations of those points form the set of all N_mathrmgp = N_1 times N_2 times N_3 grid points.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"Each axis is defined as a SolidStateDetectors.DiscreteAxis.","category":"page"},{"location":"man/Grids/#DiscreteAxis","page":"Grids","title":"DiscreteAxis","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"A SolidStateDetectors.DiscreteAxis defines the axis of a dimension of a grid, e.g. the x-axis of a CartesianGrid.  A DiscreteAxis, e.g. ax::DiscreteAxis, stores the boundary conditions (reflecting / periodic) at the endpoints of the axis as well as the discrete ticks, ax.ticks, of the axis in the interval ax.interval. The interval also specifies whether the endpoints of the interval are included in the ticks or not via :closed or :open in the type of the interval. The ticks do not need to be evenly spaced, allowing for an adaptive refinement of the grid in areas where the gradient of the electric potential is large.","category":"page"},{"location":"man/Grids/#Grid-Initialization","page":"Grids","title":"Grid Initialization","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The grid can be specified in the configuration files, see Grid, of sim::Simulation.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"There is a constructor method for grid: Grid(sim::Simulation).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"In calculate_electric_potential!,calculate_weighting_potential! and simulate!(sim::Simulation) the calculation of the potentials start with an initial grid, which can be passed to these functions via the keyword grid. If no grid is passed, the grid is generated via Grid(::Simulation).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The two keywords max_tick_distance and max_distance_ratio can also be passed to the functions calculate_electric_potential!,calculate_weighting_potential! and simulate!(sim::Simulation) where they are internally forwarded.","category":"page"},{"location":"man/Grids/#Initialization-of-the-Grid","page":"Grids","title":"Initialization of the Grid","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"Important points of the objects of the simulation are obtained, e.g. the corners of a Box-primitive.  The coordinates of these points are used to generate the ticks of each axis of the grid.\nFor each axis, additional ticks are added based on the keyword max_distance_ratio::Real = 5:  If the ratio between the distances of an axis tick to its neighboring ticks is larger than max_distance_ratio  (or smaller than inv(max_distance_ratio)), additional ticks are inserted such that in the end  all those ratios are within the interval [inv(max_distance_ratio), max_distance_ratio].\nFinally, additional ticks are added for each axis if the distance between two ticks is larger  than a threshold distance specified via the keyword max_tick_distance.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"max_tick_distance can either be a Quantity, e.g. 1u\"mm\", or a Tuple of Quantities, e.g. (1u\"mm\", 0.2u\"cm\", 3u\"mm\"), to set it for each axis of the grid separately. If max_tick_distance is missing, one fourth of the axis length is used.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"See also Grid(::Simulation).","category":"page"},{"location":"man/Grids/#Grid-Refinement","page":"Grids","title":"Grid Refinement","text":"","category":"section"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"After the potential has converged to equilibrium on the initial grid, the grid can be refined (multiple times).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"The refinement can be tuned via the keyword refinement_limits in calculate_electric_potential!,calculate_weighting_potential! and simulate!(sim::Simulation).","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"It defines the maximum (relative to applied bias voltage) allowed differences of the potential values of neighbored grid points in each dimension for each refinement. It can be specified in different ways, see e.g. calculate_electric_potential!.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"One simple example would be refinement_limits = [0.2, 0.1, 0.05]. This would mean that the grid would be refined three times and the refinement limit would be the same for each dimension of the grid in each refinement. In the first refinement, the refinement limit would be 0.2. Thus, if the bias voltage of the detector in the simulation is 1000 V, the maximum allowed potential difference between two grid points would be 200 V. Let's say there is a potential difference of 500 V between the two grid points at (i,j,k) and (i,j+1,k). Then, two (floor(Int, 500 / 200) = 2) ticks are added in the second axis between the previous axis ticks, grid.axes[2].ticks[j] and grid.axes[2].ticks[j+1], which results in 2 times N_1 times N_3 new additional grid points. The potential values at the added grid points are determined through linear interpolation. Then, the potential values of all grid points are updated (through the SOR) until convergence is reached again and the next refinement with 0.1 is executed.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"Another keyword can be used to set a minimum allowed distance between to ticks: min_tick_distance, see e.g. calculate_electric_potential!, which prohibits the insertion of new ticks if the new resulting distances between the ticks would be below this limit.","category":"page"},{"location":"man/Grids/","page":"Grids","title":"Grids","text":"note: Note\nIt is usually favourable to make more refinements with smaller differences in the limits. Thus, for example, refinement_limits = [0.2, 0.1, 0.05, 0.03, 0.01] is usually better than refinement_limits = [0.2, 0.01].","category":"page"},{"location":"man/weighting_potentials/#Weighting-Potentials","page":"Weighting Potentials","title":"Weighting Potentials","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential is a theoretical potential that describes what fraction of a charge at position vecr is seen by a contact, C_i. The weighting potential can take values between 0, i.e. the charge is not seen by the electrode, and 1, i.e. the charge is collected by the electrode. ","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"nabla left( epsilon_r(vecr) nabla Phi_i^w(vecr)right) = 0\r\nPhi_i^w(vecr)vert_C_j = left beginarrayll 1  textif i = j  0  textif i neq j endarray right","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"where Phi_i^w is the electric potential and epsilon_r is the dielectric distribution.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The net charge induced on each electrode C_i, Q_i, by electrons and hole with absolute charge Q is given by the Schockley-Ramo theorem:","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"Q_i = Q left( sumlimits_textholes Phi_i^w(vecr_h) -  sumlimits_textelectrons Phi_i^w(vecr_e) right)","category":"page"},{"location":"man/weighting_potentials/#Simulation-Algorithm","page":"Weighting Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential for an electrode is internally calculated with the same function as the electric potential when calling calculate_weighting_potential!(sim, contact_id). The differences are that rho(vecr) is set to zero and that the boundary conditions of fixed values on the contacts are adapted.","category":"page"},{"location":"man/weighting_potentials/","page":"Weighting Potentials","title":"Weighting Potentials","text":"note: GPU\nWeighting potentials can be calculated on GPUs. See GPU Support in Field Calculations.","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package is a registered package.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Install via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add SolidStateDetectors\"","category":"page"},{"location":"man/installation/#Visualization-/-Plotting-(Optional)","page":"Installation","title":"Visualization / Plotting (Optional)","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This package provides serveral plot recipes for different outputs for the plotting package Plots.jl.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use these also install the Plots.jl package via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add Plots\"","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Load the Plots.jl package (and optionally the backend pyplot) via","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Plots","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The backends supported by SolidStateDetectors.jl are gr and pyplot. By default, gr is loaded when importing Plots.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For more information about the plot recipes of this package look up the Plotting section.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This documentation was build with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg, Plots # hide\r\npkgversion(m::Module) = Pkg.TOML.parsefile(joinpath(dirname(string(first(methods(m.eval)).file)), \"..\", \"Project.toml\"))[\"version\"] # hide\r\nPlots_version = pkgversion(Plots) # hide\r\nGR_version = pkgversion(GR) # hide\r\nprint(\"Plots: v$(Plots_version) - GR: v$(GR_version)\") # hide","category":"page"},{"location":"man/installation/#GPU-Support-in-Field-Calculations","page":"Installation","title":"GPU Support in Field Calculations","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The Electric Potential and individual Weighting Potentials can also be calculated on GPUs. SolidStateDetectors.jl uses KernelAbstractions.jl for GPU support.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In order to use your GPU, the Julia Packages CUDA.jl or AMDGPU.jl have to be installed and loaded. SolidStateDetectors.jl may run on other GPU types supported by KernelAbstractions.jl, but has not been tested with oneAPI.jl or Metal.jl yet.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For NVIDIA GPUs use:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using CUDA, SolidStateDetectors\r\n# *Only* for KernelAbstractions < v0.9:\r\n# using CUDAKernels","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For AMD GPUs use:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using AMDGPU, SolidStateDetectors\r\n# *Only* for KernelAbstractions < v0.9:\r\n# using ROCKernels","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Then, in any field calculation (calculate_electric_potential!, calculate_weighting_potential!, simulate!(::Simulation)) the keyword device_array_type can be set to choose the device on which the calculations should be performed. The possibilities are:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"device_array_type = Array # -> CPU (default)\r\ndevice_array_type = CuArray # -> NVIDIA GPU\r\ndevice_array_type = ROCArray # -> AMD GPU","category":"page"},{"location":"man/installation/#Example-(NVIDIA)","page":"Installation","title":"Example (NVIDIA)","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using CUDA, SolidStateDetectors\r\n# *Only* for KernelAbstractions < v0.9:\r\n# using CUDAKernels\r\n\r\nsim = Simulation(SSD_examples[:CGD])\r\ncalculate_electric_potential!( \r\n    sim, \r\n    device_array_type = CuArray, \r\n    refinement_limits = [0.2, 0.1, 0.05],\r\n    depletion_handling = true\r\n)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"note: Note\nThe AMD backend was not yet tested due to lack of an AMD GPU (we are working on that).","category":"page"},{"location":"man/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"In order to plot geometries or simulation results, the user will need to load the Plots.jl package.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"First, we have to calculate something in order to demonstrate the plotting tools:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\ngr(fmt = :png) #hide\n\nT = Float32\nsim = Simulation{T}(SSD_examples[:InvertedCoax]);\nsimulate!(sim, convergence_limit = 1e-6, refinement_limits = [0.2, 0.1, 0.05, 0.01]);","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\n\nT = Float32\nsim = Simulation{T}(SSD_examples[:InvertedCoax]);\nsimulate!(sim, convergence_limit = 1e-6, refinement_limits = [0.2, 0.1, 0.05, 0.01]);","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Besides the usual Plots.jl keywords settings, like size = (500, 500), there are some additional settings to tune the plots which are described in the following sections.","category":"page"},{"location":"man/plotting/#Detector-Plots","page":"Plotting","title":"Detector Plots","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The geometry of a detector, together with its environment, can be simply plotted via","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"det = sim.detector\nplot(det, size = (500, 500))","category":"page"},{"location":"man/plotting/#Plot-Styles","page":"Plotting","title":"Plot Styles","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The style of the detector plot can be controlled via the seriestype keyword. There are 4 available styles:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(\n      plot(det, seriestype = :csg, title = \":csg\"),\n      plot(det, seriestype = :wireframe, title = \":wireframe\"),\n      plot(det, seriestype = :mesh3d, title = \":mesh3d\"), \n      plot(\n            det, seriestype = :samplesurface, n_samples = 100, \n            markersize = 2, markeralpha = 0.03, title = \":samplesurface\"\n            ), \n      layout = (1,4), size = (800,200), legend = false, ticks = false, \n      guide = \"\", zlims = (-0.005,0.1)\n)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The seriestype can be set to :csg (default), :wireframe, :mesh3d, or :samplesurface. :csg plots a wireframe on top of a mesh (with no mesh gridlines). For fastest plotting use either :wireframe or :mesh3d and consider changing n_arc (see Optional Keywords). :csg, :wireframe, and :mesh3d are all mesh-based. For geometries containing differences or intersections the recommended seriestype is :samplesurface. This can be seen by plotting the detector's semiconductor below. :samplesurface is marker-based. The marker density is set low by default for speed. For increased plot fidelity use n_samples = 100 and markersize = 2.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(\n      plot(det.semiconductor, seriestype = :csg, title = \":csg\"),\n      plot(det.semiconductor, seriestype = :wireframe, title = \":wireframe\"),\n      plot(det.semiconductor, seriestype = :mesh3d, title = \":mesh3d\"), \n      plot(\n            det.semiconductor, seriestype = :samplesurface, n_samples = 100, \n            markersize = 2, markeralpha = 0.03, title = \":samplesurface\"\n            ), \n      layout = (1,4), size = (800,200), legend = false, ticks = false, \n      guide = \"\", zlims = (-0.005,0.1)\n)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"note: Note\nSo far, when using mesh-based seriestypes (:csg, :wireframe, :mesh3d), plots are produced by plotting whole primitives. Thus, usually, nicer plots are produced if the geometry consists only of unions of primitives and not differences or intersections. If the geometry contains differences, the resulting negative geometries are plotted with thinner wireframe lines and/or with semi-transparent white mesh faces depending on the seriestype used. ","category":"page"},{"location":"man/plotting/#How-does-the-plot-recipe-work?","page":"Plotting","title":"How does the plot recipe work?","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The detector consists of a semiconductor, det.semiconductor, its contacts, det.contacts, and its surrounding objects, det.passives. By default (see Optional Keywords), only the contacts and the surrounding objects are plotted and the color of the contact primitives is defined internally through their id.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"Components can also be plotted individually for enhanced style handling. Additionally, the units of the axes are set by calling a plot command with units beforehand.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(u\"cm\", u\"cm\", u\"cm\")\nplot!(det.semiconductor, st = :samplesurface, n_samples = 100, markersize = 2,\n      camera = (40, 55), size = (500, 500))\nplot!(det.contacts[1], st = :mesh3d, linewidth = 0.5, fillcolor = :white)\nplot!(det.contacts[2], st = :wireframe, n_vert_lines = 5)","category":"page"},{"location":"man/plotting/#Optional-Keywords","page":"Plotting","title":"Optional Keywords","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"show_semiconductor: Will display the semiconductor if set to true. Default is false.\nshow_passives: Will display the objects surrounding the detector if set to true. Default is true.\nseriestype: Can be :csg (default), :wireframe, :mesh3d, or :samplesurface.\nlinewidth: Sets the line width of the edges of the mesh gridlines when using seriestype = :mesh3d. When using seriestype = :csg or seriestype = :wireframe, linewidth sets the line width of the wireframe.\nlinecolor: Sets the line color of the edges of the mesh gridlines when using seriestype = :mesh3d. When using seriestype = :csg or seriestype = :wireframe, linecolor sets the line color of the wireframe.\nfillcolor: Sets the face color of all faces of the mesh.\nfillalpha: Sets the alpha value of all faces of the mesh.\nmarkercolor: Sets the marker color.\nmarkersize: Sets the marker size. markersize = 4 is the default value.\nmarkeralpha: Sets the alpha value for markers.\nn_arc: Controls the discretization of curved objects in a mesh. Each full ellipse is divided into n_arc segments. Partial ellipses are drawn with a proportional number (n_arc*f with f<1) of segments.n_arc = 40 is the default value. Smaller n_arc values will result in faster plotting, specially if the geometry contains tori or ellipsoids.\nn_vert_lines: Controls the number of wireframe \"vertical\" lines in a mesh. n_vert_lines = 2 is the default value. A maximum of n_arc*f vertical lines can be drawn on each curved object. This keyword is ignored by polygons.\nn_samples: Controls the marker density. n_samples = 40 is the default value. Reduce this value for faster plotting. Consider increasing markersize and/or markeralpha to compensate for the visual impact of lower marker densities. Note that the marker density is intended to be even across all dimensions. Therefore, visual distortions will occur if the aspect ratio of the axes is far from unity.","category":"page"},{"location":"man/plotting/#Scalar-Potential-Plots","page":"Plotting","title":"Scalar Potential Plots","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"When calculating the electric potential, a set of scalar potentials are stored in the Simulation object, e.g. sim.electric_potential, sim.point_types, and sim.q_eff_imp. SolidStateDetectors.jl has plot recipes for these scalar potentials.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(sim.electric_potential)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"There are several keyword arguments that can be passed to adjust the potential plots. First, the simulated potentials are simulated on a three-dimensional Grid, but the plots will always be a two-dimensional cross section (for a CylindricalGrid at constant r, φ or z, for a CartesianGrid3D at constant x, y or z). The cross section can be specified in the plot command. A cross section of the ElectricPotential at z = 20mm can be plotted via","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(sim.electric_potential, z = 20u\"mm\")","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"In addition to all plot attributes that are implemented in Plots.jl, plots of scalar potentials can take two additional keyword arguments, contours_equal_potential and full_det, which both are of type Bool:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"contours_equal_potential: If this set to true, the plot will additionally display contour lines at points with equal potential value.\nfull_det: By default, cross sections in φ are only displayed for positive radii r. If full_det is set to true, cross sections in φ are also extended to \"negative\" r, by additionally plotting the potential values at φ + 180° on the left side of the plot.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot( sim.electric_potential, φ = 30u\"°\", \n      contours_equal_potential = true, full_det = true, \n      linecolor = :white, levels = 34)","category":"page"},{"location":"man/plotting/#Electric-Field-Plots","page":"Plotting","title":"Electric Field Plots","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The magnitude of the electric field can be plotted using the same syntax as Scalar Potential Plots.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(sim.electric_field, full_det = true, clims = (0, 5e5))","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"In addition, SolidStateDetectors.jl offers the possibilities to plot electric field lines via plot_electric_fieldlines. This is done by spawning charges close to the surface of the contacts and simulating their drift parallel to the electric field, using ElectricFieldChargeDriftModel.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot_electric_fieldlines!(sim, full_det = true)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"In addition to all plot attributes that are implemented in Plots.jl, the syntax for specifying the cross section and full_det (see Scalar Potential Plots), the plot recipe for electric field lines can additionally understand the following arguments to tune the plot.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"sampling: Specifies the steps at which the contacts are sampled to generate equally spaced charges at the surface. The default is 2u\"mm\", but the optimal value depends on the geometry of the detector and contacts. If no unit is given, sampling is interpreted in units of meter.\noffset: The charges are created on the surface and have to be moved slightly inside the semiconductor to be able to drift (charges that are in the contacts will not drift). This keyword defines how much the charges will be moved inside along the normal vector of the surface. The default is 0.5u\"mm\", but the optimal value again depends on the detector geometry. Unitless quantities are interpreted in units of meter.\nskip_contact: Detectors will usually have positively and negatively biased contacts. The charges should only be spawned on either of them, but not both. This keyword defines which contact should be skipped in the charge spawn algorithm. Default is 1, i.e. that no charges will be spawned at the surface of contact with id = 1.\nmax_nsteps: After all, the generation of electric field lines is based on the charge drift code, which requires a maximum number of steps, which is set to 5000 by default here. If the drift ends before the charges reach a contact, the electric field line will not be fully displayed. In this case, it is recommended to increase max_nsteps.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"In case the electric field line plots do not look good, adjust sampling, offset and max_nsteps until obtaining the desired result.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(sim.electric_field, full_det = true, size = (500,500), clims = (0,5e5))\nplot_electric_fieldlines!(sim, full_det = true, sampling = 3u\"mm\", offset = 2u\"mm\")","category":"page"},{"location":"man/plotting/#Event-Plots","page":"Plotting","title":"Event Plots","text":"","category":"section"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"SolidStateDetectors.jl also provides plot recipes to display charge drift paths resulting from simultaneous energy deposits in the semiconductor body of the detector. To simulate and plot an individual event, the Event struct is recommended.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"evt = Event([CartesianPoint{T}(0.01,0.01,0.075)], [2u\"MeV\"])\nsimulate!(evt, sim)\nplot(sim.detector, size = (500,500), label = \"\")\nplot!(evt.drift_paths)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The drift path plots can be modified using the keywords implemented in Plots.jl. The units of the axes can be set by calling a plot command with units beforehand:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(u\"mm\", u\"mm\", u\"mm\")\nplot!(sim.detector, size = (500,500), label = \"\")\nplot!(evt.drift_paths, linewidth = 2, linestyle = :dash, markersize = 6)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"There are also plot recipes for plotting the simulated waveforms of the Event:","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(evt.waveforms, unitformat = :slash, label = \"Contact \".*string.((1:2)'), legend = :topleft)","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"The length of the waveforms is given by the length of the charge drift. By default, no baseline and no tail are added to the waveforms. However, this might be desired in waveforms plots. The waveforms can be extended by calling add_baseline_and_extend_tail on the waveforms. Again, the units of the axes can be set by calling a plot command with units before plotting the waveforms.","category":"page"},{"location":"man/plotting/","page":"Plotting","title":"Plotting","text":"plot(u\"µs\", u\"fC\")\nplot!(add_baseline_and_extend_tail.(evt.waveforms,0,400), \n      linewidth = 4, linestyle = :dash, \n      label = \"\", unitformat = :slash)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup  = quote\r\n    using SolidStateDetectors\r\n    using SolidStateDetectors.ConstructiveSolidGeometry\r\nend","category":"page"},{"location":"api/#Dictionaries","page":"API","title":"Dictionaries","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:constant]","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SolidStateDetectors, SolidStateDetectors.ConstructiveSolidGeometry]\r\nOrder = [:constant, :type, :function]","category":"page"},{"location":"api/#SolidStateDetectors.SSD_examples","page":"API","title":"SolidStateDetectors.SSD_examples","text":"SSD_examples::Dict{Symbol,String}\n\nDictionary with the paths to the example detector configuration files provided by the package.\n\nFind the possible keys of the dictionary with keys(SSD_examples).\n\nThe example detector configuration files can be loaded via\n\npath_to_config_file = SSD_examples[:InvertedCoax]\nsim = Simulation(path_to_config_file)\n\n\n\n\n\n","category":"constant"},{"location":"api/#SolidStateDetectors.ADLChargeDriftModel","page":"API","title":"SolidStateDetectors.ADLChargeDriftModel","text":"ADLChargeDriftModel{T <: SSDFloat, M <: AbstractDriftMaterial, N, TM <: AbstractTemperatureModel{T}} <: AbstractChargeDriftModel{T}\n\nCharge drift model for electrons and holes based on the AGATA Detector Library. Find a detailed description of the calculations in ADL Charge Drift Model.\n\nFields\n\nelectrons::CarrierParameters{T}: Parameters to describe the electron drift along the <100> and <111> axes.\nholes::CarrierParameters{T}: Parameters to describe the hole drift along the <100> and <111> axes.\ncrystal_orientation::SMatrix{3,3,T,9}: Rotation matrix that transforms the global coordinate system to the crystal coordinate system given by the <100>, <010> and <001> axes of the crystal.\nγ::SVector{N,SMatrix{3,3,T,9}}: Reciprocal mass tensors to the N valleys of the conduction band.\nparameters::ADLParameters{T}: Parameters needed for the calculation of the electron drift velocity.\ntemperaturemodel::TM: Models to scale the resulting drift velocities with respect to temperature\n\nSee also CarrierParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractChargeDensity","page":"API","title":"SolidStateDetectors.AbstractChargeDensity","text":"abstract type AbstractChargeDensity{T <: SSDFloat} end\n\nStruct defining the charge density inside a Passive.\n\nFor each charge density, there should be a method get_charge_density  which returns the charge density in SI units (C/m³) at a given point pt.\n\nExamples\n\nConstantChargeDensity\nLinearChargeDensity\nCylindricalChargeDensity\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractImpurityDensity","page":"API","title":"SolidStateDetectors.AbstractImpurityDensity","text":"abstract type AbstractImpurityDensity{T <: SSDFloat} end\n\nStruct defining an impurity density inside a Semiconductor.\n\nFor each impurity density, there should be a method get_impurity_density which returns the impurity density in SI units (1/m³) at a given point.\n\nExamples\n\nConstantImpurityDensity\nLinearImpurityDensity\nCylindricalImpurityDensity\n\nnote: Note\nThe sign of the impurity density is important. It is taken into account in the conversion to a charge density and, thus, defines where the semiconductor is n-type or p-type. \n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CarrierParameters","page":"API","title":"SolidStateDetectors.CarrierParameters","text":"struct CarrierParameters{T <: SSDFloat}\n\nParameters needed to describe the electron or hole drift along the <100> and <111> axes.\n\nFields\n\naxis100::VelocityParameters{T}: Parameters to describe the charge drift along the <100> axis.\naxis111::VelocityParameters{T}: Parameters to describe the charge drift along the <111> axis.\n\nSee also VelocityParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantChargeDensity","page":"API","title":"SolidStateDetectors.ConstantChargeDensity","text":"struct ConstantChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nCharge density model that assumes a constant charge density everywhere.\n\nFields\n\nρ::T: the constant value of the charge density.\n\nDefinition in Configuration File\n\nA ConstantChargeDensity is defined in the configuration file through the field charge_density  (of a passive or surrounding) with name: constant and a value for ρ.\n\nAn example definition of a constant charge density looks like this:\n\ncharge_density:\n  name: constant\n  value: 1.0e-10 # C/m³\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstantImpurityDensity","page":"API","title":"SolidStateDetectors.ConstantImpurityDensity","text":"struct ConstantImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nImpurity density model that assumes a constant impurity density everywhere.\n\nFields\n\nρ::T: the constant value of the impurity density.\n\nDefinition in Configuration File\n\nA ConstantImpurityDensity is defined in the configuration file through the field impurity_density  (of a semiconductor) with name: constant and a value for ρ.\n\nAn example definition of a constant impurity density looks like this:\n\nimpurity_density:\n  name: constant\n  value: 1.0e10 # 1/m³\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Contact","page":"API","title":"SolidStateDetectors.Contact","text":"struct Contact{T, G, MT} <: AbstractContact{T}\n\nContact of a SolidStateDetector.\n\nFor the simulation of the ElectricPotential, all contacts are fixed to a constant potential value.\n\nParametric types:\n\nT: Precision type.\nG: Type of geometry.\nMT: Type of material.\n\nFields\n\npotential::T: Potential (in V) to which the contact will be fixed during the calculation of the ElectricPotential.\nmaterial::MT: Material of the contact.\nid::Int: Unique id that will unambiguously identify the contact.\nname::String: Custom name for the contact, relevant for plotting.\ngeometry::G: Geometry of the contact, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA Contact is defined in the configuration file through an entry in the contacts array of a detector. It needs id, potential and geometry and can optionally be given a name and material.\n\nAn example definition of contacts looks like this:\n\ncontacts:\n  - name: \"n+ contact\"\n    id: 1\n    potential: 5000V\n    material: HPGe # optional\n    geometry: # ....\n  - name: \"p+ contact\"\n    id: 2\n    potential: 0\n    material: HPGe #optional\n    geometry: # ....\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalChargeDensity","page":"API","title":"SolidStateDetectors.CylindricalChargeDensity","text":"struct CylindricalChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nCharge density model which assumes a linear gradient in charge density in each spatial dimension  of a cylindrical coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: charge density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in r and z direction.\n\nDefinition in Configuration File\n\nA CylindricalChargeDensity is defined in the configuration file through the field charge_density  (of a passive or surrounding) with name: cylindrical and optional fields r and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a cylindrical charge density looks like this:\n\ncharge_density:\n  name: cylindrical\n  r:  # impurity profile with linear gradient in r\n    init: 1.0e-10     # C/m³\n    gradient: 1.0e-11 # C/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.CylindricalImpurityDensity","page":"API","title":"SolidStateDetectors.CylindricalImpurityDensity","text":"struct CylindricalImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nImpurity density model which assumes a linear gradient in impurity density in each spatial dimension  of a cylindrical coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: impurity density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in r and z direction.\n\nDefinition in Configuration File\n\nA CylindricalImpurityDensity is defined in the configuration file through the field impurity_density  (of a passive or surrounding) with name: cylindrical and optional fields r and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a cylindrical impurity density looks like this:\n\nimpurity_density:\n  name: cylindrical\n  r:  # impurity profile with linear gradient in r\n    init: 1.0e10     # 1/m³\n    gradient: 1.0e11 # 1/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DeadVolume","page":"API","title":"SolidStateDetectors.DeadVolume","text":"struct DeadVolume{T, G} <: AbstractVirtualVolume{T}\n\nVolume inside which the charge drift is set to zero.\n\nParametric types\n\nT: Precision type.\nG: Type of geometry.\n\nFields\n\nname::String: Name of the dead volume, relevant for plotting.\ngeometry::G: Geometry of the dead volume, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA DeadVolume is defined through an entry in the virtual_drift_volumes array of a detector with model: dead. It needs a geometry and can optionally be given a name.\n\nAn example definition of dead volumes looks like this:\n\nvirtual_drift_volume:\n  - name: Volume 1\n    model: dead\n    geometry: # ...\n  - name: Volume 2\n    model: dead\n    geometry: # ...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DielectricDistribution","page":"API","title":"SolidStateDetectors.DielectricDistribution","text":"struct DielectricDistribution{T, N, S, AT} <: AbstractArray{T, N}\n\nDielectric distribution, or distribution of the relative permittivity, epsilon_r,  needed to calculate the ElectricPotential. The dielectric distribution is unitless.\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the dielectric distribution at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points at which the electric potential is determined.\n\nnote: Note\nThe data array contains the values of the dielectric distribution at the discrete points  between the points defined by the axes ticks of the extended grid of grid.Thus, size(data) == size(grid) .+ 1 !\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"struct DiscreteAxis{T, BL, BR, I} <: AbstractAxis{T, BL, BR, I}\n\nAxis with discrete ticks which is used to define a dimension of a Grid.\n\nParametric types\n\nT: Type of ticks\nBL: Boundary condition at the left endpoint.\nBR: Boundary condition at the right endpoint.\nI: IntervalSets.Interval (closed or open boundaries)\n\nThe boundary conditions of a DiscreteAxis can be BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}.\n\nFields\n\ninterval::I: Interval that defines the range of the axis.\nticks::Vector{T}: Array of values that correspond to the discrete ticks of the axis.\n\nSee also Grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}\n\nConstructor of a DiscreteAxis.\n\nArguments\n\nleft_endpoint::T: Left endpoint of the interval of the DiscreteAxis.\nright_endpoint::T: Right endpoint of the interval of the DiscreteAxis.\nBL::Symbol: Boundary condition at the left endpoint.\nBR::Symbol: Boundary condition at the right endpoint.\nL::Symbol: Boundary type of the left endpoint.\nR::Symbol: Boundary type of the right endpoint.\nticks::AbstractVector{T}: Array of values that correspond to the discrete ticks of the axis.\n\nThe boundary conditions of a DiscreteAxis can be BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}.\n\nThe boundary types of a DiscreteAxis can be L, R ∈ {:closed, :open}.\n\nExamples\n\nDiscreteAxis(-2.0, 2.0, :infinite, :infinite, :closed, :closed, collect(-2:0.1:2))\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.EffectiveChargeDensity","page":"API","title":"SolidStateDetectors.EffectiveChargeDensity","text":"struct EffectiveChargeDensity{T, N, S, AT} <: AbstractArray{T, N}\n\nEffective charge density needed to calculate the ElectricPotential. The effective charge density is the charge density (in C/m³) times the volume of the voxel of the respective grid point (in m³). Thus, the unit of the effective charge density is Coulomb (C).\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the effective charge density at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points at which the electric potential is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricField","page":"API","title":"SolidStateDetectors.ElectricField","text":"struct ElectricField{T, N, S, AT} <: AbstractArray{T, N}\n\nElectric field of the simulation in units of volt per meter (V/m).\n\nParametric types\n\nT: Element type of grid.axes.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.\n\nFields\n\ndata::Array{<:StaticArray{Tuple{N}, T}, N}: Array containing the field vectors of the electric field at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the electric field is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricFieldChargeDriftModel","page":"API","title":"SolidStateDetectors.ElectricFieldChargeDriftModel","text":"struct ElectricFieldChargeDriftModel{T <: SSDFloat} <: AbstractChargeDriftModel{T}\n\nCharge drift model in which the electrons and holes drift along the electric field with a mobility of ± 1m²/Vs.\n\nThis model is the default when no charge drift model is defined in the configuration file.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ElectricPotential","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"struct ElectricPotential{T, N, S, AT} <: AbstractArray{T, N}\n\nElectric potential of the simulation in units of volt (V).\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the electric potential at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the electric potential is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Event","page":"API","title":"SolidStateDetectors.Event","text":"mutable struct Event{T <: SSDFloat}\n\nCollection struct for individual events.  This (mutable) struct is meant to be used to look at individual events, not to process a huge amount of events.\n\nFields\n\nlocations::VectorOfArrays{CartesianPoint{T}}: Vector of the positions of all hits of the event.\nenergies::VectorOfArrays{T}: Vector of energies corresponding to the hits of the event.\ndrift_paths::Union{Vector{EHDriftPath{T}}, Missing}: Calculated drift paths of each hit position. \nwaveforms::Union{Vector{<:Any}, Missing}: Generated signals (waveforms) of the event.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.GeometricalAzimutalAxisWeights","page":"API","title":"SolidStateDetectors.GeometricalAzimutalAxisWeights","text":"struct GeometricalAzimutalAxisWeights{T} <: AbstractGeometricalAxisWeights{T}\n\nGeometricalAzimutalAxisWeights stores certain precalculated (in its construction) fixed values of the azimulal (or polar) axis, ax, of an cylindrical grid on which the field calculation is performed.  These precalculated values are further used in the field calculation  to calculate the six weights for the neighboring grid points in the SOR. \n\nGeometricalAzimutalAxisWeights has only one field: weights::Array{T}, 2, which is  of size (4, length(ax.ticks)). Each row holding the 4 precalculated values for one axis tick.\n\nAxis ticks, t = ax.ticks, and midpoints, mp = midpoints(get_extended_ticks(ax)),\n(the middle points between to axis ticks) inbetween:\n... t[i-1] --- mp[i] --- t[i] --- mp[i+1] --- t[i+1] ...\nare required for the understanding of the precalculated values.\n\nThe columns store the following quantities:\n\nweights[1, i]: (mp[i+1] - t[i]) / weights[3, i]\nweights[2, i]: (t[i] - mp[i]) / weights[3, i]\nweights[3, i]: mp[i+1] - mp[i]\nweights[4, i]: inv(t[i] - t[i-1])\nweights[5, i]: normalize(wφ[3, 1:2:end], 1)\nweights[6, i]: normalize(wφ[3, 2:2:end], 1)\n\nDeveloper note: This actually seems to be the same as GeometricalCartesianAxisWeights. Thus, we actually could remove that. Or change this into an alias.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.GeometricalCartesianAxisWeights","page":"API","title":"SolidStateDetectors.GeometricalCartesianAxisWeights","text":"struct GeometricalCartesianAxisWeights{T} <: AbstractGeometricalAxisWeights{T}\n\nGeometricalCartesianAxisWeights stores certain precalculated (in its construction) fixed values of one of the cartesian (linear) axes, ax, of the grid on which the field calculation is performed.  These precalculated values are further used in the field calculation  to calculate the six weights for the neighboring grid points in the SOR. \n\nGeometricalCartesianAxisWeights has only one field: weights::Array{T}, 2, which is  of size (4, length(ax.ticks)). Each row holding the 4 precalculated values for one axis tick.\n\nAxis ticks, t = ax.ticks, and midpoints, mp = midpoints(get_extended_ticks(ax)),\n(the middle points between to axis ticks) inbetween:\n... t[i-1] --- mp[i] --- t[i] --- mp[i+1] --- t[i+1] ...\nare required for the understanding of the precalculated values.\n\nThe columns store the following quantities:\n\nweights[1, i]: (mp[i+1] - t[i]) / weights[3, i]\nweights[2, i]: (t[i] - mp[i]) / weights[3, i]\nweights[3, i]: mp[i+1] - mp[i]\nweights[4, i]: inv(t[i] - t[i-1])\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.GeometricalRadialAxisWeights","page":"API","title":"SolidStateDetectors.GeometricalRadialAxisWeights","text":"struct GeometricalRadialAxisWeights{T} <: AbstractGeometricalAxisWeights{T}\n\nGeometricalRadialAxisWeights stores certain precalculated (in its construction) fixed values of the radial axis, ax, of an cylindrical grid on which the field calculation is performed.  These precalculated values are further used in the field calculation  to calculate the six weights for the neighboring grid points in the SOR. \n\nGeometricalRadialAxisWeights has only one field: weights::Array{T}, 2, which is  of size (6, length(ax.ticks)). Each row holding the 6 precalculated values for one axis tick.\n\nAxis ticks, t = ax.ticks, and midpoints, mp = midpoints(get_extended_ticks(ax)),\n(the middle points between to axis ticks) inbetween:\n... t[i-1] --- mp[i] --- t[i] --- mp[i+1] --- t[i+1] ...\nare required for the understanding of the precalculated values.\n\nThe columns store the following quantities:\n\nweights[1, i]: (mp[i+1] - t[i]) / weights[3, i]\nweights[2, i]: (t[i] - mp[i]) / weights[3, i]\nweights[3, i]: (mp[i+1] - mp[i]) / t[i]\nweights[4, i]: mp[i+1] / (t[i+1] - t[i])\nweights[5, i]: mp[i] / (t[i] - t[i-1])\n# Developer note: maybe this one could be removed as it basically stores the same as weights[4, i-1]\nweights[6, i]: (mp[i+1]^2 - mp[i]^2)/2\n\nDeveloper note: Some of the weights for i == 1 are set manually as r = 0 requires some special treatment.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid","page":"API","title":"SolidStateDetectors.Grid","text":"struct Grid{T, N, S <: AbstractCoordinateSystem, AT} <: AbstractGrid{T, N}\n\nCollection of N axes that define the dimensions of the grid needed to calculate  ElectricPotential, ElectricField or WeightingPotential.\n\nParametric types\n\nT: Tick type (element type) of the axes.\nN: Dimension of the grid.\nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.\n\nFields\n\naxes::AT: Tuple of length N containing DiscreteAxis for each dimension of the grid.\n\nSee also DiscreteAxis.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Grid-Union{Tuple{Simulation{T, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.Grid","text":"Grid(sim::Simulation{T, Cartesian}; kwargs...)\nGrid(sim::Simulation{T, Cylindrical}; kwargs...)\n\nInitializes a Grid based on the objects defined in a Simulation.\n\nThe important points of all objects are sampled and added to the ticks of the grid. The grid initialization can be tuned using a set of keyword arguments listed below.\n\nArguments\n\nsim::Simulation{T, S}: Simulation for which the grid will be defined.\n\nKeywords\n\nmax_tick_distance = missing: Maximum distance between neighbouring ticks of the grid.   Additional grid ticks will be added if two neighbouring ticks are too far apart.   max_tick_distance can either be a Quantity, e.g. 1u\"mm\", or a Tuple of Quantity,    e.g. (1u\"mm\", 15u\"°\", 3u\"mm\"),   to set it for each axis of the Grid separately. Note that a CartesianGrid3D requires a    Tuple{LengthQuantity, LengthQuantity, LengthQuantity} while a CylindricalGrid requires a   Tuple{LengthQuantity, AngleQuantity, LengthQuantity}.   If max_tick_distance is missing, one fourth of the axis length is used.\nmax_distance_ratio::Real = 5: If the ratio between a tick and its left and right neighbour  is greater than max_distance_ratio, additional ticks are added between the ticks that are  further apart. This prevents the ticks from being too unevenly spaced.\nadd_ticks_between_important_ticks::Bool = true: If set to true, additional points   will be added in between the important points obtained from sampling the objects of the   simulation. If some objects are too close together, this will ensure a noticeable gap   between them in the calculation of potentials and fields.\nfor_weighting_potential::Bool = false: Grid will be optimized for the calculation of    an ElectricPotential if set to true, and of a WeightingPotential   if set to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ImpurityScale","page":"API","title":"SolidStateDetectors.ImpurityScale","text":"struct ImpurityScale{T, N, S, AT} <: AbstractArray{T, N}\n\nImpurity scalar field of the simulation. It is kinda an alpha map for the impurity density of semiconductors. It can takes values between 0 and 1:\n\n1: The impurity density has its full value. For grid points in depleted region of the semiconductor. \n]0,1[: The impurity density is scaled down but not zero. For grid points at the edge of the depleted region which are partially depleted.\n0: The impurity density is set to 0. For grid points in undepleted regions of the semiconductor.\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the impurity scale at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the impurity scale is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearChargeDensity","page":"API","title":"SolidStateDetectors.LinearChargeDensity","text":"struct LinearChargeDensity{T <: SSDFloat} <: AbstractChargeDensity{T}\n\nCharge density model which assumes a linear gradient in charge density in each dimension of a Cartesian coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: charge density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in x, y and z direction.\n\nDefinition in Configuration File\n\nA LinearChargeDensity is defined in the configuration file through the field charge_density  (of a passive or surrounding) with name: linear and optional fields x, y and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a linear charge density looks like this:\n\ncharge_density:\n  name: cylindrical\n  x:  # impurity profile with linear gradient in x\n    init: 1.0e-10     # C/m³\n    gradient: 1.0e-11 # C/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearImpurityDensity","page":"API","title":"SolidStateDetectors.LinearImpurityDensity","text":"struct LinearImpurityDensity{T <: SSDFloat} <: AbstractImpurityDensity{T}\n\nImpurity density model which assumes a linear gradient in impurity density in each dimension of a Cartesian coordinate system.\n\nFields\n\noffsets::NTuple{3,T}: impurity density values at the origin of each dimension.\ngradients::NTuple{3,T}: linear slopes in x, y and z direction.\n\nDefinition in Configuration File\n\nA LinearImpurityDensity is defined in the configuration file through the field impurity_density  (of a passive or surrounding) with name: linear and optional fields x, y and z that can each contain init for initial values at 0 and gradient for gradients in that dimension.\n\nAn example definition of a linear impurity density looks like this:\n\nimpurity_density:\n  name: cylindrical\n  x:  # impurity profile with linear gradient in x\n    init: 1.0e10     # 1/m³\n    gradient: 1.0e11 # 1/m⁴\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.NBodyChargeCloud","page":"API","title":"SolidStateDetectors.NBodyChargeCloud","text":"struct NBodyChargeCloud{T, N, SH} <: AbstractChargeCloud\n\nStruct which defines a charge cloud consisting of multiple point-like charge carriers, initially distributed around a given center.\n\nParametric Types\n\nT: Precision type.\nN: Number of shells.\nSH: Geometry of the shells.\n\nFields\n\nlocations::Vector{CartesianPoint{T}}: Positions of the charge carriers that are part of the charge cloud.\nenergies::Vector{T}: Energies of the respective charge carriers, in the same order as locations.\nshell_structure::SH: Initial geometry of the charge carriers around the center point, relevant for plotting.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{<:var\"#s37\"}, var\"#s37\"} where var\"#s37\"<:Real, Integer}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{<:var\"#s37\"}, var\"#s37\"} where var\"#s37\"<:Real, Integer, Type{PT}}} where {T, PT<:SolidStateDetectors.ParticleType}","page":"API","title":"SolidStateDetectors.NBodyChargeCloud","text":"NBodyChargeCloud(center::CartesianPoint{T}, energy::T, N::Integer, particle_type::Type{PT} = Gamma; kwargs...)\n\nReturns an NBodyChargeCloud for a given energy deposition at a position that defines the center of the charge cloud, given by a center charge surrounded by shells of approximately N point charges equally distributed on the surface of a sphere. Find the algorithm to create the shells here.\n\nArguments\n\ncenter::CartesianPoint{T}: Center position of the NBodyChargeCloud.\nenergy::RealQuantity: Deposited energy with units. If no units are given, the value is parsed in units of eV.\nN::Integer: Approximate number of charges in the NBodyChargeCloud (might vary by around 1%).\nparticle_type: ParticleType of the particle that deposited the energy. Default is Gamma.\n\nKeywords\n\nradius::T: Estimate for the radius of the NBodyChargeCloud. Default is determined from particle_type via radius_guess.\nnumber_of_shells::Int: Number of shells around the center point. Default is 2.\n\nExample\n\ncenter = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nNBodyChargeCloud(center, energy, 200, number_of_shells = 3)\n\nnote: Note\nUsing values with units for energy requires the package Unitful.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{<:var\"#s37\"}, var\"#s37\"} where var\"#s37\"<:Real}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{<:var\"#s37\"}, var\"#s37\"} where var\"#s37\"<:Real, Type{PT}}} where {T, PT<:SolidStateDetectors.ParticleType}","page":"API","title":"SolidStateDetectors.NBodyChargeCloud","text":"NBodyChargeCloud(center::CartesianPoint{T}, energy::T, particle_type::Type{PT} = Gamma; kwargs...)\n\nReturns an NBodyChargeCloud for a given energy deposition at a position that defines the center of the charge cloud, given by a center charge surrounded by shells consisting of platonic solids.\n\nArguments\n\ncenter::CartesianPoint{T}: Center position of the NBodyChargeCloud.\nenergy::RealQuantity: Deposited energy with units. If no units are given, the value is parsed in units of eV.\nparticle_type: ParticleType of the particle that deposited the energy. Default is Gamma.\n\nKeywords\n\nradius::T: Estimate for the radius of the NBodyChargeCloud. Default is determined from particle_type via radius_guess.\nnumber_of_shells::Int: Number of shells around the center point. Default is 2.\nshell_structure: Geometry with which the charges are distributed in the shells. Default is Dodecahedron.\n\nExample\n\ncenter = CartesianPoint{T}([0,0,0])\nenergy = 1460u\"keV\"\nNBodyChargeCloud(center, energy, number_of_shells = 3, shell_structure = SolidStateDetectors.Icosahedron)\n\nnote: Note\nUsing values with units for energy requires the package Unitful.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ParticleType","page":"API","title":"SolidStateDetectors.ParticleType","text":"abstract type ParticleType\n\nType of a particle that deposits energy in a Semiconductor. Currently defined are Alpha, Beta and Gamma.\n\nParticleType is used to determine the radius of an NBodyChargeCloud, where the default radius for Alpha is 0.1mm and the default radius for Beta and Gamma is 0.5mm.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Passive","page":"API","title":"SolidStateDetectors.Passive","text":"struct Passive{T,G,MT,CDM} <: AbstractPassive{T}\n\nPassive object, assigned to a SolidStateDetector.\n\nFor the calculation of the ElectricPotential and WeightingPotential,  passives can be fixed to a constant potential. They can additionally have a charge density  profile that has an influence on the ElectricPotential.\n\nParametric types\n\nT: Precision type.\nG: Type of geometry.\nMT: Type of material.\nCDM: Type of charge_density_model.\n\nFields\n\nname::String: Custom name for the passive, relevant for plotting.\nid::Int: Unique id that will unambiguously identify the passive.\npotential::T: Potential (in V) to which the passive will be fixed during the calculation of the electric potential.   For floating passives, the potential value is NaN.\ntemperature::T: Temperature (in K) of the passive.\nmaterial::MT: Material of the passive.\ncharge_density_model::CDM: Charge density model for the points inside the passive.\ngeometry::G: Geometry of the passive, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA Passive is defined through an entry in the passives array of a detector or an entry in the surroundings array in the configuration file. It needs material and geometry and can optionally be given a name, id, potential, temperature and charge_density.\n\nAn example definition of passives looks like this:\n\npassives:\n  - name: Passivated Surface\n    material: HPGe\n    charge_density: # ...\n    geometry: # ...\n  - name: Cryostat\n    id: 3\n    potential: 0\n    temperature: 293K\n    material: Al\n    geometry: # ...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointCharge","page":"API","title":"SolidStateDetectors.PointCharge","text":"struct PointCharge{T} <: AbstractChargeCloud\n\nStruct which defines a single point-like charge carrier.\n\nFields\n\nlocations::SVector{1, CartesianPoint{T}}: Position of the charge carrier, saved as single entry of a Vector.\n\nExample\n\ncenter = CartesianPoint{T}(0,0,0)\npc = PointCharge(center) # Constructor: creates a PointCharge around (0,0,0)\npc.locations             # Array that only contains the center point\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointType","page":"API","title":"SolidStateDetectors.PointType","text":"const PointType = UInt8\n\nStores certain information about a grid point via bit-flags. \n\nRight now, there are:\n\nconst update_bit      = 0x01\nconst undepleted_bit  = 0x02\nconst pn_junction_bit = 0x04\nconst bulk_bit     = 0x08\n\nExamples\n\nHow to get information out of a PointType variable point_type:\n\npoint_type & update_bit == 0 -> do not update this point (for fixed points)     \npoint_type & update_bit >  0 -> do update this point    \npoint_type & undepleted_bit > 0 -> this point is undepleted\npoint_type & pn_junction_bit > 0 -> this point belongs to the solid state detector, meaning that it is in the volume of the n-type or p-type material.\npoint_type & bulk_bit > 0 -> this point is only surrounded by points marked as pn_junction_bit\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes","page":"API","title":"SolidStateDetectors.PointTypes","text":"struct PointTypes{T, N, S, AT} <: AbstractArray{T, N}\n\nInformation about the grid points used to calculate the ElectricPotential stored via bit-flags. Data is stored as PointType which is an UInt8.\n\nParametric types\n\nT: Element type of grid.axes.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{PointType, N}: Array containing the point type values at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the point types are determined.\n\nSee also PointType.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PotentialCalculationSetup","page":"API","title":"SolidStateDetectors.PotentialCalculationSetup","text":"struct PotentialCalculationSetup\n\nPotentialCalculationSetup holds the grid, fields and certain precalculated fixed parameters for the field calculation. This struct will be calculated after each refinement as is depends on the grid. \n\ngrid: The 3-dimensional grid, either Cartesian or cylindrical, on which the field will be calculated. \n\nThe fields:\n\npotential: This is the 4-dimensional array of the extended 3D potential array. \n\nThe fourth dimensions comes from the red-black (even-odd) division in order to parallelize the field calculation.  Extended means that the grid holds one additional tick at both sides of all axes necessary for boundary handling (reflecting, fixed, ...) at the ends of the grid.\n\npoint_types: Also a 4-dimensional array. Same structure as the potential-array.\nvolume_weights: Also a 4-dimensional array. Same structure as the potential-array.\nq_eff_imp: Also a 4-dimensional array. Same structure as the potential-array.\nimp_scale: Also a 4-dimensional array. Same structure as the potential-array.\nq_eff_fix: Also a 4-dimensional array. Same structure as the potential-array.\nϵ_r: Normal 3-dimensional array! In order to calculate the final 6 weights for each grid point in the SOR, \n\nthe eight values of the dielectric permittivity (of each octant) around the grid point needs to be loaded.  Here not special division is possible for the red-black (even-odd) division. \n\nPrecalculated parameters:\n\ngeom_weights: The parts of the calculation of the six weights in the SOR can be precalculated. Those are stored here for each axis/dimension.\nsor_const: Vector holding the SOR constants. In the cartesian case only the first entry is used. As the optimal value for the SOR constant\n\ndepends on the grid, the constant is linear increased and the array holds the respective value for each radial axis tick. \n\nbias_voltage: maximum_applied_potential - minimum_applied_potential. Used for depletion handling, but might be obsolete by now. \nmaximum_applied_potential: Used for depletion handling, but might be obsolete by now. \nminimum_applied_potential: Used for depletion handling, but might be obsolete by now. \ngrid_boundary_factors: Used in the application of boundary conditions in the field calculation for decaying (infinite) boundary conditions \n\nto approximate the decay of the potential (depending on the grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SSDInterval","page":"API","title":"SolidStateDetectors.SSDInterval","text":"struct SSDInterval{T <: SSDFloat, L, R, BL, BR} <: IntervalSets.TypedEndpointsInterval{L,R,T}\n\nInterval containing boundary conditions of left and right boundary as parametric type (BL and BR).\n\nParametric types\n\nT: Precision type.\nL: Boundary type of the left endpoint.\nR: Boundary type of the right endpoint.\nBL: Boundary condition at the left endpoint.\nBR: Boundary condition at the right endpoint.\n\nThe boundary types of an SSDInterval can be L, R ∈ {:closed, :open}.\n\nThe boundary conditions of an SSDInterval can be BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}.\n\nFields\n\nleft::T: Value of the left endpoint.\nright::T: Value of the right endpoint.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Semiconductor","page":"API","title":"SolidStateDetectors.Semiconductor","text":"struct Semiconductor{T,G,MT,CDM,IDM} <: AbstractSemiconductor{T}\n\nSemiconductor bulk of a SolidStateDetector.\n\nThis is the volume in which electrons and holes will drift during the signal development.\n\nParametric types\n\nT: Precision type.\nG: Type of geometry.\nMT: Type of material.\nCDM: Type of charge_drift_model.\nIDM: Type of impurity_density_model.\n\nFields\n\ntemperature::T: Temperature (in K) of the semiconductor.\nmaterial::MT: Material of the semiconductor.\nimpurity_density_model::IDM: Impurity density model for the points inside the semiconductor.\ncharge_drift_model::CDM: Model that describes the drift of electrons and holes inside the semiconductor.\ngeometry::G: Geometry of the semiconductor, see Constructive Solid Geometry (CSG).\n\nDefinition in Configuration File\n\nA Semiconductor is defined through the semiconductor field of a detector. It needs material and geometry, and can optionally be given a temperature, impurity_density and charge_drift_model.\n\nAn example definition of a semiconductor looks like this:\n\nsemiconductor:\n  material: HPGe\n  temperature: 78\n  impurity_density: # ...\n  charge_drift_model: # ...\n  geometry: # ...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Simulation","page":"API","title":"SolidStateDetectors.Simulation","text":"mutable struct Simulation{T <: SSDFloat, CS <: AbstractCoordinateSystem} <: AbstractSimulation{T}\n\nCollection of all parts of a simulation of a SolidStateDetector.\n\nParametric types\n\nT: Precision type.\nCS: Coordinate system (Cartesian or Cylindrical).\n\nFields\n\nconfig_dict::Dict: Dictionary (parsed configuration file) which initialized the simulation.\ninput_units::NamedTuple: Units with which the config_dict should be parsed.\nmedium::NamedTuple: Medium of the world.\ndetector::Union{SolidStateDetector{T}, Missing}: The SolidStateDetector of the simulation.\nworld::World{T, 3, CS}: The World of the simulation.\nq_eff_imp::Union{EffectiveChargeDensity{T}, Missing}: Effective charge resulting from the impurites in the Semiconductor of the detector.\nimp_scale::Union{ImpurityScale{T}, Missing}: Scale (alpha channel) of the impurity density (for depletion handling).  \nq_eff_fix::Union{EffectiveChargeDensity{T}, Missing}: Fixed charge resulting from fixed space charges in Passive of the detector.\nϵ_r::Union{DielectricDistribution{T}, Missing}: The DielectricDistribution of the simulation.\npoint_types::Union{PointTypes{T}, Missing}: The PointTypes of the simulation.\nelectric_potential::Union{ElectricPotential{T}, Missing}: The ElectricPotential of the simulation.\nweighting_potentials::Vector{Any}: The WeightingPotential for each Contact of the detector in the simulation.\nelectric_field::Union{ElectricField{T}, Missing}: The ElectricField of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.SolidStateDetector","page":"API","title":"SolidStateDetectors.SolidStateDetector","text":"struct SolidStateDetector{T,SC,CT,PT,VDM} <: AbstractConfig{T}\n\nStruct to describe all parts of a solid state detector, i.e. the Semiconductor, a set of Contact and (optionally) Passive and virtual drift volumes.\n\nThe properties of the parts (charge densities, fixed potentials, relative permittivity of the materials) will be used as input to the calculation of ElectricPotential and  WeightingPotential in the Simulation.\n\nParametric types\n\nT: Precision type.\nSC: Type of the semiconductor.\nCT: Type of the contacts.\nPT: Type of the passives.\nVDM: Type of the virtual_drift_volumes.\n\nFields\n\nname::String: Name of the detector.\nsemiconductor::SC: Semiconductor of the detector. \ncontacts::CT: Vector of Contact of the detector. \npassives::PT: Vector of Passive objects, e.g. holding structures around the detector. \nvirtual_drift_volumes::VDM: Vector of virtual drift volumes in which the drift can be modulated   by user-defined methods for modulate_driftvector, e.g. DeadVolume.\n\nSee also Semiconductor, Contact, Passive and DeadVolume.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.VelocityParameters","page":"API","title":"SolidStateDetectors.VelocityParameters","text":"struct VelocityParameters{T <: SSDFloat}\n\nValues needed to parametrize the longitudinal drift velocity of electrons or hole along a crystal axis as a function of the electric field strength.\n\nBackground information\n\nThe parameterization for the longitudinal drift velocity, v_l, as a function of the electric  field strength, E, was proposed by D.M. Caughey and R.E. Thomas and later expanded by L. Mihailescu et al.:\n\nv_l = fracmu_0 E(1 + (EE_0 )^beta)^1 beta - mu_n E\n\nwith the four parameters, mu_0, beta, E_0 and mu_n, which are different for electrons and holes and for the different crystal axes.\n\nnote: Note\nThe parameter mu_n accounts for the Gunn effects for electrons and should be 0 for holes.\n\nFields\n\nmu0::T: Parameter mu_0 in the parameterization shown above.\nbeta::T: Parameter beta in the parameterization shown above.\nE0::T: Parameter E_0 in the parameterization shown above.\nmun::T: Parameter mu_n in the parameterization shown above.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.WeightingPotential","page":"API","title":"SolidStateDetectors.WeightingPotential","text":"struct WeightingPotential{T, N, S, AT} <: AbstractArray{T, N}\n\nWeighting potential for a given Contact which is a unitless potential.\n\nParametric types\n\nT: Element type of data.\nN: Dimension of the grid and data array.  \nS: Coordinate system (Cartesian or Cylindrical).\nAT: Axes type.  \n\nFields\n\ndata::Array{T, N}: Array containing the values of the weighting potential at the discrete points of the grid.\ngrid::Grid{T, N, S, AT}: Grid defining the discrete points for which the weighting potential is determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.World","page":"API","title":"SolidStateDetectors.World","text":"struct World{T <: SSDFloat, N, S} <: AbstractWorld{T, N}\n\nDefinition of the finite volume on which a Simulation is performed.\n\nParametric types\n\nT: Precision type.\nN: Dimensions of the world.\nS: Coordinate system (Cartesian or Cylindrical).\n\nFields\n\nintervals::NTuple{N, SSDInterval{T}}: A set of SSDInterval defining the dimensions of the world.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.add_baseline_and_extend_tail-Union{Tuple{UV}, Tuple{TV}, Tuple{U}, Tuple{T}, Tuple{RadiationDetectorSignals.RDWaveform{T, U, TV, UV}, Int64, Int64}} where {T, U, TV, UV}","page":"API","title":"SolidStateDetectors.add_baseline_and_extend_tail","text":"add_baseline_and_extend_tail(wv::RadiationDetectorSignals.RDWaveform{T,U,TV,UV}, n_baseline_samples::Int, total_waveform_length::Int) where {T,U,TV,UV}\n\nAdds a zero-valued baseline in front of the waveform wv and extends (or cuts off) the waveform at the end with the last value of wv. A waveform of length total_waveform_length is returned.\n\nArguments\n\nwv::RadiationDetectorSignals.RDWaveform{T,U,TV,UV}: A waveform (signal over time).\nn_baseline_samples::Int: Number of samples added in front of the waveform with values 0. \ntotal_waveform_length::Int: Number of samples of the extended waveform which is returned.\n\nExamples\n\nadd_baseline_and_extend_tail(wv, 1000, 5000)\n\nnote: Note\nThis functions assumes that the time steps between the samples of the input waveform wv are the same. Thus, that the input waveform is sampled with a fixed frequency. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.add_fano_noise","page":"API","title":"SolidStateDetectors.add_fano_noise","text":"add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity\n\nAdds Fano noise to an energy deposition E_dep, assuming a detector material ionisation energy E_ionisation and a Fano factor f_fano.\n\nArguments\n\nE_dep::RealQuantity: Energy deposited in a semiconductor material.\nE_ionisation: Energy needed to create one electron-hole-pair in the semiconductor material.\nf_fano: Fano factor of the material.\n\nExample\n\nadd_fano_noise(100u\"keV\", 2.95u\"eV\", 0.129)\n\nSome material properties are stored in SolidStateDetectors.material_properties and can be used here:\n\nmaterial = SolidStateDetectors.material_properties[:HPGe]\nadd_fano_noise(100u\"keV\", material.E_ionisation, material.f_fano)\n\nnote: Note\nUsing values with units for E_dep or E_ionisation requires the package Unitful.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Grid{T}}} where {T<:Union{Float16, Float32, Float64}, CS}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim);\n        not_only_paint_contacts::Bool = true, paint_contacts::Bool = true)::Nothing where {T <: SSDFloat}\n\nApplies the initial state for the calculation of the ElectricPotential. It overwrites sim.electric_potential, sim.q_eff_imp, sim.q_eff_fix, sim.ϵ and sim.point_types with the material properties and fixed potentials defined in sim.detector.\n\nArguments\n\nsim::Simulation{T}: Simulation for which the initial state should be applied.\ngrid::Grid{T}: Grid to apply the initial state on. If no grid is given,    a default Grid is determined from sim.\n\nKeywords\n\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\n\nExamples\n\napply_initial_state!(sim, ElectricPotential, paint_contacts = false)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Grid{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.apply_initial_state!","text":"apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim))::Nothing\n\nApplies the initial state for the calculation of the WeightingPotential for the [Contact}(@ref) with the id contact_id. It overwrites sim.weighting_potentials[contact_id] with the fixed values on the [Contact}(@ref).\n\nArguments\n\nsim::Simulation{T}: Simulation for which the initial state should be applied.\ncontact_id::Int: The id of the Contact for which the WeightingPotential is to be calculated.\ngrid::Grid{T}: Grid to apply the initial state on. If no grid is given,    a default Grid is determined from sim.\n\nKeywords\n\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\n\nExamples\n\napply_initial_state!(sim, WeightingPotential, 1) # =>  applies initial state for weighting potential of contact with id 1\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calc_new_potential_by_neighbors_3D-Union{Tuple{T}, Tuple{T, NTuple{6, T}, NTuple{6, T}}} where T","page":"API","title":"SolidStateDetectors.calc_new_potential_by_neighbors_3D","text":"function calc_new_potential_by_neighbors_3D(\n    volume_weight::T,\n    weights::NTuple{6,T},\n    neighbor_potentials::NTuple{6,T},\n) where {T}\n\nCalculates and returns the new potential value of a grid point given the potential values of the six neighbouring grid points (2 in each dimension) neighbor_potentials, the weights corresponding to those six potentials of the neighboring grid points, the weight due to the volume of the grid point itself (the voxel around it).\n\nFor more detailed information see Chapter 5.2.2 \"Calculation of the Electric Potential\" Eqs. 5.31 to 5.37 in https://mediatum.ub.tum.de/doc/1620954/1620954.pdf.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_capacitance_matrix-Union{Tuple{Simulation{T}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.calculate_capacitance_matrix","text":"calculate_capacitance_matrix(sim::Simulation{T}; consider_multiplicity::Bool = true) where {T}\n\nCalculates the Maxwell Capacitance N×N-Matrix in units of pF, where N is the number of contacts of sim.detector. The individual elements, c_ij, are calculated via  calculate_mutual_capacitance(sim::Simulation, (i,j)::Tuple{Int,Int}). The matrix should be symmetric. The difference of C[i,j] and C[j,i] are due  to numerical precision in the integration due to the different grids of the two weighting potentials.\n\nArguments\n\nsim::Simulation: Simulation for which the capacitance matrix is calculated.\n\nKeywords\n\nconsider_multiplicity::Bool = true: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the x-axis going from [0, x_max] and the y-axis going from [0, y_max] the multiplicity is 4   and, if consider_multiplicity == true, the returned value is already multiplied by 4.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_field!-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}} where {T<:Union{Float16, Float32, Float64}, CS}","page":"API","title":"SolidStateDetectors.calculate_electric_field!","text":"calculate_electric_field!(sim::Simulation{T}; n_points_in_φ::Union{Missing, Int} = missing)::Nothing\n\nCalculates the ElectricField from the ElectricPotential stored in sim.electric_potential and stores it in sim.electric_field. \n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_potential has already been calculated.\n\nKeywords\n\nn_points_in_φ::Union{Missing, Int}: For a 2D ElectricPotential (cylindrical coordinates and symmetric in φ), sim.electric_potential   is extended to n_points_in_φ \"layers\" in φ in order to calculate a 3D [ElectricField]. If n_points_in_φ is missing, the    default value is 36.\n\nExamples\n\ncalculate_electric_field!(sim, n_points_in_φ = 32)\n\nnote: Note\nThis method only works if sim.electric_potential has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_electric_potential!","text":"calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing\n\nCalculates the ElectricPotential for a given Simulation sim on an adaptive grid through successive over relaxation and stores it in sim.electric_potential.\n\nThere are several keyword arguments which can be used to tune the calculation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which the ElectricPotential is calculated.\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 1e-7 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions.\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension.\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ngrid::Grid: Initial grid used to start the simulation. Default is Grid(sim).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Union{Int, Vector{Int}}: If <:Int, use_nthreads defines the maximum number of threads to be used in the computation.    Fewer threads might be used depending on the current grid size due to threading overhead. Default is Base.Threads.nthreads().   If <:Vector{Int}, use_nthreads[i] defines the number of threads used for each grid (refinement) stage of the field simulation.   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\ncalculate_electric_potential!(sim, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_mutual_capacitance-Tuple{Simulation, Tuple{Int64, Int64}}","page":"API","title":"SolidStateDetectors.calculate_mutual_capacitance","text":"calculate_mutual_capacitance(sim::Simulation, ij::Tuple{Int, Int}; consider_multiplicity::Bool = true)\n\nReturns the mutual capacitance between the contacts with ID i = ij[1] and j = ij[2]. It is calculated via the weighting potentials of the contacts, Phi_i^w(vecr) and Phi_j^w(vecr):\n\nc_ij = epsilon_0 int_World nabla Phi_i^w(vecr) ϵ_r(vecr) nabla Phi_j^w(vecr) dvecr\n\nnote: Note\nThese are elements of the Mawell Capcitance Matrix. Look up Capacitances for more information.\n\nnote: Note\nThe electric potential as well as the two weighting potentials of both contacts have to be calculated.\n\nArguments\n\nsim::Simulation: Simulation for which the capacitance matrix is calculated.\nij::Tuple{Int,Int}: Tuple of indices of the contacts for which the capacitance should be calculated. \n\nKeywords\n\nconsider_multiplicity::Bool = true: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the x-axis going from [0, x_max] and the y-axis going from [0, y_max] the multiplicity is 4   and, if consider_multiplicity == true, the returned value is already multiplied by 4.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_stored_energy-Tuple{Simulation}","page":"API","title":"SolidStateDetectors.calculate_stored_energy","text":"calculate_stored_energy(sim::Simulation; consider_multiplicity::Bool = true)\n\nCalculates and returns the energy stored in the ElectricField of a  SolidStateDetector in a given Simulation in units of J.\n\nArguments\n\nsim::Simulation{T}: Simulation with sim.detector for which the stored energy is calculated.\n\nKeywords\n\nconsider_multiplicity::Bool = true: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the x-axis going from [0, x_max] and the y-axis going from [0, y_max] the multiplicity is 4   and, if consider_multiplicity == true, the returned value is already multiplied by 4.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.calculate_weighting_potential!","text":"calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing\n\nCalculates the WeightingPotential for a Contact with contact_id  given Simulation sim on an adaptive grid through successive over relaxation  and stores it in sim.weighting_potentials[contact_id].\n\nThere are several keyword arguments which can be used to tune the calculation.\n\nKeywords\n\nconvergence_limit::Real: convergence_limit sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 1e-7.\nrefinement_limits: Defines the maximum relative allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions.\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension.\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ngrid::Grid: Initial grid used to start the simulation. Default is Grid(sim).\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false. This is an experimental feature:   In undepleted regions (determined in calculate_electric_potential!(sim; depletion_handling = true)), the dielectric permittivity   of the semiconductor is scaled up to mimic conductive behavior. The scale factor can be tuned via    the function scaling_factor_for_permittivity_in_undepleted_region.\nuse_nthreads::Union{Int, Vector{Int}}: If <:Int, use_nthreads defines the maximum number of threads to be used in the computation.    Fewer threads might be used depending on the current grid size due to threading overhead. Default is Base.Threads.nthreads().   If <:Vector{Int}, use_nthreads[i] defines the number of threads used for each grid (refinement) stage of the field simulation.   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\ncalculate_weighting_potential!(sim, 1, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.drift_charges!","text":"drift_charges!(evt::Event{T}, sim::Simulation{T}; kwargs...)::Nothing where {T <: SSDFloat}\n\nCalculates the electron and hole drift paths for the given Event and Simulation     and stores them in evt.drift_paths.\n\nArguments\n\nevt::Event{T}: Event for which the charges should be drifted.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in evt should drift.\n\nKeywords\n\nmax_nsteps::Int = 1000: Maximum number of steps in the drift of each hit. \nΔt::RealQuantity = 5u\"ns\": Time step used for the drift.\ndiffusion::Bool = false: Activate or deactive diffusion of charge carriers via random walk.\nself_repulsion::Bool = false: Activate or deactive self-repulsion of charge carriers of the same type.\nverbose = true: Activate or deactivate additional info output.\n\nExample\n\ndrift_charges!(evt, sim, Δt = 1u\"ns\", verbose = false)\n\nnote: Note\nUsing values with units for Δt requires the package Unitful.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.estimate_depletion_voltage-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, NamedTuple}} where {T<:AbstractFloat, CS}","page":"API","title":"SolidStateDetectors.estimate_depletion_voltage","text":"estimate_depletion_voltage( sim::Simulation{T}, contact_id::Int, field_sim_settings = (verbose = true,))::T\n\nEstimates the full depletion voltage, UD, of a detector in a given Simulation.\nThat is is the voltage to fully deplete the detector.\nThis is done by calculating two electric potentials with different boundary conditions:\n    1) Only the electric potential coming from the impurity density alone: `EPi`\n    2) The electric potential without an impurity density: EP_0\nThen, the superpostion EP_i + U_D * EP_0 is iteratively solved over all grid points\nto determine U_D which is the voltage where the gradient of the suposition field, the electric field,\nbecomes nowhere 0 anywhere inside the semiconductor. \n\nArguments\n\nsim::Simulation{T}: Simulation of the detector for which the depletion voltage should be determined.\n\nKeywords\n\nbias_voltage_contact_id::Int: The id of the Contact at which the potential is applied.\n\n\nAs default it is tried to determine this automatically via determine_bias_voltage_contact_id(sim.detector).\n\nfield_sim_settings::NamedTuple = (verbose = false,): NamedTuple of simulation settings merged with the\n\n\ndefault settings (listed underneath) and passed further to the field calculation functions.\n\nThe following default settings are used for the field simulations performed in this function:\n\n(\n    convergence_limit = 1e-7,\n    max_tick_distance = 2.0u\"mm\",\n    refinement_limits = [0.2, 0.1, 0.05, 0.025, 0.01], \n    sor_consts = (1.0, 1.0),\n    use_nthreads = max_threads > 16 ? 16 : max_threads,\n    n_iterations_between_checks = 20, \n    depletion_handling = false\n)\n\nExample\n\nusing SolidStateDetectors\nsim = Simulation(SSD_examples[:InvertedCoax])\nestimate_depletion_voltage(sim, field_sim_settings = (verbose = true,))\n\nnote: Note\nThe accuracy of the result depends on the precision of the initial simulation.\n\nnote: Note\nThis function performs two 2D or 3D, depending on sim, field calculations.\nThus, keep in mind that is might consume some memory. \n\nSee also is_depleted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_active_volume","text":"get_active_volume(point_types::PointTypes{T}) where {T}\n\nReturns an approximation of the active volume of the detector by summing up the cell volumes of all cells marked as depleted.\n\nArguments\n\npoint_types::PointTypes{T}: Point types of a Simulation.\n\nExamples\n\nget_active_volume(sim.point_types)\n\nnote: Note\nOnly φ-symmetries are taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_charge_density","page":"API","title":"SolidStateDetectors.get_charge_density","text":"get_charge_density(cd::AbstractChargeDensity, pt::AbstractCoordinatePoint)\n\nReturns the charge density at a given point, pt, based on the charge density model cd.\n\nArguments\n\ncd::AbstractChargeDensity: The AbstractChargeDensity defining the charge density inside a Passive.\npt::AbstractCoordinatePoint: The point at which cd is to be evaluated.\n\nnote: Note\nThe value returned by get_charge_density is in units of C/m³ (SI units).\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.get_electron_and_hole_contribution-Union{Tuple{S}, Tuple{T}, Tuple{Event{T}, Simulation{T, S}, Int64}} where {T<:Union{Float16, Float32, Float64}, S}","page":"API","title":"SolidStateDetectors.get_electron_and_hole_contribution","text":"get_electron_and_hole_contribution(evt::Event{T}, sim::Simulation{T}, contact_id::Int)\n\nReturns the electron and hole contribution to the waveform of a Contact with a given contact_id of an Event as a NamedTuple with two entries:  electron_contribution and hole_contribution.\n\nArguments\n\nevt::Event{T}: Event in which the charges have already been drifted.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in evt were drifted.\ncontact_id::Int: The id of the Contact for which the waveform should be split into electron and hole contribution.\n\nExample\n\nusing Plots\nusing SolidStateDetector\nT = Float32\n\nsimulation = Simulation{T}(SSD_examples[:InvertedCoax])\nsimulate!(simulation)\nevent = Event([CartesianPoint{T}(0.02,0.01,0.05)])\nsimulate!(event, simulation)\n\ncontact_id = 1\nwf = get_electron_and_hole_contribution(evt, sim, contact_id)\n\nnote: Note\nThe drift paths in evt need to be calculated using drift_charges! before calling this function.\n\nSee also plot_electron_and_hole_contribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_impurity_density","page":"API","title":"SolidStateDetectors.get_impurity_density","text":"get_impurity_density(id::AbstractImpurityDensity, pt::AbstractCoordinatePoint)\n\nReturns the impurity density at a given point, pt, based on the impurity density model id.\n\nArguments\n\nid::AbstractImpurityDensity: The AbstractImpurityDensity defining the impurity density inside a Semiconductor.\npt::AbstractCoordinatePoint: The point at which id is to be evaluated.\n\nnote: Note\nThe value returned by get_impurity_density is in units of 1/m³ (SI Units).\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.get_path_to_example_config_files-Tuple{}","page":"API","title":"SolidStateDetectors.get_path_to_example_config_files","text":"get_path_to_example_config_files()::String\n\nReturns the path to the example detector configuration files provided by the package.\n\nSee also SSD_examples.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_signals!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_signals!","text":"get_signals!(evt::Event{T}, sim::Simulation{T}; Δt::RealQuantity = 5u\"ns\")::Nothing where {T <: SSDFloat}\n\nGenerates the signals/waveforms from the drift paths of an Event for each Contact, for which a WeightingPotential is specified in sim.weighting_potentials.\n\nThe output is stored in evt.waveforms.\n\nArguments\n\nevt::Event{T}: Event for which the waveforms should be generated.\nsim::Simulation{T}: Simulation which defines the setup in which the waveforms are generated.\n\nKeywords\n\nΔt::RealQuantity = 5u\"ns\": Time steps with which the drift paths were calculated.\n\nExample\n\nget_signals!(evt, sim, Δt = 1u\"ns\") # if evt.drift_paths were calculated in time steps of 1ns\n\nnote: Note\nThis method only works if evt.drift_paths has already been calculated and is not missing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_sor_kernel-Tuple{Type{Cylindrical}, Any, Any, Vararg{Any}}","page":"API","title":"SolidStateDetectors.get_sor_kernel","text":"function get_sor_kernel(::Type{S}, args...)\n\nwhere S is either Cartesian or Cylindrical. \n\nDeveloper notes: Currently (February 2022), there are some limitations to the @kernel macro  of the package KernelAbstractions.jl. Especially, regarding usage of dispatch. \n\nThus, we have to write two kernel functions right now for the Cartesian & Cylindrical case: sor_cyl_gpu! and sor_car_gpu!.\n\nInside kernel functions, everything is (and has to be) inlined and we can make use of multiple dispatch.  So in the end we only have to write one function for the kernel, sor_kernel,  which is then inlined inside the two kernel functions.\n\nWe can also use most of the CPU functions with the restriction that all  types have to be independent on the GPU-indices of the kernel.  E.g., making use of i23_is_even_t = Val(iseven(i2 + i3)) and other similar statements is not possible, which are used in the CPU implementation for optimization. On the GPU (currently) those statements have to be calculated and booleans have to be passed. Maybe this will change in the future.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes-Union{Tuple{SolidStateDetectors.ImpurityScale{T, 3}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes","text":"get_ticks_at_positions_of_edge_of_depleted_volumes(impscale::ImpurityScale{T, 3})\n\nThe impurity scale field is analyzed in order to find and return ticks where the gradient is strong, which is the case at the surface of the depleted volume of a semiconductor.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_ticks_at_positions_of_large_gradient-Union{Tuple{ElectricPotential{T, 3}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_ticks_at_positions_of_large_gradient","text":"get_ticks_at_positions_of_large_gradient(epot::ElectricPotential)\n\nThe electric potential is analyzed in order to find and return ticks where the gradient (electric field) is strong (relativ to its maximum).\n\nIn the 1D case of a pn-junction, the electric field strength is the largest at the position of the pn-junction. Thus, this function is likely to return ticks which are located close to the pn-junction of a semiconductor.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.handle_depletion-Union{Tuple{T}, Tuple{T, T, NTuple{6, T}, T, T}} where T","page":"API","title":"SolidStateDetectors.handle_depletion","text":"function handle_depletion(\n    new_potential::T, \n    imp_scale::T,\n    neighbor_potentials::NTuple{6,T}, \n    q_eff_imp::T, \n    volume_weight::T,\n)::Tuple{T, PointType} where {T}\n\nThis function handles the grid points with volumes which are not fully depleted. The decision depends on the proposal for the new potential value, new_potential_proposal,  for the respective grid point in that iteration and the potential values of the neighboring grid points, neighbor_potentials.\n\nIf vmin = minimum(neighbor_potentials) < new_potential_proposal < vmax = maximum(neighbor_potentials) => fully depleted => imp_scale = 1\n\nIf it undershoots or overshoots, the impurity density in the grid point is scaled down via reducing imp_scale ∈ [0, 1] of this grid point.\n\nThis decision is based on the fact that the potential inside a solid-state  detector increases monotonically from a p+-contact towards an n+-contact. Thus, there cannot be local extrema. \n\nnote: Note\nIf a fixed charge impurity is present, e.g. due to a charged passivated surface, this handling is probably not valid anymore as the potential between a  p+-contact towards an n+-contact is not required to change monotonically anymore.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.is_depleted-Tuple{PointTypes}","page":"API","title":"SolidStateDetectors.is_depleted","text":"is_depleted(point_types::PointTypes)::Bool\n\nReturns true if all PointType values of the PointTypes of a Simulation are marked as depleted and false if any point in the PointTypes is marked as undepleted.\n\nIt can be used to determine whether the SolidStateDetector is depleted at the provided bias voltage.\n\nArguments\n\npoint_types::PointTypes: PointTypes of a Simulation.\n\nExamples\n\nis_depleted(sim.point_types)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.merge_second_order_important_ticks-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T","page":"API","title":"SolidStateDetectors.merge_second_order_important_ticks","text":"merge_second_order_important_ticks(imp::Vector{T}, imp_second_order::Vector{T}; min_diff::T = T(1e-6)) where {T}\n\nMerge all elements of the second vector, imp_second_order, into the first vector, imp,  if they are not too close (via min_diff) to elements of the first vector. Returns the merged vector sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.parse_config_file-Tuple{AbstractString}","page":"API","title":"SolidStateDetectors.parse_config_file","text":"parse_config_file(filename::AbstractString)::Dict where {T <: SSDFloat}\n\nReads in a configuration file and returns a parsed dictionary which holds all the information specified in the configuration file.\n\nFind detailed information on configuration files in Configuration Files.\n\nArguments\n\nfilename::AbstractString: File name of the configuration file. If the file is not   in the same directory, a path to the file is required.\n\nnote: Note\nCurrently supported formats for the configuration files:     - YAML: filename ends with .yaml.     - JSON: filename ends with .json.     - SigGen: filename ends with .config.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.plot_electron_and_hole_contribution","page":"API","title":"SolidStateDetectors.plot_electron_and_hole_contribution","text":"plot_electron_and_hole_contribution(evt::Event{T}, sim::Simulation{T}, contact_id::Int)\n\nPlots the waveform as well as the electron and hole contribution to the waveform  of a Contact with a given contact_id of an Event.\n\nArguments\n\nevt::Event{T}: Event in which the charges have already been drifted.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in evt were drifted.\ncontact_id::Int: The id of the Contact for which the waveform should be split into electron and hole contribution.\n\nKeywords\n\nn_samples::Int: Number of samples with which the waveforms will be plotted. The default is the number of samples of the original waveform.\n\nExample\n\nusing Plots\nusing SolidStateDetector\nT = Float32\n\nsimulation = Simulation{T}(SSD_examples[:InvertedCoax])\nsimulate!(simulation)\nevent = Event([CartesianPoint{T}(0.02,0.01,0.05)])\nsimulate!(event, simulation)\n\ncontact_id = 1\nplot_electron_and_hole_contribution(evt, sim, contact_id, n_samples = 300)\n\nnote: Note\nThe drift paths in evt need to be calculated using drift_charges! before calling this function.\n\nnote: Note\nThis method requires to load the package Plots.jl.\n\nSee also get_electron_and_hole_contribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.readsiggen-Tuple{String}","page":"API","title":"SolidStateDetectors.readsiggen","text":"readsiggen(file_path::String; T::Type)\n\nReads a SigGen configuration file (ending in .config) in 'file_path' and returns a dictionary of all parameters. Non-existing parameteres are set to 0.\n\nArguments\n\nfile_path::String: File path leading to the SigGen configuration file.\n\nKeywords\n\nT::Type: Type of the parameters in the output dictionary. Default is Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{ElectricPotential}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple, minimum_distances::Tuple, kwargs...)\n\nTakes the current state of sim.electric_potential and refines it with respect to the input arguments max_diffs and minimum_distances by\n\nextending the grid of sim.electric_potential to be a closed grid in all dimensions,\nrefining the axis of the grid based on max_diffs and minimum_distances: Insert new ticks between two existing ticks such that the potential difference between each tick becomes smaller than max_diff[i] (i -> dimension) but that the distances between the ticks stays larger than minimum_distances[i], and\ncreating the new data array for the refined grid and fill it by interpolation of the the initial grid.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_potential will be refined.\nmax_diffs::Tuple{<:Real,<:Real,<:Real}: Maximum potential difference between two discrete ticks of sim.electric_potential.grid after refinement.\nminimum_distances::Tuple{<:Real,<:Real,<:Real}: Minimum distance (in SI Units) between two discrete ticks of sim.electric_potential.grid after refinement.\n\nExamples\n\nSolidStateDetectors.refine!(sim, ElectricPotential, max_diffs = (100, 100, 100), minimum_distances = (0.01, 0.02, 0.01))\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.refine!","text":"refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{<:Real,<:Real,<:Real}, minimum_distances::Tuple{<:Real,<:Real,<:Real})\n\nTakes the current state of sim.weighting_potentials[contact_id] and refines it with respect to the input arguments max_diffs and minimum_distances by\n\nextending the grid of sim.weighting_potentials[contact_id] to be a closed grid in all dimensions,\nrefining the axis of the grid based on max_diffs and minimum_distances: Insert new ticks between two existing ticks such that the potential difference between each tick becomes smaller than max_diff[i] (i -> dimension) but that the distances between the ticks stays larger than minimum_distances[i], and\ncreating the new data array for the refined grid and fill it by interpolation of the the initial grid.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.weighting_potentials[contact_id] will be refined.\ncontact_id::Int: The id of the Contact for which the WeightingPotential is refined.\nmax_diffs::Tuple{<:Real,<:Real,<:Real}: Maximum potential difference between two discrete ticks of sim.weighting_potentials[contact_id].grid after refinement.\nminimum_distances::Tuple{<:Real,<:Real,<:Real}: Minimum distance (in SI Units) between two discrete ticks of sim.weighting_potentials[contact_id].grid after refinement.\n\nExamples\n\nSolidStateDetectors.refine!(sim, WeightingPotential, 1, max_diffs = (0.01, 0.01, 0.01), minimum_distances = (0.01, 0.02, 0.01))\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region","text":"scaling_factor_for_permittivity_in_undepleted_region(sc::Semiconductor{T})::T where {T}\n\nThis function is called in the calculations of weighting potentials of undepleted detectors.  The electric permittivity, ϵ_r, is scaled with this function in areas where the detector is undepleted. A value between [0, +Inf] should be returned. However, Inf should not be returned but instead a very high value should be returned in order to mimic perfect conductivity if that is desired. \n\nArguments\n\nsc::Semiconductor{T}: Semiconductor for which the dielectric permittivity should be scaled up.\n\ndanger: Experimental feature!\nThis feature is under research. The goal is to study the properties / signal response of undepleted detector.  This function is indented to be overwritten by the user to study the response. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.siggentodict-Tuple{Dict}","page":"API","title":"SolidStateDetectors.siggentodict","text":"siggentodict(config::Dict; units::Dict)\n\nConverts the dictionary containing the parameters from a SigGen configuration file to a dictionary that can be understood by SolidStateDetectors.jl. \n\nArguments\n\nconfig::Dict: Dictionary containing SigGen parameters (output of readsiggen()`).\n\nKeywords\n\nunits::Dict: Units used in SigGen configuration file (set to \"mm\", \"deg\", \"V\" and \"K\").   The dictionary needs the fields \"length\", \"angle\", \"potential\" and \"temperature\".\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T<:Union{Float16, Float32, Float64}, S}","page":"API","title":"SolidStateDetectors.simulate!","text":"simulate!( sim::Simulation{T}; kwargs...) where {T, S}\n\nPerforms a full chain simulation for a given Simulation by\n\ncalculating the ElectricPotential,\ncalculating the ElectricField,\ncalculating the WeightingPotential for each Contact.\n\nThe output is stored in sim.electric_potential, sim.electric_field and sim.weighting_potentials, respectively.\n\nThere are several keyword arguments which can be used to tune the simulation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which the full chain simulation should be performed.\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of convergence_limit is 1e-7 (times bias voltage).\nrefinement_limits: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighboured grid points    in each dimension for each refinement.\nrl::Real -> One refinement with rl equal in all 3 dimensions.\nrl::Tuple{<:Real,<:Real,<:Real} -> One refinement with rl set individual for each dimension.\nrl::Vector{<:Real} -> length(l) refinements with rl[i] being the limit for the i-th refinement. \nrl::Vector{<:Real,<:Real,<:Real}} -> length(rl) refinements with rl[i] being the limits for the i-th refinement.\nmin_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is 1e-5 for linear axes and 1e-5 / (0.25 * r_max) for the polar axis in case of a cylindrical grid.\nmax_tick_distance::Tuple{<:Quantity, <:Quantity, <:Quantity}: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.\nmax_distance_ratio::Real: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than max_distance_ratio.       Default is 5.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is 10000. If set to -1 there will be no limit.\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nSee also calculate_electric_potential!, calculate_electric_field! and calculate_weighting_potential!.\n\nExample\n\nsimulate!(sim, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate!","text":"simulate!(evt::Event{T}, sim::Simulation{T}; kwargs...)::Nothing where {T <: SSDFloat}\n\nSimulates the waveforms for the Event for a given Simulation by\n\ncalculating the drift paths of all energy hits, at evt.locations and \ngenerating the waveforms for each Contact, for which a WeightingPotential is specified in sim.weighting_potentials.\n\nThe output is stored in evt.drift_paths and evt.waveforms.\n\nArguments\n\nevt::Event{T}: Event for which the charges should be drifted.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in evt should drift.\n\nKeywords\n\nmax_nsteps::Int = 1000: Maximum number of steps in the drift of each hit. \nΔt::RealQuantity = 5u\"ns\": Time step used for the drift.\ndiffusion::Bool = false: Activate or deactive diffusion of charge carriers via random walk.\nself_repulsion::Bool = false: Activate or deactive self-repulsion of charge carriers of the same type.\nverbose = true: Activate or deactivate additional info output.\n\nExample\n\nsimulate!(evt, sim, Δt = 1u\"ns\", verbose = false)\n\nSee also drift_charges! and get_signals!.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate_waveforms-Union{Tuple{T}, Tuple{TypedTables.Table, Simulation{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate_waveforms","text":"simulate_waveforms( mcevents::TypedTables.Table, sim::Simulation{T}; kwargs...)\nsimulate_waveforms( mcevents::TypedTables.Table, sim::Simulation{T}, output_dir::AbstractString, output_base_name::AbstractString; kwargs...)\n\nSimulates the waveforms for all events defined in mcevents for a given Simulation by\n\ncalculating the drift paths of all energy hits defined in mcevents,\ndetermining the signal (waveforms) for each Contact,   for which a WeightingPotential is specified in sim.weighting_potentials.\n\nArguments\n\nmcevents::TypedTables.Table: Table with information about events in the simulated setup.\nsim::Simulation{T}: Simulation which defines the setup in which the charges in mcevents should drift.\n\nIf HDF5.jl is loaded, this function has additional arguments. \n\nAdditional Arguments (HDF5)\n\noutput_dir::AbstractString: Directory where the HDF5 output file is saved.\noutput_base_name::AbstractString: Basename of the HDF5 output file, default is \"generated_waveforms\".\n\nKeywords\n\nmax_nsteps::Int = 1000: Maximum number of steps in the drift of each hit. \nΔt::RealQuantity = 4u\"ns\": Time step used for the drift.\ndiffusion::Bool = false: Activate or deactive diffusion of charge carriers via random walk.\nself_repulsion::Bool = false: Activate or deactive self-repulsion of charge carriers of the same type.\nnumber_of_carriers::Int = 1: Number of charge carriers to be used in the N-Body simulation of an energy deposition. \nnumber_of_shells::Int = 1: Number of shells around the center point of the energy deposition.\nverbose = false: Activate or deactivate additional info output.\nchunk_n_physics_events::Int = 1000 (HDF5 only): Number of events that should be saved in a single HDF5 output file.\n\nExamples\n\nsimulate_waveforms(mcevents, sim, Δt = 1u\"ns\", verbose = false)\n# => returns the input table `mcevents` with an additional column `waveform` in which the generated waveforms are stored\n\nimport HDF5\nsimulate_waveforms(mcevents, sim, \"output_dir\", \"my_basename\", Δt = 1u\"ns\", verbose = false)\n# => simulates the charge drift and saves the output to \"output_dir/my_basename_evts_xx.h5\"\n\nnote: Note\nThe drift paths are just calculated temporarily and not returned.\n\nnote: Note\nUsing values with units for Δt requires the package Unitful.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ssd_read","page":"API","title":"SolidStateDetectors.ssd_read","text":"ssd_read(filename::AbstractString, ::Type{Simulation})\n\nReads a Simulation from a HDF5 file with a given filename  using LegendHDF5IO.jl.\n\nArguments\n\nfilename::AbstractString: Filename of the HDF5 file.\n\nExample\n\nusing HDF5 \nusing LegendHDF5IO\nusing SolidStateDetectors\nsim = ssd_read(\"example_sim.h5\", Simulation)\n\nnote: Note\nIn order to use this method, the packages HDF5.jl and  LegendHDF5IO.jl have to be loaded before loading SolidStateDetectors.jl.\n\nSee also ssd_write.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.ssd_write","page":"API","title":"SolidStateDetectors.ssd_write","text":"ssd_write(filename::AbstractString, sim::Simulation)\n\nConverts a Simulation to a NamedTuple and writes it to a HDF5 file  with a given filename using LegendHDF5IO.jl.\n\nArguments\n\nfilename::AbstractString: Filename of the HDF5 file.\nsim::Simulation: Simulation that should be written to the HDF5 file.\n\nExample\n\nusing HDF5 \nusing LegendHDF5IO\nusing SolidStateDetectors\nsim = Simulation(SSD_examples[:InvertedCoax])\nsimulate!(sim)\nssd_write(\"example_sim.h5\", sim)\n\nwarn: Warn\nIf a file with filename already exists, it will be overwritten by this method.\n\nnote: Note\nIn order to use this method, the packages HDF5.jl and  LegendHDF5IO.jl have to be loaded before loading SolidStateDetectors.jl.\n\nSee also ssd_read.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.update!-Union{Tuple{_is_weighting_potential}, Tuple{only_2d}, Tuple{depletion_handling_enabled}, Tuple{T}, Tuple{SolidStateDetectors.PotentialCalculationSetup{T, S, N1, DATN1, N2, AT, DATN2, DATPT, DATGW, DATSOR} where {S, N1, DATN1<:AbstractArray{T, N1}, N2, AT, DATN2<:AbstractArray{T, N2}, DATPT<:AbstractArray{UInt8, N2}, DATGW<:AbstractMatrix{T}, DATSOR<:AbstractVector{T}}, Nothing, Any}} where {T, depletion_handling_enabled, only_2d, _is_weighting_potential}","page":"API","title":"SolidStateDetectors.update!","text":"function update!(   \n    pcs::PotentialCalculationSetup{T}; \n    ::Nothing, # these two unused arguments are used such that the method\n    ::Any;     # is similar to the GPU method for it.\n    use_nthreads::Int = Base.Threads.nthreads(), \n    depletion_handling::Val{depletion_handling_enabled} = Val{false}(), \n    is_weighting_potential::Val{_is_weighting_potential} = Val{false}(),\n    only2d::Val{only_2d} = Val{false}()\n\n)::Nothing where {T, depletionhandlingenabled, only2d, _isweighting_potential}\n\nThis function performs one iteration of the SOR. One iteration consists out of 4 steps:\n\n1) Iterate in parallel over all even points and update their potential. \n2) Apply the boundary conditions at the ends of the grid for all even points. \n3) Iterate in parallel over all odd points and update their potential. \n4) Apply the boundary conditions at the ends of the grid for all odd points.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.electric_potential and updates it until it has converged.\n\nThere are several keyword arguments which can be used to tune the simulation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.electric_potential will be updated.\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default is 1e-7.\n\nKeywords\n\nn_iterations_between_checks::Int: Number of iterations between checks. Default is set to 500.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is -1. If set to -1 there will be no limit.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\nSolidStateDetectors.update_till_convergence!(sim, ElectricPotential, 1e-6, depletion_handling = true)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T<:Union{Float16, Float32, Float64}, CS<:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}","page":"API","title":"SolidStateDetectors.update_till_convergence!","text":"update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T\n\nTakes the current state of sim.weighting_potentials[contact_id] and updates it until it has converged.\n\nThere are several keyword arguments which can be used to tune the simulation.\n\nArguments\n\nsim::Simulation{T}: Simulation for which sim.weighting_potentials[contact_id] will be updated.\ncontact_id::Int: The id of the Contact for which the WeightingPotential is to be calculated.\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default is 1e-7.\n\nKeywords\n\nn_iterations_between_checks::Int: Number of iterations between checks. Default is set to 500.\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement.   Default is -1. If set to -1 there will be no limit.\ndepletion_handling::Bool: Enables the handling of undepleted regions. Default is false. This is an experimental feature:   In undepleted regions (determined in calculate_electric_potential!(sim; depletion_handling = true)), the dielectric permittivity   of the semiconductor is scaled up to mimic conductive behavior. The scale factor can be tuned via    the function scaling_factor_for_permittivity_in_undepleted_region.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads().   The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was   started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nnot_only_paint_contacts::Bool = true: Whether to only use the painting algorithm of the surfaces of Contact   without checking if points are actually inside them.   Setting it to false should improve the performance but the points inside of Contact are not fixed anymore.    \npaint_contacts::Bool = true: Enable or disable the painting of the surfaces of the Contact onto the grid.\nsor_consts::Union{<:Real, NTuple{2, <:Real}}: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for r = 0.   Second contains the constant at the outer most grid point in r. A linear scaling is applied in between.   First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].   In case of Cartesian coordinates, only one value is taken.\nverbose::Bool=true: Boolean whether info output is produced or not.\n\nExample\n\nSolidStateDetectors.update_till_convergence!(sim, WeightingPotential, 1, 1e-6, use_nthreads = 4)\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Box","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Box","text":"struct Box{T, CO} <: AbstractVolumePrimitive{T}\n\nVolume primitive describing a three-dimensional Box with its surfaces being parallel to the xy, xy and yz plane.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\n\nFields\n\nhX::T: Half of the width in x dimension (in m).\nhY::T: Half of the width in y dimension (in m).\nhZ::T: Half of the width in z dimension (in m).\norigin::CartesianPoint{T}: The position of the center of the Box.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Box around its origin.\n\nDefinition in Configuration File\n\nA Box is defined in the configuration file as part of the geometry field  of an object through the field box.\n\nExample definitions of a Box looks like this:\n\nbox:\n  widths: [2, 4, 6] # => hX = 1; hY = 2; hZ = 3;\n  origin: [0, 0, 0] # [x, y, z] - Optional; Default: [0, 0, 0]\n  rotate: # Optional; Default: no rotation\n    Z: 0 \n\nThe halfwidths hX, hY and hZ can also be defined directly in the configuration file:\n\nbox:\n  halfwidths: [1, 2, 3] # => hX = 1; hY = 2; hZ = 3;\n\nor\n\nbox:\n  hX: 1\n  hY: 2\n  hZ: 3\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference","text":"struct CSGDifference{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\nA CSGDifference of two geometries a and b is defined as the set of points that are  in a but not in b (a && !b).\n\n(Image: CSGDifference)\n\nnote: Note\nNote that b is treated as open primitive. This means that points which are in  a and on the surface of b will still be in the CSGDifference of a and b.\n\nParametric types\n\nT: Precision type.\nA: Type of geometry a.\nB: Type of geometry b.\n\nFields\n\na::A: Main geometry.\nb::B: Geometry to be subtracted from a.\n\nDefinition in Configuration File\n\nA CSGDifference is defined in the configuration file as part of the geometry field  of an object through the field difference, followed by an array of geometries from which the difference is constructed. The first entry of the array is the main geometry,  from which all following geometry entries are subtracted.\n\nAn example definition of a CSGDifference looks like this:\n\ndifference: # a && !b\n  - tube: # a\n      r: 2\n      h: 1\n  - tube: # b\n      r: 1\n      h: 1.1\n\nnote: Note\nIf more than two geometries are passed, all entries starting from the second will be subtracted from the first.\n\nnote: Note\nKeep in mind that to discard the part of the surface of a which is on the surface of b,  b should be chosen slightly bigger than a.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection","text":"struct CSGIntersection{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\nA CSGIntersection of two geometries a and b is defined as the set of points  that are both in a and in b (a && b).\n\n(Image: CSGIntersection)\n\nParametric types\n\nT: Precision type.\nA: Type of geometry a.\nB: Type of geometry b.\n\nFields\n\na::A: First geometry to build the intersection.\nb::B: Second geometry to build the intersection.\n\nDefinition in Configuration File\n\nA CSGIntersection is defined in the configuration file as part of the geometry field  of an object through the field intersection, followed by an array of geometries from which the intersection is constructed. \n\nAn example definition of a CSGIntersection looks like this:\n\nintersection: # a && b\n  - tube: # a\n      r: 2\n      h: 1\n  - tube: # b\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5\n\nnote: Note\nIf more than two geometries are passed, the intersection is constructed from all of them.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion","text":"struct CSGUnion{T, A <: AbstractGeometry{T}, B <: AbstractGeometry{T}} <: AbstractConstructiveGeometry{T}\n\nA CSGUnion of two geometries a and b is defined as the set of points that are in at least  one of either a or b (a || b).\n\n(Image: CSGUnion)\n\nParametric types\n\nT: Precision type.\nA: Type of geometry a.\nB: Type of geometry b.\n\nFields\n\na::A: First geometry to build the union.\nb::B: Second geometry to build the union.\n\nDefinition in Configuration File\n\nA CSGUnion is defined in the configuration file as part of the geometry field  of an object through the field union, followed by an array of geometries from which the union is constructed. \n\nAn example definition of a CSGUnion looks like this:\n\nunion: # a || b\n  - tube: # a\n      r: 2\n      h: 1\n  - tube: # b\n      r: 1\n      h: 1.5\n      origin: \n        z: 0.5\n\nnote: Note\nIf more than two geometries are passed, the union is constructed from all of them.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint","text":"struct CartesianPoint{T} <: AbstractCoordinatePoint{T, Cartesian}\n\nDescribes a three-dimensional point in Cartesian coordinates.\n\nFields\n\nx: x-coordinate (in m).\ny: y-coordinate (in m).\nz: z-coordinate (in m).\n\nSee also CylindricalPoint.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector","text":"struct CartesianVector{T} <: AbstractCoordinateVector{T, Cartesian}\n\nDescribes a three-dimensional vector in Cartesian coordinates.\n\nFields\n\nx: x-coordinate (in m).\ny: y-coordinate (in m).\nz: z-coordinate (in m).\n\nSee also CylindricalVector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Cone","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Cone","text":"struct Cone{T,CO,TR,TP} <: AbstractVolumePrimitive{T, CO}\n\nVolume primitive describing a Cone with its top and bottom circular base being aligned with the xy plane (before possible rotations).\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nTR: Type of the radius r.\nTR == T: Cylinder (constant radius r at all z).\nTR == Tuple{T, T}: Tube (inner radius at r[1], outer radius at r[2]).\nTR == Tuple{Tuple{T}, Tuple{T}}: Varying Cylinder (full cylinder with radius changing linearly in z from r[1] at the bottom to r[2] at the top).\nTR == Tuple{Tuple{T, T}, Tuple{T, T}}: Varying Tube (inner radius changes linearly in z from r[1][1] at the bottom to r[1][2] at the top, outer radius changes linearly in z from r[2][1] at the bottom to r[1][2] at the top).\nTR == Tuple{Nothing, Tuple{T, T}}: Cone (Tip at the bottom, top is a circular base with inner radius r[2][1] and outer radius r[2][2]).\nTR == Tuple{Tuple{T, T}, Nothing}: Cone (Tip at the top, bottom is a circular base with inner radius r[1][1] and outer radius r[1][2]).\nTP: Type of the angular range φ.\nTP == Nothing: Full 2π Cone.\nTP == T: Partial Cone ranging from 0 to φ.\n\nFields\n\nr::TR: Definition of the radius of the Cone (in m).\nφ::TP: Range in polar angle φ over which the Cone extends (in radians).\nhZ::T: Half of the height of the Cone (in m).\norigin::CartesianPoint{T}: The position of the center of the Cone at the middle height.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Cone around its origin.\n\nDefinition in Configuration File\n\nA Cone is defined in the configuration file as part of the geometry field  of an object through the field cone (or tube).\n\nExample definitions of a cylinder looks like this:\n\ntube:\n  r:\n    from: 1.0\n    to: 2.0  # => r = (1.0, 2.0)\n  h: 2.0     # => hZ = 1.0\n  origin:\n    z: 1.0   # => origin = [0.0, 0.0, 1.0]\n\nThis is a hollow cylinder with inner radius 1 at outer radius 2 with a height of 2 and extending over full 2π (no phi given), translated 1 along the z axis.\n\nIf the radius is not constant over z, the r entries are divided into bottom and top, where bottom describes the inner and outer  radius at the bottom circular base and top describes the inner and outer radius at the top circular base (before rotations)\n\ncone:\n  r:\n    bottom:\n      from: 1.0\n      to: 2.0\n    top:\n      from: 1.0\n      to: 4.0     # => r = ((1.0, 2.0), (1.0, 4.0))\n  phi:\n    from: 0.0°\n    to: 180.0°    # => φ = π\n  h: 2.0          # => hZ = 1.0\n\nThis is half a Cone (φ goes from 0 to 180°, i.e. only positive y are allowed) with a height of 2, constant inner radius of 1 and an outer radius which increases  from 2 at the bottom to 4 at the top circular base.\n\nnote: Note\nThe names tube and cone in the configuration files are interchangeable.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle","text":"struct ConeMantle{T,TR,TP,D} <: AbstractCurvedSurfacePrimitive{T}\n\nSurface primitive describing the mantle of a Cone.\n\nParametric types\n\nT: Precision type.\nTR: Type of the radius r.\nTR == T: CylinderMantle (constant radius r at all z).\nTR == Tuple{T, T}: VaryingCylinderMantle (bottom radius at r[1], top radius at r[2]).\nTP: Type of the angular range φ.\nTP == Nothing: Full 2π Cone.\nTP == T: Partial ConeMantle ranging from 0 to φ.\nD: Direction in which the normal vector points (:inwards or :outwards).\n\nFields\n\nr::TR: Definition of the radius of the ConeMantle (in m).\nφ::TP: Range in polar angle φ over which the ConeMantle extends (in radians).\nhZ::T: Half of the height of the ConeMantle (in m).\norigin::CartesianPoint{T}: Origin of the Cone which has this ConeMantle as surface.\nrotation::SMatrix{3,3,T,9}: Rotation matrix of the Cone which has this ConeMantle as surface.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint","text":"struct CylindricalPoint{T} <: AbstractCoordinatePoint{T, Cylindrical}\n\nDescribes a three-dimensional point in cylindrical coordinates. \n\nFields\n\nr: Radius (in m).\nφ: Polar angle (in rad).\nz: z-coordinate (in m).\n\nnote: Note\nφ == 0 corresponds to the x-axis in the Cartesian coordinate system.\n\nSee also CartesianPoint.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector","text":"struct CylindricalVector{T} <: AbstractCoordinateVector{T, Cylindrical}\n\nDescribes a three-dimensional vector in cylindrical coordinates. \n\nFields\n\nr: Radius (in m).\nφ: Polar angle (in rad).\nz: z-coordinate (in m).\n\nnote: Note\nφ == 0 corresponds to the x-axis in the Cartesian coordinate system.\n\nSee also CartesianVector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid","text":"struct Ellipsoid{T,CO,TR,TP,TT} <: AbstractVolumePrimitive{T, CO}\n\nVolume primitive describing an Ellipsoid.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nTR: Type of the radius r.\nTR == T: Sphere (constant radius r along all axes).\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\n\nFields\n\nr::TR: Definition of the radius of the Ellipsoid (in m).\nφ::TP: Range in azimuthial angle φ of the Ellipsoid.\nθ::TT: Range in polar angle θ of the Ellipsoid.\norigin::CartesianPoint{T}: The position of the center of the Ellipsoid.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Ellipsoid around its origin.\n\nDefinition in Configuration File\n\nSo far, the only Ellipsoid implemented so far is a FullSphere. A FullSphere is defined in the configuration file as part of the geometry field  of an object through the field sphere.\n\nExample definitions of a FullSphere looks like this:\n\nsphere:\n  r: 2\n\nThis is a full sphere with radius 2.\n\nTo define a sphere with inner cut-out, use CSGDifference:\n\ndifference:\n  - sphere:\n      r: 2\n  - sphere:\n      r: 1\n\nThis is a sphere with inner radius 1 and outer radius 2.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle","text":"struct EllipsoidMantle{T,TR,TP,TT,D} <: AbstractCurvedSurfacePrimitive{T}\n\nSurface primitive describing the surface of an Ellipsoid.\n\nParametric types\n\nT: Precision type.\nTR: Type of the radius r.\nTR == T: SphereMantle (constant radius r along all axes).\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\nD: Direction in which the normal vector points (:inwards or :outwards).\n\nFields\n\nr::TR: Definition of the radius of the EllipsoidMantle (in m).\nφ::TP: Range in azimuthial angle φ of the EllipsoidMantle.\nθ::TT: Range in polar angle θ of the EllipsoidMantle.\norigin::CartesianPoint{T}: Origin of the Ellipsoid which has this EllipsoidMantle as surface.\nrotation::SMatrix{3,3,T,9}: Rotation matrix of the Ellipsoid which has this EllipsoidMantle as surface.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface","text":"struct EllipticalSurface{T,TR,TP} <: AbstractPlanarSurfacePrimitive{T}\n\nSurface primitive describing circular bases, e.g. the top or bottom base of a Cone.\n\nParametric types\n\nT: Precision type.\nTR: Type of the radius r.\nTR == T: Full Circle (constant radius r, no cut-out).\nTR == Tuple{T, T}: Circular Annulus (inner radius at r[1], outer radius at r[2]).\nTP: Type of the angular range φ.\nTP == Nothing: Full 2π Cone.\nTP == T: Partial Elliptical Surface ranging from 0 to φ.\n\nFields\n\nr::TR: Definition of the radius of the EllipticalSurface (in m).\nφ::TP: Range in polar angle φ over which the EllipticalSurface extends (in radians).\norigin::CartesianPoint{T}: The position of the center of the EllipticalSurface.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the EllipticalSurface around its origin.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Plane","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Plane","text":"struct Plane{T} <: AbstractPlanarSurfacePrimitive{T}\n\nSurface primitive describing a two-dimensional flat plane in three-dimensional space.\n\nFields\n\norigin::CartesianPoint{T}: Point in the Plane.\nnormal::CartesianVector{T}: Normal vector of the Plane, normalized to length 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Polygon","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Polygon","text":"struct Polygon{N,T} <: AbstractPlanarSurfacePrimitive{T}\n\nSurface primitive describing a planar polygon, e.g. the base of a RegularPrism.\n\nParametric types\n\nT: Precision type.\nN: Number of vertices of the Polygon.\n\nFields\n\npoints::SVector{N, CartesianPoint{T}}: Vertices of the polygon in the order with which they are connected.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism","text":"struct RegularPrism{T,CO,N,TR} <: AbstractVolumePrimitive{T, CO}\n\nVolume primitive describing a Prism with base plates are regular polygons which are parallel to the xy plane. If the regular polygon base plate is projected to  the xy plane, one of the vertices lays on the x axis.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nN: Number of vertices of the regular polygon that defines the base of the prism.\nTR: Type of r.\nTR == T: Regular polygon base (all vertices have the same distance to the center).\n\nFields\n\nr::TR: Distance of the vertices to the center of the regular polygon base (in m).\nhZ::T: Half of the width in z dimension (in m).\norigin::CartesianPoint{T}: The position of the center of the RegularPrism.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the RegularPrism around its origin.\n\nDefinition in Configuration File\n\nSo far, only HexagonalPrism can be defined in the configuration files. A HexagonalPrism is defined in the configuration file as part of the geometry field  of an object through the field HexagonalPrism.\n\nAn example definition of a HexagonalPrism looks like this:\n\nHexagonalPrism:\n  r: 1.0 # => r = 1.0\n  h: 2.0 # => hZ = 1.0\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.Torus","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.Torus","text":"struct Torus{T,CO,TR,TP,TT,TT1,TT2} <: AbstractVolumePrimitive{T,CO}\n\nVolume primitive describing a Torus. It is defined as all points that are within a given radius to a circle, parallel to the xy plane, with constant radius around a given origin.\n\nParametric types\n\nT: Precision type.\nCO: Describes whether the surface belongs to the primitive.    It can be ClosedPrimitive, i.e. the surface points belong to the primitive,   or OpenPrimitive, i.e. the surface points do not belong to the primitive.\nTR: Type of r_tube.\nTR == T: Full tube without cutout (constant radius r_tube).\nTR == Tuple{T,T}: Hollow tube with cutout (inner radius r_tube[1], outer radius r_tube[2]).\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTP == T: Partial Torus ranging from 0 to φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\nTP == Tuple{T,T}: Partial Torus ranging from θ[1] to θ[2].\nTT1: Type of the surface at θ[1] (:inwards, :outwards or :flat).\nTT2: Type of the surface at θ[2] (:inwards, :outwards or :flat).\n\nFields\n\nr_torus::T: Distance of the center of the Torus to the center of the tube (in m).\nr_tube::TR: Radius of the tube of the Torus (in m).\nφ::TP: Range in azimuthial angle φ of the Torus.\nθ::TT: Range in polar angle θ of the Torus.\norigin::CartesianPoint{T}: The position of the center of the Torus.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the Torus around its origin.\n\nDefinition in Configuration File\n\nA Torus is defined in the configuration file as part of the geometry field  of an object through the field torus.\n\nExample definitions of a Torus looks like this:\n\ntorus:\n  r_torus: 10.0   # => r_torus = 10.0\n  r_tube: 2       # => r_tube = 2.0\n  phi: \n      from: 0.0°\n      to: 360.0°  # => φ = nothing\n  theta: \n      from: 0.0°\n      to: 360.0°  # => θ = nothing\n\nThe fields phi and theta do not need to defined if they are full 2π.\n\nExample definition of a Torus with an inner cut-out:\n\ntorus:\n  r_torus: 10.0   # => r_torus = 10.0\n  r_tube: \n      from: 1.0\n      to: 2.0     # => r_tube = (1.0, 2.0)\n  phi: \n      from: 0.0°\n      to: 360.0°  # => φ = nothing\n  theta: \n      from: 0.0°\n      to: 360.0°  # => θ = nothing\n\nThis is a Torus with r_tube having an inner radius of 1 and an outer radius of 2.\n\nSee also Constructive Solid Geometry (CSG).\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle","text":"struct TorusMantle{T,TP,TT,D} <: AbstractCurvedSurfacePrimitive{T}\n\nSurface primitive describing the mantle of a Torus.\n\nParametric types\n\nT: Precision type.\nTP: Type of the azimuthial angle φ.\nTP == Nothing: Full 2π in φ.\nTP == T: Partial Torus Mantle ranging from 0 to φ.\nTT: Type of the polar angle θ.\nTT == Nothing: Full 2π in θ.\nTP == Tuple{T,T}: Partial Torus Mantle ranging from θ[1] to θ[2].\nD: Direction in which the normal vector points (:inwards or :outwards).\n\nFields\n\nr_torus::T: Distance of the center of the TorusMantle to the center of the tube (in m).\nr_tube::T: Radius of the tube of the TorusMantle (in m).\nφ::TP: Range in azimuthial angle φ of the TorusMantle.\nθ::TT: Range in polar angle θ of the TorusMantle.\norigin::CartesianPoint{T}: The position of the center of the TorusMantle.\nrotation::SMatrix{3,3,T,9}: Matrix that describes a rotation of the TorusMantle around its origin.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.extreme_points","text":"extreme_points(es::AbstractPrimitive{T}) where {T}\n\nGeneric fallback of extreme_points for any primitive.  Returns 6 CartesianPoints in both directions of each cartesian axes (x, y and z) around the origin of the primitive with distance determined by extremum(es), which returns the maximum distance of an primitive to its origin.\n\nArguments\n\nes::AbstractPrimitive{T}: Any primitive, e.g. a Box.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP} where TP<:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(cm::ConeMantle{T,Tuple{T,T}}, l::Line{T}) where {T}\n\nCalculates the intersections of a Line with a ConeMantle.\n\nArguments\n\ncm::ConeMantle{T,Tuple{T,T}}: The ConeMantle.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates. If the line crosses the mantle only once, two points will be returned. The two points will be the same point (the intersection). If the line lies inside the mantle and is parallel to it. The same point will be returned which is the origin of the line. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(em::EllipsoidMantle{T}, l::Line{T}) where {T}\n\nCalculates the intersections of a Line with a EllipsoidMantle.\n\nArguments\n\ncm::EllipsoidMantle{T}: The EllipsoidMantle.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return 2 CartesianPoint's. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.Plane{T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(p::Plane{T}, line::Line{T}) where {T}\n\nCalculates the intersections of a Line with a Plane.\n\nArguments\n\ncm::Plane{T}: The Plane.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return one Point as a Tuple. If the line is parallel to the plane, the point will have NaN's/Inf's as values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP} where TP<:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T","page":"API","title":"SolidStateDetectors.ConstructiveSolidGeometry.intersection","text":"intersection(tm::TorusMantle{T}, l::Line{T}) where {T}\n\nCalculates the intersections of a Line with a TorusMantle.\n\nArguments\n\ncm::TorusMantle{T}: The TorusMantle.\nl::Line{T}: The Line.\n\nnote: Note\nThe function will always return 4 CartesianPoint's. If the line just touches the mantle, the points will be the same.  If the line does not touch the mantle at all, the points will have NaN's as there coordinates.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"EditURL = \"https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/main/docs/src/tutorials/custom_impurity_density_pn_junction_lit.jl\"","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/#Advanced-Example:-Custom-Impurity-Profile","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"","category":"section"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"A very important input to the simulation is the impurity profile of the semiconductor. It influences the electric potential and, thus, the electric field, capacitances, drift paths and also the induced waveforms.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"Arbitrary impurity density profiles can be defined and assigned to the semiconductor of the detector. Also have a look into the manual: Impurity Densities and Custom Impurity Density.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"As an example, we define the impurity profile of a simple p-n junction and calculate the electric potential and depleted region and reproduce the typical plot shown in various books explaining p-n junctions.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"For this, we use one of the example detectors: the infinite parallel plate capacitor in cartesian coordinates. The plates span over y and z. It is made infinite by defining the world smaller than the contacts and using reflecting boundaries in y and z. Let's get started by loading the packages and the detector and have a look at its geometry:","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"using Plots\nusing SolidStateDetectors\nusing Unitful\n\nsim = Simulation{Float32}(SSD_examples[:InfiniteParallelPlateCapacitor])\nplot( sim.detector.semiconductor, fillalpha = 0.4)\nplot!(sim.detector, xlims = (-0.006, 0.006), aspect_ratio = :none)","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/#Define-the-Impurity-Density","page":"Advanced Example: Custom Impurity Profile","title":"Define the Impurity Density","text":"","category":"section"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"Now, we define the model for the impurity density of the p-n junction. In order to do so, we need to define two things.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"1. We have to define a struct which has to be    subtype of SolidStateDetectors.AbstractImpurityDensity{T}.    We define the model with two parameters in order to be able to vary the density level    in the p-type and n-type regions independently.    More parameters could be added, e.g., the position of the p-n junction.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"struct PNJunctionImpurityDensity{T} <: SolidStateDetectors.AbstractImpurityDensity{T}\n    p_type_density::T\n    n_type_density::T\nend","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"2. We have to define a method for SolidStateDetectors.get_impurity_density for our    just defined impurity density.    It has to take two arguments. An instance of our model and a point.    The function returns the impurity density at the respective position.    The returned value has to be in units of 1/m^3.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"note: Sign of the impurity density\nThe sign of the impurity density determines whether the semiconductor is p-type or n-type.p-type region <-> negative sign: Holes are the majority carriers and are free to move and diffuse into the n-type region.     Electrons are fixed in the lattice. Thus, a negative fixed space charge density is left behind in the depleted p-type region.n-type region <-> positive sign: Electrons are the majority carriers and are free to move and diffuse into the p-type region.     Holes are fixed in the lattice. Thus, a positive fixed space charge density is left behind in the depleted n-type region.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"function SolidStateDetectors.get_impurity_density(\n    cdm::PNJunctionImpurityDensity{T},\n    pt::SolidStateDetectors.AbstractCoordinatePoint{T}\n)::T where {T}\n    cpt = CartesianPoint(pt)\n    x = cpt[1] # In this example, we only need the `x` coordinate of the point.\n    if x > 0\n        -cdm.p_type_density # p-type region -> electrons are fixed -> negative charge\n    else\n        cdm.n_type_density  # n-type region -> holes are fixed -> positive charge\n    end\nend","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/#Assign-the-Density-and-Calculate-the-Fields","page":"Advanced Example: Custom Impurity Profile","title":"Assign the Density and Calculate the Fields","text":"","category":"section"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"Now, we create an instance of our model with reasonable parameters (for the geometry and bias voltage of the example detector) and assign it to the detector.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"pn_junction_impurity_density = PNJunctionImpurityDensity{Float32}(3e16, 1.5e16)\nsim.detector = SolidStateDetector(sim.detector, pn_junction_impurity_density);\nnothing #hide","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"We are now ready to calculate the electric potential. Depletion handling has to be turned on, via the keyword depletion_handling = true, in order to detect the regions where the detector is depleted. The other settings for calculate_electric_potential! are very specific for this effectively 1D problem to be calculated in 3D. Afterwards, we also calculate the electric field and plot the electric potential, impurity scale map and the point type map. The two latter ones show us where the detector is depleted (imp_scale == 1).","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"calculate_electric_potential!(\n    sim,\n    convergence_limit = 1e-6,\n    max_tick_distance = (0.002, 1, 1) .* u\"cm\",\n    min_tick_distance = (1e-7, 1, 1) .* u\"m\",\n    refinement_limits = [0.005, 0.001],\n    depletion_handling = true\n)\ncalculate_electric_field!(sim)\n\nplot(\n    plot(sim.electric_potential, y = 0),\n    plot(sim.imp_scale, y = 0),\n    plot(sim.point_types, y = 0),\n    layout = (3, 1),\n    aspect_ratio = :none,\n    size = (800, 800)\n)","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/#D-Plots-of-the-P-N-Junction","page":"Advanced Example: Custom Impurity Profile","title":"1D Plots of the P-N Junction","text":"","category":"section"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"As this is in principle a 1D simulation, it is most reasonable to plot the charge density from the impurities, the electric potential and the electric field strength (here equals the x component of the electric field) only over x.","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"xs = uconvert.(u\"mm\", sim.electric_potential.grid[1] * u\"m\");\nplot(\n    begin\n        ρ_x = map(x -> SolidStateDetectors.get_impurity_density(\n            sim.detector.semiconductor.impurity_density_model, CartesianPoint{Float32}(x, 0, 0)),\n            sim.electric_potential.grid[1]\n        )\n        plot(xs, ρ_x .* sim.imp_scale[:, 1, 1], lw = 4, label =\"\", xguide = \"x\", unitformat = :square, yguide = \"\\$\\\\rho\\$ [e/m\\$^3\\$]\")\n        vline!([sim.detector.contacts[1].geometry.origin.x] * 1000, lw = 4, color = \"green\", label = \"N+ Contact\")\n        vline!([sim.detector.contacts[2].geometry.origin.x] * 1000, lw = 4, color = \"red\", label = \"P+ Contact\")\n        vline!([0], lw = 4, color = \"black\", label = \"p-n junction\")\n    end,\n    begin\n        plot(xs, sim.electric_potential.data[:,1,1], lw = 4, label =\"\", xguide = \"x\", unitformat = :square, yguide = \"\\$\\\\Phi\\$ [V]\")\n        vline!([sim.detector.contacts[1].geometry.origin.x] * 1000, lw = 4, color = \"green\", label = \"N+ Contact\")\n        vline!([sim.detector.contacts[2].geometry.origin.x] * 1000, lw = 4, color = \"red\", label = \"P+ Contact\")\n        vline!([0], lw = 4, color = \"black\", label = \"p-n junction\")\n    end,\n    begin\n        plot(xs, map(E -> E[1]/1000, sim.electric_field.data[:,1,1]), lw = 4, label =\"\", xguide = \"x\", unitformat = :square, yguide = \"\\$\\\\mathcal{E}_x\\$ [V/mm]\")\n        vline!([sim.detector.contacts[1].geometry.origin.x] * 1000, lw = 4, color = \"green\", label = \"N+ Contact\")\n        vline!([sim.detector.contacts[2].geometry.origin.x] * 1000, lw = 4, color = \"red\", label = \"P+ Contact\")\n        vline!([0], lw = 4, color = \"black\", label = \"p-n junction\")\n    end,\n    layout = (3, 1),\n    xlims = (-5.1, 5.1),\n    size = (800, 800),\n    lw = 2,\n)","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"","category":"page"},{"location":"tutorials/custom_impurity_density_pn_junction/","page":"Advanced Example: Custom Impurity Profile","title":"Advanced Example: Custom Impurity Profile","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/electric_field/#Electric-Field","page":"Electric Field","title":"Electric Field","text":"","category":"section"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The electric field is calculated from the electric potential for each grid point (ijk) when calling calculate_electric_field!(sim). The field vector components on each grid point are the means of the electric field in each direction calculated as finite differences.","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"On a Cartesian grid, this results in:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"vecE^ijk = left( mathcalE_x^ijk mathcalE_y^ijk mathcalE_z^ijk right)^mathsfThspace10pt","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"where","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"beginaligned\n\tmathcalE_x^ijk = dfrac12left( dfracPhi_i+1jk-Phi_i+1jkx_i+1 - x_i + dfracPhi_ijk-Phi_i-1jkx_i - x_i-1 right)hspace10pt\n\tmathcalE_y^ijk = dfrac12left( dfracPhi_ij+1k-Phi_ijky_j+1 - y_j + dfracPhi_ijk-Phi_ij-1ky_j - y_j-1 right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"On a cylindrical grid, the calculation is:","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"vecE^ijk = left( mathcalE_r^ijk mathcalE_varphi^ijk mathcalE_z^ijk right)^mathsfThspace10pt","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"where","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"beginaligned\n\tmathcalE_r^ijk = dfrac12left(dfracPhi_i+1jk-Phi_ijkr_i+1 - r_i + dfracPhi_ijk-Phi_i-1jkr_i - r_i-1right)hspace10pt\n\tmathcalE_varphi^ijk = dfrac12 r_ileft(dfracPhi_ij+1k-Phi_ijkvarphi_j+1 - varphi_j + dfracPhi_ijk-Phi_ij-1kvarphi_j - varphi_j-1right)hspace10pt\n\tmathcalE_z^ijk = dfrac12left( dfracPhi_ijk+1-Phi_ijkz_k+1 - z_k + dfracPhi_ijk-Phi_ijk-1z_k - z_k-1 right)hspace10pt\nendaligned","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"This discrete electric field is interpolated (via Interpolations.jl)  during the drift in order to get the electric field at the current position of the charge carrier.","category":"page"},{"location":"man/electric_field/","page":"Electric Field","title":"Electric Field","text":"The calculated electric field is stored as a field in the Simulation object, i.e. sim.electric_field, consisting of the actual field vectors for each grid point stored in sim.electric_field.data and the corresponding grid in sim.electric_field.grid.","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#SolidStateDetectors.jl","page":"Home","title":"SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SolidStateDetectors.jl is a Julia package for fast 2D and 3D simulation of Solid State Detectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/installation.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/config_files.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/csg.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/Grids.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_potential.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/electric_field.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/charge_drift.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/weighting_potentials.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/capacitances.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/IO.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/plotting.md\"]","category":"page"},{"location":"#Citing-SolidStateDetectors.jl","page":"Home","title":"Citing SolidStateDetectors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using SolidStateDetectors.jl for research, teaching or similar, please cite the paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Abt:2021SSD,\r\n  author        = {Abt, I. and Fischer, F. and Hagemann, F. and Hauertmann, L. and Schulz, O. and Schuster, M. and Zsigmond, A. J.},\r\n  title         = {Simulation of semiconductor detectors in 3D with SolidStateDetectors.jl},\r\n  year          = {2021},\r\n  month         = {8},\r\n  journal       = {Journal of Instrumentation},\r\n  publisher     = {{IOP} Publishing},\r\n  volume        = {16},\r\n  number        = {08},\r\n  pages         = {P08007},\r\n  doi           = {10.1088/1748-0221/16/08/p08007},\r\n  url           = {https://doi.org/10.1088/1748-0221/16/08/p08007}\r\n}","category":"page"},{"location":"man/electric_potential/#Electric-Potential","page":"Electric Potential","title":"Electric Potential","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The electric potential is given by Gauss' law in matter","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"nabla left( epsilon_r(vecr) nabla Phi(vecr)right) = - dfracrho(vecr)epsilon_0","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"where Phi is the electric potential, rho is the charge density, epsilon_r is the dielectric distribution and epsilon_0 is the dielectric constant of the vacuum.","category":"page"},{"location":"man/electric_potential/#Simulation-Algorithm","page":"Electric Potential","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The electric potential is calculated through successive over relaxation when calling calculate_electric_potential!(sim). The equation is numerically solved on a three-dimensional adaptive red/black grid. The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical. To use multiple threads for the simulation, the environment variable JULIA_NUM_THREADS must be set before Julia is started. In case of bash this is done through","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"note: GPU\nThe electric potential can be calculated on GPUs. See GPU Support in Field Calculations.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"At the beginning of the simulation, each grid point, (ijk) is assigned its dielectric constant, epsilon_r(vecr_ijk), as well as its effective charge, Q_texteff = rho(vecr_ijk) cdot V_ijk  epsilon_0, where V_ijk is the volume assigned to the grid point (ijk).","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"These quantities are stored in the fields sim.q_eff_imp and sim.ϵ_r and can be plotted using","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors\r\nusing Plots \r\nsim = Simulation(SSD_examples[:InvertedCoax])\r\napply_initial_state!(sim, ElectricPotential)\r\nplot(\r\n  plot(sim.q_eff_imp),\r\n  plot(sim.ϵ_r)\r\n)","category":"page"},{"location":"man/electric_potential/#Impurity-Densities","page":"Electric Potential","title":"Impurity Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"One contribution to the charge density rho(vecr) is the impurity density of the semiconductor of a detector. Some simple impurity density profiles are already implemented in SolidStateDetectors.jl and can be easily accessed in the configuration files. Note that all impurity densities are given in units of atoms / particles per volume.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"note: Sign of the impurity density\nThe sign of the impurity density determines whether the semiconductor is p-type or n-type.p-type region <-> negative sign: Holes are the majority carriers and are free to move and diffuse into the n-type region.      Electrons are fixed in the lattice. Thus, a negative fixed space charge density is left behind in the depleted p-type region.n-type region <-> positive sign: Electrons are the majority carriers and are free to move and diffuse into the p-type region.      Holes are fixed in the lattice. Thus, a positive fixed space charge density is left behind in the depleted n-type region.","category":"page"},{"location":"man/electric_potential/#Constant-Impurity-Density","page":"Electric Potential","title":"Constant Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"A constant impurity density throughout the detector volume can be modeled with ConstantImpurityDensity. In the configuration files, constant impurity densities are defined with the value of the constant impurity density, i.e.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: constant\r\n  value: 1e10cm^-3 # => 10¹⁶ m⁻³","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"If no units are given, value is interpreted in units of units.length^-3. They are converted to SI units (m^-3) internally.","category":"page"},{"location":"man/electric_potential/#Linear-Impurity-Density","page":"Electric Potential","title":"Linear Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"An impurity density with a linear gradient can be modeled with LinearImpurityDensity. In the configuration files, linear impurity densities are defined with an init (initial) value and gradient along each Cartesian direction (x, y and z), e.g.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: linear\r\n  z:\r\n    init: 1e10cm^-3\r\n    gradient: 1e10cm^-4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"or","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: linear\r\n  x:\r\n    init: 0\r\n    gradient: 1e10\r\n  z:\r\n    init: 0\r\n    gradient: 1e10","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"In the first example, the init value corresponds to the value at z = 0 whereas the gradient points towards positive z. In the second example, the impurity density is 0 at the origin of the coordinate system, whereas the gradient of the impurity density profile points in langle101rangle direction. If no units are given, init is parsed in units of units.length^-3 and gradient in units of units.length^-4.","category":"page"},{"location":"man/electric_potential/#Cylindrical-Impurity-Density","page":"Electric Potential","title":"Cylindrical Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"An impurity density with a radial gradient can be modeled with CylindricalImpurityDensity. In the configuration files, cylindrical impurity densities are defined with an init (initial) value and gradient along each cylindrical spatial direction (r and z), e.g.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"impurity_density:\r\n  name: cylindrical\r\n  r:\r\n    init: 1e10cm^-3\r\n    gradient: 1e10cm^-4","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Here, the impurity density at the origin is 10^10cm^-3 and it increases radially with the gradient 10^10cm^-4. If no units are given, init is parsed in units of units.length^-3 and gradient in units of units.length^-4.","category":"page"},{"location":"man/electric_potential/#Custom-Impurity-Density","page":"Electric Potential","title":"Custom Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"The source code for the previously introduced impurity densities can be found here. More complex impurity density profiles can be defined by the user. Each custom impurity density is a new struct and subtype of SolidStateDetectors.AbstractImpurityDensity and needs a method SolidStateDetectors.get_impurity_density that returns the impurity density at a given point pt.","category":"page"},{"location":"man/electric_potential/#Example-1:-Radially-Oscillating-Impurity-Density","page":"Electric Potential","title":"Example 1: Radially Oscillating Impurity Density","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors: AbstractChargeDensity, CartesianVector, AbstractCoordinatePoint\r\nimport SolidStateDetectors: get_impurity_density\r\n\r\n# new struct for translated impurity densities\r\nstruct OscillatingImpurityDensity{T} <: AbstractImpurityDensity{T}\r\n    wavelength::T \r\n    amplitude::T\r\n    offset::T\r\nend\r\n\r\n# add get_charge_density for the newly defined charge density model\r\nfunction SolidStateDetectors.get_impurity_density(ocdm::OscillatingImpurityDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}\r\n    cyl_pt = CylindricalPoint(pt) # convert point to a CylindricalPoint\r\n    return ocdm.offset + ocdm.amplitude * sin(2π * cyl_pt.r / ocdm.wavelength)\r\nend","category":"page"},{"location":"man/electric_potential/#Example-2:-Translating-Existing-Impurity-Densities","page":"Electric Potential","title":"Example 2: Translating Existing Impurity Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"using SolidStateDetectors: AbstractImpurityDensity, CartesianVector, AbstractCoordinatePoint\r\nimport SolidStateDetectors: get_impurity_density\r\n\r\n# new struct for translated impurity densities\r\nstruct TranslatedImpurityDensity{T} <: AbstractImpurityDensity{T}\r\n    impurity_density_model::AbstractImpurityDensity{T}\r\n    translate::CartesianVector{T}\r\nend\r\n\r\n# add get_impurity_density for the newly defined impurity density model\r\nfunction SolidStateDetectors.get_impurity_density(tcdm::TranslatedImpurityDensity{T}, pt::AbstractCoordinatePoint{T})::T where {T}\r\n    translated_pt::CartesianPoint{T} = CartesianPoint(pt) - tcdm.translate\r\n    return get_impurity_density(tcdm.impurity_density_model, translated_pt)\r\nend","category":"page"},{"location":"man/electric_potential/#Example-3:-P-N-Junction","page":"Electric Potential","title":"Example 3: P-N Junction","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Have a look at Advanced Example: Custom Impurity Profile.","category":"page"},{"location":"man/electric_potential/#Charge-Densities","page":"Electric Potential","title":"Charge Densities","text":"","category":"section"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Another contribution to the charge density rho(vecr) can be charged surfaces or volumes that can be modeled using passive objects. The same profiles as for impurity densities are defined here that can be accessed similarly, i.e.","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"charge_density:\r\n  name: constant\r\n  value: 1e-10 # => 10⁻¹⁰ C/m⁻³","category":"page"},{"location":"man/electric_potential/","page":"Electric Potential","title":"Electric Potential","text":"Note that, in contrast to impurity densities, charge densities are given in units of the elementary charge per volume.","category":"page"}]
}
