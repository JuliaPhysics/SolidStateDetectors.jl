var documenterSearchIndex = {"docs":
[{"location":"#SolidStateDetectors.jl-1","page":"Home","title":"SolidStateDetectors.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SolidStateDetectors.jl is a Julia package for fast 2D and 3D simulation of Solid State Detectors.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/installation.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/config_files.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/csg.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/primitives.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/electric_potentials.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/weighting_potentials.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/electric_fields.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/drift_fields.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/IO.md\"]","category":"page"},{"location":"man/installation/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"This package is a registered package.","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"Install via","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add SolidStateDetectors\"","category":"page"},{"location":"man/installation/#Vizualization-/-Plotting-(Optional)-1","page":"Installation","title":"Vizualization / Plotting (Optional)","text":"","category":"section"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"This package provides serveral plot recipes for different outputs for the plotting package Plots.jl.","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"In order to use these also install the Plots.jl package via","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add Plots\"","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"It is recommended to use pyplot as backend. Install via","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"using Pkg; pkg\"add PyPlot\"","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"Then you can load it via","category":"page"},{"location":"man/installation/#","page":"Installation","title":"Installation","text":"using Plots; pyplot();","category":"page"},{"location":"man/config_files/#Config-Files-1","page":"Config Files","title":"Config Files","text":"","category":"section"},{"location":"man/config_files/#Example-Detector-Config-Files-1","page":"Config Files","title":"Example Detector Config Files","text":"","category":"section"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"Currently, there are four predefined example detectors. ","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"Three of them are cylindrical detectors:","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"* Coaxial detector (Coax)\r\n* Inverted coax detector (IVC)\r\n* BEGe type detector (BEGe)","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"The fourth one is in cartesian coordinates:","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"* simple cube detector (CGD)","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"They are all specified in their JSON config files, which can be found under: <package_directory>/examples/example_detector_config_files/<config_filename>.json.","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"In Julia, their path is already saved in the SolidStateDetectors.jl package in a dictionary:","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"    using SolidStateDetectors\r\n    SSD_examples # dictionary holding the full path to the corresponding config JSON files\r\n    SSD_exmpless[:Coax]","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"The keys are: :Coax, :InvertedCoax, :BEGe, :CGD.","category":"page"},{"location":"man/config_files/#Example-1)-Inverted-Coax-1","page":"Config Files","title":"Example 1) Inverted Coax","text":"","category":"section"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"Example minimum config file for an Inverted Coax detector (IVC) plus explanations. Remember, comments are not allowed in JSON files and have to be deleted if you want to use it.","category":"page"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"{\r\n    name = \"Example Detector\",\r\n    ToDo...\r\n}","category":"page"},{"location":"man/config_files/#UserConfigs:-Define-your-own-geometry-1","page":"Config Files","title":"UserConfigs: Define your own geometry","text":"","category":"section"},{"location":"man/config_files/#","page":"Config Files","title":"Config Files","text":"ToDo...","category":"page"},{"location":"man/csg/#Constructive-Solid-Geometry-(CSG)-1","page":"CSG","title":"Constructive Solid Geometry (CSG)","text":"","category":"section"},{"location":"man/csg/#Boolean-operators-1","page":"CSG","title":"Boolean operators","text":"","category":"section"},{"location":"man/csg/#Union-1","page":"CSG","title":"Union","text":"","category":"section"},{"location":"man/csg/#","page":"CSG","title":"CSG","text":"\"geometry\": {\n    \"type\": \"union\",\n    \"parts\": [\n        {\n            \"name\":\"Seg1 bottom\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 13.5,\n                \"to\": 39.5\n            },\n            \"phi\": {\n                \"from\": 0.3582,\n                \"to\": 59.6419\n            },\n            \"h\": 0\n        },\n        {\n            \"name\": \"Seg1 side\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 39.5,\n                \"to\": 39.5\n            },\n            \"phi\": {\n                \"from\": 0.3582,\n                \"to\": 59.6419\n            },\n            \"h\": 40\n        },\n    }\n}","category":"page"},{"location":"man/csg/#Difference-1","page":"CSG","title":"Difference","text":"","category":"section"},{"location":"man/csg/#","page":"CSG","title":"CSG","text":"\"geometry\": {\n    \"type\": \"difference\",\n    \"parts\": [\n        {\n            \"name\": \"Initial Cylinder\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 0.0,\n                \"to\":  35.0\n            },\n            \"phi\": {\n                \"from\": 0.0,\n                \"to\": 360.0\n            },\n            \"z\": {\n                \"from\": 0,\n                \"to\":  40\n            }\n        },\n        {\n            \"name\": \"Borehole\",\n            \"type\": \"tube\",\n            \"r\": {\n                \"from\": 0.0,\n                \"to\":   5.0\n            },\n            \"phi\": {\n                \"from\": 0.0,\n                \"to\": 360.0\n            },\n            \"z\": {\n                \"from\": 0,\n                \"to\":  40\n            }\n        }\n    ]\n}","category":"page"},{"location":"man/csg/#Intersection-1","page":"CSG","title":"Intersection","text":"","category":"section"},{"location":"man/csg/#","page":"CSG","title":"CSG","text":"ToDo...","category":"page"},{"location":"man/primitives/#CSG-Primitives-1","page":"Primitives","title":"CSG Primitives","text":"","category":"section"},{"location":"man/primitives/#","page":"Primitives","title":"Primitives","text":"CSG = Constructive Solid Geometries","category":"page"},{"location":"man/primitives/#Primitve:-Box-1","page":"Primitives","title":"Primitve: Box","text":"","category":"section"},{"location":"man/primitives/#","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"box\",\n    \"x\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    },\n    \"y\":{\n        \"from\": 0.0,\n        \"to\":  10.0\n    },\n    \"z\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    }\n}","category":"page"},{"location":"man/primitives/#Primitve:-Tube-1","page":"Primitives","title":"Primitve: Tube","text":"","category":"section"},{"location":"man/primitives/#","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"tube\",\n    \"r\": {\n        \"from\": 3.0,\n        \"to\":   7.0\n    },\n    \"phi\": {\n        \"from\": 0.0,\n        \"to\": 360.0\n    },\n    \"z\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    }\n}","category":"page"},{"location":"man/primitives/#Primitve:-Cone-1","page":"Primitives","title":"Primitve: Cone","text":"","category":"section"},{"location":"man/primitives/#","page":"Primitives","title":"Primitives","text":"{\n    \"type\": \"cone\",\n    \"r\": {\n        \"bottom\": {\n            \"from\": 10.0,\n            \"to\": 20.0\n        },\n        \"top\": {\n            \"from\": 5.0,\n            \"to\": 25.0\n        }\n    },\n    \"phi\": {\n        \"from\": 0.0,\n        \"to\": 360.0\n    },\n    \"z\": {\n        \"from\": 0.0,\n        \"to\":  10.0\n    }\n}","category":"page"},{"location":"man/electric_potentials/#Electric-Potentials-1","page":"Electric Potentials","title":"Electric Potentials","text":"","category":"section"},{"location":"man/electric_potentials/#Simulation-Algorithm-1","page":"Electric Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"The electric potential is calculated through successive over relaxation (SOR).","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"The calculation is based on Gauss' law in matter","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"nabla left( epsilon_r(vecr) nabla Phi(vecr)right) = dfracrho(vecr)epsilon_0","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"where Phi is the electric potential, rho is the charge density, epsilon_r is the dielectric distribution and epsilon_0 is the dielectric constant of the vacuum.","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"The equation is numerically solved on a 3-dimensional adaptive red/black grid.","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"The red/black division allows for multithreading and the adaptive grid saves computation time since it only increases the grid point density in areas where it is critical.","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"Cylindrical and cartesian coordinates are supported.","category":"page"},{"location":"man/electric_potentials/#Multithreading-1","page":"Electric Potentials","title":"Multithreading","text":"","category":"section"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"To use multiple threads for the simulation, the environement variable JULIA_NUM_THREADS must be set before Julia is started. In case of bash this is done through","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"Note that the user still has to parse the number of threads to the function as a keyword nthreads.","category":"page"},{"location":"man/electric_potentials/#","page":"Electric Potentials","title":"Electric Potentials","text":"ToDo...","category":"page"},{"location":"man/weighting_potentials/#Weighting-Potentials-1","page":"Weighting Potentials","title":"Weighting Potentials","text":"","category":"section"},{"location":"man/weighting_potentials/#Simulation-Algorithm-1","page":"Weighting Potentials","title":"Simulation Algorithm","text":"","category":"section"},{"location":"man/weighting_potentials/#","page":"Weighting Potentials","title":"Weighting Potentials","text":"The weighting potential for an electrode is internally calculated with the same function as the electric potential.","category":"page"},{"location":"man/weighting_potentials/#","page":"Weighting Potentials","title":"Weighting Potentials","text":"The only difference is that the charge carrier density ρ(vecr) is set to 0 and all electrodes are fixed to 0 but the one electrode which is fixed to 1.","category":"page"},{"location":"man/weighting_potentials/#","page":"Weighting Potentials","title":"Weighting Potentials","text":"ToDo...","category":"page"},{"location":"man/electric_fields/#Electric-Fields-1","page":"Electric Fields","title":"Electric Fields","text":"","category":"section"},{"location":"man/electric_fields/#","page":"Electric Fields","title":"Electric Fields","text":"ToDo...","category":"page"},{"location":"man/drift_fields/#Drift-Fields-1","page":"Drift Fields","title":"Drift Fields","text":"","category":"section"},{"location":"man/drift_fields/#","page":"Drift Fields","title":"Drift Fields","text":"ToDo...","category":"page"},{"location":"man/IO/#IO-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/IO/#","page":"IO","title":"IO","text":"ToDo...","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Example-1:-Inverted-Coax-Detector-1","page":"Tutorial","title":"Example 1: Inverted Coax Detector","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"ToDo... explanation","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots; pyplot();\nusing SolidStateDetectors\n\nT = Float32\ndetector = SolidStateDetector{T}(SSD_examples[:InvertedCoax])\n\nsimulation = Simulation(detector)\n\nsimulate!(simulation, max_refinements = 3)\n\np_ep = plot(simulation.electric_potential)","category":"page"},{"location":"tutorial/#Example-2:-ToDo...-1","page":"Tutorial","title":"Example 2: ToDo...","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"ToDo... #- This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"DocTestSetup  = quote\r\n    using SolidStateDetectors\r\nend","category":"page"},{"location":"api/#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions-1","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation-1","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [SolidStateDetectors]\r\nOrder = [:type, :function]","category":"page"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{PotentialSimulationSetup{T,3,:cartesian}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, :cartesian} ; kwargs...)::ElectricPotential{T, 3, :cartesian}\n\nExtracts the electric potential from setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(setup::PotentialSimulationSetup{T, 3, :cylindrical} ; kwargs...)::ElectricPotential{T, 3, :cylindrical}\n\nExtracts the electric potential from setup and extrapolate it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.ElectricPotential-Union{Tuple{SolidStateDetector{T,CS} where CS}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.ElectricPotential","text":"ElectricPotential(detector::SolidStateDetector{T}; kwargs...) where {T}\n\nCalls calculate_electric_potential(detector; kwargs...) end extracts only the electric potential and returns it.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.Grid","page":"API","title":"SolidStateDetectors.Grid","text":"T: tick type\nN: N dimensional\nS: System (Cartesian, Cylindrical...)\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes{T, N, S} <: AbstractArray{T, N}\n\nPointTypes stores the point type of each grid point.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointTypes-Union{Tuple{PotentialSimulationSetup{T,3,:cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.PointTypes","text":"PointTypes(setup::PotentialSimulationSetup{T, 3, :cylindrical} ; kwargs...)::PointTypes{T, 3, :cylindrical}\n\nExtracts the electric potential from setup and extrapolate it to an 2π grid.\n\nFor 2D grids (r and z) the user has to set the keyword n_points_in_φ::Int, e.g.: n_points_in_φ = 36.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.SolidStateDetector","page":"API","title":"SolidStateDetectors.SolidStateDetector","text":"mutable struct SolidStateDetector{T <: SSDFloat, CS} <: AbstractConfig{T}\n\nCS: Coordinate System: -> :cartesian / :cylindrical\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.VacuumChargeDriftModel","page":"API","title":"SolidStateDetectors.VacuumChargeDriftModel","text":"VacuumChargeDriftModel <: AbstractChargeDriftModel\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.WeightingPotential-Union{Tuple{T}, Tuple{SolidStateDetector{T,CS} where CS,Int64}} where T","page":"API","title":"SolidStateDetectors.WeightingPotential","text":"WeightingPotential(detector::SolidStateDetector{T}, channel_id::Int; kwargs...) where {T}\n\nCalls calculate_weighting_potential(detector, channel_id; kwargs...) end extracts only the weighting potential and returns it.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.add_fano_noise","page":"API","title":"SolidStateDetectors.add_fano_noise","text":"add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity\n\nAdd Fano noise to an energy deposition E_dep, assuming a detector material ionisation energy E_ionisation and a Fano factor f_fano.\n\n\n\n\n\n","category":"function"},{"location":"api/#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T,3,:cylindrical}}, Tuple{T}} where T","page":"API","title":"SolidStateDetectors.get_active_volume","text":"get_active_volume(pts::PointTypes{T}) where {T}\n\nReturns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.point_type-Union{Tuple{T}, Tuple{SolidStateDetector{T,CS} where CS,Grid{T,3,S} where S,CartesianPoint{T}}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.point_type","text":"For charge drift...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T}}, Tuple{T}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.simulate!","text":"function simulate!(sim::Simulation{T};  max_refinements::Int = 1, verbose::Bool = false, \n                                    depletion_handling::Bool = false, convergence_limit::Real = 1e-5 ) where {T <: SSDFloat}\n\nToDo...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.AbstractConfig","page":"API","title":"SolidStateDetectors.AbstractConfig","text":"abstract type AbstractConfig{T <: SSDFloat} end\n\nSupertype of all detector/world/object configs.\n\nUser defined geometries must be subtype of AbstractConfig{T}.\n\nThere are a few functions which must be defined for a user config, e.g. struct UserConfig{T} <: AbstractConfig{T}:\n\nFor cylindrical grids:\n\nin(pt::cylindrical{T}, config::UserConfig{T})::Bool where {T <: SSDFloat}\nGrid(config::UserConfig{T})::Grid{T, 3, :cylindrical} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::cylindrical{T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, :cylindrical}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\nFor cartesian grids:\n\nin(pt::StaticVector{3, T}, config::UserConfig{T})::Bool \nGrid(config::UserConfig{T})::Grid{T, 3, :cartesian} where {T <: SSDFloat}\nget_ρ_and_ϵ(pt::StaticVector{3, T}, config::UserConfig{T})::Tuple{T, T} where {T <: SSDFloat} \nset_pointtypes_and_fixed_potentials!(pointtypes::Array{PointType, 3}, potential::Array{T, 3},        grid::Grid{T, 3, :cartesian}, config::UserConfig{T}; weighting_potential_channel_idx::Union{Missing, Int} = missing)::Nothing where {T <: SSDFloat}\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.AbstractLine","page":"API","title":"SolidStateDetectors.AbstractLine","text":"abstract type AbstractLine{T, N, S} <: AbstractGeometry{T, N} end\n\nT: eltype N: Dimension S: Coordinate System: :cartesian or :cylindrical\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Box","page":"API","title":"SolidStateDetectors.Box","text":"mutable struct Box{T} <: AbstractGeometry{T, 3}\n\nVery simple rectengular box in cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Contact","page":"API","title":"SolidStateDetectors.Contact","text":"mutable struct Contact{T} <: AbstractContact{T}\n\nT: Type of precision.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Difference","page":"API","title":"SolidStateDetectors.Difference","text":"struct Difference{T, N, A, B} <: AbstractSet{T, N}\n\na && !b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis{T, BL, BR} <: AbstractAxis{T, BL, BR}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nBL: left boundary condition\nBR: right boundary condition\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T,T,Symbol,Symbol,Symbol,Symbol,AbstractArray{T,1}}} where T","page":"API","title":"SolidStateDetectors.DiscreteAxis","text":"DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}\n\nT: Type of ticks\nBL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed} \nL, R {:closed, :open} \nticks: Ticks of the axis\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.Event","page":"API","title":"SolidStateDetectors.Event","text":"mutable struct Event{T <: SSDFloat}\n\nCollection struct for individual events. This (mutable) struct is ment to be used to look at individual events, not to process a hugh amount of events.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.GeometryUnion","page":"API","title":"SolidStateDetectors.GeometryUnion","text":"struct GeometryUnion{T, N, A, B} <: AbstractSet{T, N}\n\na || b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Intersection","page":"API","title":"SolidStateDetectors.Intersection","text":"struct Intersection{T, N, A, B} <: AbstractSet{T, N}\n\na && b\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Line","page":"API","title":"SolidStateDetectors.Line","text":"struct Line{T, N, S} <: AbstractLine{T, N, S}\n\n<––A–––––B––>\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LineSegment","page":"API","title":"SolidStateDetectors.LineSegment","text":"struct LineSegment{T, N, S} <: AbstractLine{T, N, S}\n\n[A----------B]\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.LinearChargeDensityModel","page":"API","title":"SolidStateDetectors.LinearChargeDensityModel","text":"struct LinearChargeDensityModel{T <: SSDFloat} <: AbstractChargeDensityModel{T}\n\nSimple charge density model which assumes a linear gradient in charge density in each dimension. offsets::NTuple{3, T} are the charge densities at 0 and gradients::NTuple{3, T} are the linear slopes in each dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PointType","page":"API","title":"SolidStateDetectors.PointType","text":"const PointType = UInt8\n\nStores certain information about a grid point via bit-flags. \n\nRight now there are:\n\n`const update_bit      = 0x01`\n`const undepleted_bit  = 0x02`\n`const pn_junction_bit = 0x04`\n\nHow to get information out of a PointType variable pt:\n\npt & update_bit == 0 -> do not update this point (for fixed points)     \npt & update_bit >  0 -> do update this point    \npt & undepleted_bit > 0 -> this point is undepleted\npt & pn_junction_bit > 0 -> this point belongs to the solid state detector. So it is in the volume of the n-type or p-type material.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.PotentialSimulationSetup","page":"API","title":"SolidStateDetectors.PotentialSimulationSetup","text":"PotentialSimulationSetup{T, N, S} <: AbstractPotentialSimulationSetup{T, N}\n\nCollection struct. It holds the grid, the potential, the point types, the charge density and the dielectric distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.Ray","page":"API","title":"SolidStateDetectors.Ray","text":"struct Ray{T, N, S} <: AbstractLine{T, N, S}\n\n[A----------B---->\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.RectangularCuboid","page":"API","title":"SolidStateDetectors.RectangularCuboid","text":"struct RectangularCuboid{T} <: AbstractGeometry{T, 3}\n\n...\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.ZeroChargeDensityModel","page":"API","title":"SolidStateDetectors.ZeroChargeDensityModel","text":"struct ZeroChargeDensityModel{T <: SSDFloat} <: AbstractChargeDensityModel{T}\n\nReturns always 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SolidStateDetectors.RBArray-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T","page":"API","title":"SolidStateDetectors.RBArray","text":"RBExtBy2Array( et::Type, g::Grid{T, N, :cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{N}, Tuple{T}, Tuple{Type,Grid{T,N,:cylindrical}}} where N where T","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, N, :cylindrical} )::Array{et, N + 1} where {T, N}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.RBExtBy2Array-Union{Tuple{T}, Tuple{Type,Grid{T,3,:cartesian}}} where T","page":"API","title":"SolidStateDetectors.RBExtBy2Array","text":"RBExtBy2Array( et::Type, g::Grid{T, 3, :cartesian} )::Array{et, 4} where {T}\n\nReturns a RedBlack array for the grid g. The RedBlack array is extended in its size by 2 in each geometrical dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_electric_potential-Union{Tuple{SolidStateDetector{T,:cylindrical}}, Tuple{S}, Tuple{N}, Tuple{T}} where S where N where T","page":"API","title":"SolidStateDetectors.calculate_electric_potential","text":"calculate_electric_potential(det::SolidStateDetector{T}; <keyword arguments>) where {T}\n\nCompute the electric potential for the given Detector det on an adaptive grid through successive over relaxation. It returns a collection struct PotentialSimulationSetup{T} which stores the potential, the charge density, the dielectric distribution, pointtypes and the final grid.\n\nThere are serveral <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation. The convergence value is the absolute maximum difference of the potential between two iterations of all grid points. Default of convergence_limit is 5e-6 (times bias voltage).\nmax_refinements::Int: number of maximum refinements. Default is 2. Set it to 0 to switch off refinement.\nrefinement_limits::Vector{Real}: vector of refinement limits for each dimension (in case of cylindrical coordinates the order is r, φ, z). A refinement limit (e.g. refinement_limits[1]) times the bias voltage of the detector det is the maximum allowed voltage difference between two neighbouring grid points in the respective dimension. When the difference is larger, new points are created inbetween. Default is [1e-4, 1e-4, 1e-4].\ninit_grid_spacing::Vector{Real}: vector of the initial distances between two grid points for each dimension. For normal coordinates the unit is meter. For angular coordinates, the unit is radiance. It prevents the refinement to make the grid to fine. Default is [0.005, 10.0, 0.005]`.\nmin_grid_spacing::Vector{Real}: vector of the mimimum allowed distance between two grid points for each dimension. For normal coordinates the unit is meter. For angular coordinates, the unit is radiance. It prevents the refinement to make the grid to fine. Default is [1e-4, 1e-2, 1e-4].\ngrid::Grid{T, N, S}: Initial grid used to start the simulation. Default is Grid(detector, init_grid_spacing=init_grid_spacing).\ndepletion_handling::Bool: enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads(). The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Vector{<:Real}: Two element array. First element contains the SOR constant for r = 0. Second contains the constant at the outer most grid point in r. A linear scaling is applied in between. First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement. Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\ninit_grid_spacing::Vector{<:Real}: Initial spacing of the grid. Default is [2e-3, 5, 2e-3] <=> [2mm, 5 degree, 2mm ]\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.calculate_weighting_potential-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{SolidStateDetector{T,:cylindrical},Int64}} where S where N where T","page":"API","title":"SolidStateDetectors.calculate_weighting_potential","text":"calculate_weighting_potential(det::SolidStateDetector{T}, channel_id::Int; <keyword arguments>) where {T}\n\nCompute the weighting potential for the given Detector det on an adaptive grid through successive over relaxation. It returns a collection struct PotentialSimulationSetup{T} which stores the potential, the charge density, the dielectric distribution, pointtypes and the final grid.\n\nThere are serveral <keyword arguments> which can be used to tune the computation:\n\nKeywords\n\nconvergence_limit::Real: convergence_limit times the bias voltage sets the convergence limit of the relaxation. The convergence value is the absolute maximum difference of the potential between two iterations of all grid points. Default of convergence_limit is 5e-6 (times bias voltage).\nmax_refinements::Int: number of maximum refinements. Default is 2. Set it to 0 to switch off refinement.\nrefinement_limits::Vector{Real}: vector of refinement limits for each dimension (in case of cylindrical coordinates the order is r, φ, z). A refinement limit (e.g. refinement_limits[1]) times the bias voltage of the detector det is the maximum allowed voltage difference between two neighbouring grid points in the respective dimension. When the difference is larger, new points are created inbetween. Default is [1e-4, 1e-4, 1e-4].\ninit_grid_spacing::Vector{Real}: vector of the initial distances between two grid points for each dimension. For normal coordinates the unit is meter. For angular coordinates, the unit is radiance. It prevents the refinement to make the grid to fine. Default is [0.005, 10.0, 0.005]`.\nmin_grid_spacing::Vector{Real}: vector of the mimimum allowed distance between two grid points for each dimension. For normal coordinates the unit is meter. For angular coordinates, the unit is radiance. It prevents the refinement to make the grid to fine. Default is [1e-4, 1e-2, 1e-4].\ngrid::Grid{T, N, S}: Initial grid used to start the simulation. Default is Grid(detector, init_grid_spacing=init_grid_spacing).\ndepletion_handling::Bool: enables the handling of undepleted regions. Default is false.\nuse_nthreads::Int: Number of threads to use in the computation. Default is Base.Threads.nthreads(). The environment variable JULIA_NUM_THREADS must be set appropriately before the Julia session was started (e.g. export JULIA_NUM_THREADS=8 in case of bash).\nsor_consts::Vector{<:Real}: Two element array. First element contains the SOR constant for r = 0. Second contains the constant at the outer most grid point in r. A linear scaling is applied in between. First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].\nmax_n_iterations::Int: Set the maximum number of iterations which are performed after each grid refinement. Default is 10000. If set to -1 there will be no limit.\nverbose::Bool=true: Boolean whether info output is produced or not.\ninit_grid_spacing::Vector{<:Real}: Initial spacing of the grid. Default is [2e-3, 5, 2e-3] <=> [2mm, 5 degree, 2mm ]\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},SolidStateDetector{T,:cartesian},PointTypes{T,3,:cartesian},Grid{T,3,:cartesian},CartesianPoint{T},T,Extrapolation{#s337,3,ITPT,IT,ET} where ET where IT where ITPT where #s337<:(StaticArray{Tuple{3},T,1} where T)}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.drift_charge!","text":"Before calling this function one should check that `startpos` is inside `det`: `in(startpos, det`\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.drift_charge!-Union{Tuple{T}, Tuple{Array{CartesianPoint{T},1},SolidStateDetector{T,:cylindrical},PointTypes{T,3,:cylindrical},Grid{T,3,:cylindrical},CartesianPoint{T},T,Extrapolation{#s337,3,ITPT,IT,ET} where ET where IT where ITPT where #s337<:(StaticArray{Tuple{3},T,1} where T)}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.drift_charge!","text":"drift_charge(...)\n\nBefore calling this function one should check that startpos is inside det: in(startpos, det\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_electron_drift_field-Union{Tuple{T}, Tuple{Array{SArray{Tuple{3},T,1,3},3},ADLChargeDriftModel}} where T<:Union{Float16, Float32, Float64}","page":"API","title":"SolidStateDetectors.get_electron_drift_field","text":"get_electron_drift_field(ef::Array{SVector{3, T},3}, chargedriftmodel::ADLChargeDriftModel)::Array{SVector{3,T},3} where {T <: SSDFloat}\n\nApplies the charge drift model onto the electric field vectors. The field vectors have to be in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_path_to_example_config_files-Tuple{}","page":"API","title":"SolidStateDetectors.get_path_to_example_config_files","text":"get_path_to_example_config_files()::String\n\nReturns the path to example config files provided by the package.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.get_rbidx_right_neighbour-Tuple{Int64,Val{true},Val{true}}","page":"API","title":"SolidStateDetectors.get_rbidx_right_neighbour","text":"get_rbidx_right_neighbour(rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nneeds docu...\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},PotentialSimulationSetupRB{T,3,4,:cartesian},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential}}} where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  iz::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_x::Array{T, 2}, gw_y::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, :cartesian},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                            bulk_is_ptype::Val{_bulk_is_ptype}  )::Nothing where {T, even_points, depletion_handling_enabled, _bulk_is_ptype}\n\n(Vectorized) inner loop for Cartesian coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.innerloops!-Union{Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{T}, Tuple{Int64,Int64,Int64,Array{T,2},Array{T,2},Array{T,2},PotentialSimulationSetupRB{T,3,4,:cylindrical},Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential}}} where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where T","page":"API","title":"SolidStateDetectors.innerloops!","text":"innerloops!(  ir::Int, rb_tar_idx::Int, rb_src_idx::Int, gw_r::Array{T, 2}, gw_φ::Array{T, 2}, gw_z::Array{T, 2}, fssrb::PotentialSimulationSetupRB{T, 3, 4, :cylindrical},\n                            update_even_points::Val{even_points},\n                            depletion_handling::Val{depletion_handling_enabled},\n                            bulk_is_ptype::Val{_bulk_is_ptype}  )::Nothing where {T, even_points, depletion_handling_enabled, _bulk_is_ptype}\n\n(Vectorized) inner loop for Cylindrical coordinates. This function does all the work in the field calculation.                            \n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.nidx-Tuple{Int64,Val{true},Val{true}}","page":"API","title":"SolidStateDetectors.nidx","text":"nidx( rbidx::Int, ::Val{true}, ::Val{true})::Int\n\nfirst type argument:  type of the orgal point (for even points -> Val{true}(), else Val{false}()) second type argument: is sum of other point indices even or odd -> (if sum is even -> Val{true}(), else Val{false}())\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.parse_config_file-Tuple{AbstractString}","page":"API","title":"SolidStateDetectors.parse_config_file","text":"SolidStateDetector{T}(filename::AbstractString)::SolidStateDetector{T} where {T <: SSDFloat}\n\nReads in a config-JSON file and returns an Detector struct which holds all information specified in the config file.\n\n\n\n\n\n","category":"method"},{"location":"api/#SolidStateDetectors.update!-Union{Tuple{_is_weighting_potential}, Tuple{_bulk_is_ptype}, Tuple{depletion_handling_enabled}, Tuple{even_points}, Tuple{S}, Tuple{T}, Tuple{PotentialSimulationSetupRB{T,3,4,S},Int64,Val{even_points},Val{depletion_handling_enabled},Val{_bulk_is_ptype},Val{_is_weighting_potential}}} where _is_weighting_potential where _bulk_is_ptype where depletion_handling_enabled where even_points where S where T","page":"API","title":"SolidStateDetectors.update!","text":"update!(fssrb::PotentialSimulationSetupRB{T, 3, 4, S}, RBT::DataType)::Nothing\n\nLoop over even grid points. A point is even if the sum of its cartesian indicies (of the not extended grid) is even. Even points get the red black index (rbi) = 2. ( -> rbpotential[ inds..., rbi ]).\n\n\n\n\n\n","category":"method"},{"location":"LICENSE/#LICENSE-1","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/#","page":"LICENSE","title":"LICENSE","text":"using Markdown\r\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"}]
}
