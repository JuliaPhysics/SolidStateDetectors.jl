<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SolidStateDetectors.jl</title><link rel="canonical" href="https://JuliaHEP.github.io/SolidStateDetectors.jl/stable/api/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SolidStateDetectors.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/installation/">Installation</a></li><li><a class="toctext" href="../man/detectors/">Detectors</a></li><li><a class="toctext" href="../man/electric_potentials/">Electric Potentials</a></li><li><a class="toctext" href="../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="toctext" href="../man/electric_fields/">Electric Fields</a></li><li><a class="toctext" href="../man/drift_fields/">Drift Fields</a></li><li><a class="toctext" href="../man/IO/">IO</a></li></ul></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li class="toplevel"><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="../LICENSE/">LICENSE</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><ul><li><a href="#SolidStateDetectors.ADLChargeDriftModel"><code>SolidStateDetectors.ADLChargeDriftModel</code></a></li><li><a href="#SolidStateDetectors.CylindricalGrid"><code>SolidStateDetectors.CylindricalGrid</code></a></li><li><a href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a></li><li><a href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a></li><li><a href="#SolidStateDetectors.SolidStateDetector-Union{Tuple{AbstractString}, Tuple{T}} where T&lt;:AbstractFloat"><code>SolidStateDetectors.SolidStateDetector</code></a></li><li><a href="#SolidStateDetectors.VacuumChargeDriftModel"><code>SolidStateDetectors.VacuumChargeDriftModel</code></a></li></ul><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><ul><li><a href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_potential-Tuple{SolidStateDetector}"><code>SolidStateDetectors.calculate_electric_potential</code></a></li><li><a href="#SolidStateDetectors.calculate_weighting_potential-Tuple{SolidStateDetector,Int64}"><code>SolidStateDetectors.calculate_weighting_potential</code></a></li><li><a href="#SolidStateDetectors.extent_2D_grid_to_3D-Tuple{CylindricalGrid,Int64}"><code>SolidStateDetectors.extent_2D_grid_to_3D</code></a></li><li><a href="#SolidStateDetectors.extent_2D_grid_to_3D!-Tuple{CylindricalGrid,Int64}"><code>SolidStateDetectors.extent_2D_grid_to_3D!</code></a></li><li><a href="#SolidStateDetectors.get_active_volume-Union{Tuple{T}, Tuple{CylindricalGrid,PointTypes{T}}} where T"><code>SolidStateDetectors.get_active_volume</code></a></li><li><a href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a></li><li><a href="#SolidStateDetectors.read_from_hdf5-Tuple{Any,Type{PointTypes}}"><code>SolidStateDetectors.read_from_hdf5</code></a></li><li><a href="#SolidStateDetectors.read_from_hdf5-Tuple{Any,Type{CylindricalGrid}}"><code>SolidStateDetectors.read_from_hdf5</code></a></li><li><a href="#SolidStateDetectors.write_to_hdf5-Tuple{Any,CylindricalGrid}"><code>SolidStateDetectors.write_to_hdf5</code></a></li><li><a href="#SolidStateDetectors.write_to_hdf5-Tuple{Any,PointTypes}"><code>SolidStateDetectors.write_to_hdf5</code></a></li></ul><h1><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.ADLChargeDriftModel" href="#SolidStateDetectors.ADLChargeDriftModel"><code>SolidStateDetectors.ADLChargeDriftModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ADLChargeDriftModel{T &lt;: AbstractFloat} &lt;: AbstractChargeDriftModels</code></pre><p><strong>Fields</strong></p><ul><li><code>electrons::CarrierParameters{T}</code></li><li><code>holes::CarrierParameters{T}</code></li><li>`phi110::T</li><li><code>gammas::SVector{4, SMatrix{3,3,T}}</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/ChargeDriftModels/ChargeDriftModels.jl#L57-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.CylindricalGrid" href="#SolidStateDetectors.CylindricalGrid"><code>SolidStateDetectors.CylindricalGrid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CylindricalGrid{T&lt;:AbstractFloat} &lt;: Grid</code></pre><p>Stores the electric potential on a three dimensional cylindrical grid and also the position of the grid points.</p><p><strong>Fields</strong></p><ul><li><code>cyclic::T</code>: Stores the periodicity of the system. E.g. 2π.</li><li><code>r::T</code>: The r-axis of the grid in <code>m</code>.</li><li><code>φ::T</code>: The φ-axis of the grid in <code>rad</code>.</li><li><code>z::T</code>: The r-axis of the grid in <code>m</code>.</li><li><code>potential::Array{T, 3}</code>: The potential values in <code>V</code> of each grid point.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Grids/CylindricalGrid.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.PointTypes" href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PointTypes{T &lt;: AbstractFloat} &lt;: AbstractPointTypes</code></pre><p>Stores the point type information in a three dimensional cylindrical grid and also the position of the grid points.</p><p><strong>Fields</strong></p><ul><li><code>r::T</code>: The r-axis of the grid in <code>m</code>.</li><li><code>φ::T</code>: The φ-axis of the grid in <code>rad</code>.</li><li><code>z::T</code>: The r-axis of the grid in <code>m</code>.</li><li><code>pointtypes::Array{PointType, 3}</code>: The point type of each grid point.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Types/point_type.jl#L28-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.SolidStateDetector-Union{Tuple{AbstractString}, Tuple{T}} where T&lt;:AbstractFloat" href="#SolidStateDetectors.SolidStateDetector-Union{Tuple{AbstractString}, Tuple{T}} where T&lt;:AbstractFloat"><code>SolidStateDetectors.SolidStateDetector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SolidStateDetector{T}(filename::AbstractString)::SolidStateDetector where T &lt;: AbstractFloat</code></pre><p>Reads in a config-JSON file and returns an Detector struct which holds all information specified in the config file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/DetectorGeometries/DetectorGeometries.jl#L59-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.VacuumChargeDriftModel" href="#SolidStateDetectors.VacuumChargeDriftModel"><code>SolidStateDetectors.VacuumChargeDriftModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VacuumChargeDriftModel &lt;: AbstractChargeDriftModels</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/ChargeDriftModels/ChargeDriftModels.jl#L4-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.add_fano_noise" href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity</code></pre><p>Add Fano noise to an energy deposition <code>E_dep</code>, assuming a detector material ionisation energy <code>E_ionisation</code> and a Fano factor <code>f_fano</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/ChargeStatistics/ChargeStatistics.jl#L4-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_potential-Tuple{SolidStateDetector}" href="#SolidStateDetectors.calculate_electric_potential-Tuple{SolidStateDetector}"><code>SolidStateDetectors.calculate_electric_potential</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calculate_electric_potential(det::SolidStateDetector; &lt;keyword arguments&gt;)::Tuple{&lt;:Grid, PointTypes}</code></pre><p>Compute the electric potential for the given Detector <code>det</code> on an adaptive grid through successive over relaxation.</p><p>There are serveral <code>&lt;keyword arguments&gt;</code> which can be used to tune the computation:</p><p><strong>Keywords</strong></p><ul><li><code>coordinates::Symbol</code>: the kind of the coordinate system of the grid. Right now only <code>:cylindrical</code> is possible.</li><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation. The convergence value is the absolute maximum difference of the potential between two iterations of all grid points. Default of <code>convergence_limit</code> is <code>5e-6</code> (times bias voltage).</li><li><code>max_refinements::Int</code>: number of maximum refinements. Default is <code>2</code>. Set it to <code>0</code> to switch off refinement.</li><li><code>refinement_limits::Vector{Real}</code>: vector of refinement limits for each dimension (in case of cylindrical coordinates the order is <code>r</code>, <code>φ</code>, <code>z</code>). A refinement limit (e.g. <code>refinement_limits[1]</code>) times the bias voltage of the detector <code>det</code> is the maximum allowed voltage difference between two neighbouring grid points in the respective dimension. When the difference is larger, new points are created inbetween. Default is <code>[1e-4, 1e-4, 1e-4]</code>.</li><li><code>min_grid_spacing::Vector{Real}</code>: vector of the mimimum allowed distance between two grid points for each dimension. For normal coordinates the unit is meter. For angular coordinates, the unit is radiance. It prevents the refinement to make the grid to fine. Default is [<code>1e-4</code>, <code>1e-2</code>, <code>1e-4</code>].</li><li><code>depletion_handling::Bool</code>: enables the handling of undepleted regions. Default is false.</li><li><code>nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>. The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Vector{&lt;:Real}</code>: Two element array. First element contains the SOR constant for <code>r</code> = 0. Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between. First element should be smaller than the second one and both should be ∈ [1.0, 2.0]. Default is [1.4, 1.85].</li><li><code>return_2π_grid::Bool</code>: If set to <code>true</code>, the grid is extended to 2π in <code>φ</code> after it is computated. Default is <code>true</code>. This keyword is ignored if the simulation is in 2D. Use <code>extent_2D_grid_to_3D()</code> function to extend a 2D grid into 3D.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement. Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li><li><code>init_grid_spacing::Vector{&lt;:Real}</code>: Initial spacing of the grid. Default is [2e-3, 2π / 72, 2e-3] &lt;=&gt; [2mm, 5 degree, 2mm ]</li></ul><p><strong>Additional Information</strong></p><ul><li>The function always turns the detector into a p-type detector to compute the potential. At the end it turns the signs to make it n-type again if it was n-type.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Potentials/CalculateElectricPotential.jl#L1-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.calculate_weighting_potential-Tuple{SolidStateDetector,Int64}" href="#SolidStateDetectors.calculate_weighting_potential-Tuple{SolidStateDetector,Int64}"><code>SolidStateDetectors.calculate_weighting_potential</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">calculate_weighting_potential(det::SolidStateDetector, channels::Array{Int, 1}; &lt;keyword arguments&gt;)::Grid</code></pre><p>Compute the weighting potential of the <code>channels</code> of the given Detector <code>det</code> on an adaptive grid through successive over relaxation. <code>channels</code> is a list of the channels which are fixed to 1. All other channels are fixed to 0.</p><p>There are serveral <code>&lt;keyword arguments&gt;</code> which can be used to tune the computation:</p><p><strong>Keywords</strong></p><ul><li><code>coordinates::Symbol</code>: the kind of the coordinate system of the grid. Right now only <code>:cylindrical</code> is possible.</li><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation. The convergence value is the absolute maximum difference of the potential between two iterations of all grid points. Default of <code>convergence_limit</code> is <code>5e-6</code> (times bias voltage).</li><li><code>max_refinements::Int</code>: number of maximum refinements. Default is <code>2</code>. Set it to <code>0</code> to switch off refinement.</li><li><code>refinement_limits::Vector{Real}</code>: vector of refinement limits for each dimension (in case of cylindrical coordinates the order is <code>r</code>, <code>φ</code>, <code>z</code>). A refinement limit (e.g. <code>refinement_limits[1]</code>) times the bias voltage of the detector <code>det</code> is the maximum allowed voltage difference between two neighbouring grid points in the respective dimension. When the difference is larger, new points are created inbetween. Default is <code>[1e-4, 1e-4, 1e-4]</code>.</li><li><code>min_grid_spacing::Vector{Real}</code>: vector of the mimimum allowed distance between two grid points for each dimension. For normal coordinates the unit is meter. For angular coordinates the unit is radiance. It prevents the refinement to make the grid to fine. Default is [<code>1e-4</code>, <code>1e-2</code>, <code>1e-4</code>].</li><li><code>depletion_handling::Bool</code>: NOT IMPLEMENTET YET. Enables the handling of undepleted regions. Default is false.</li><li><code>nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>. The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Vector{&lt;:Real}</code>: Two element array. First element contains the SOR constant for <code>r</code> = 0. Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between. First element should be smaller than the second one and both should be ∈ [1.0, 2.0].</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement. Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li><li><code>init_grid_spacing::Vector{&lt;:Real}</code>: Initial spacing of the grid. Default is [2e-3, 2π / 72, 2e-3] &lt;=&gt; [2mm, 5 degree, 2mm ]</li></ul><p><strong>Additional Information</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Potentials/CalculateWeightingPotential.jl#L1-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.get_active_volume-Union{Tuple{T}, Tuple{CylindricalGrid,PointTypes{T}}} where T" href="#SolidStateDetectors.get_active_volume-Union{Tuple{T}, Tuple{CylindricalGrid,PointTypes{T}}} where T"><code>SolidStateDetectors.get_active_volume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_active_volume(grid::CylindricalGrid, pts::PointTypes{T}) where {T}</code></pre><p>Returns an approximation of the active volume of the detector by summing up the cell volumes of all depleted cells.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Potentials/PrecalculatedWeightsCylindricalRedBlack.jl#L358-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.PointType" href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">const PointType = UInt8</code></pre><p>Stores certain information about a grid point via bit-flags. </p><p>Right now there are:</p><pre><code class="language-none">`const update_bit      = 0x01`
`const undepleted_bit  = 0x02`
`const bubble_bit      = 0x04`
`const pn_junction_bit = 0x08`</code></pre><p>How to get information out of a PointType variable <code>pt</code>:</p><ol><li><code>pt &amp; update_bit == 0</code> -&gt; do not update this point (for fixed points)     </li><li><code>pt &amp; update_bit &gt;  0</code> -&gt; do update this point    </li><li><code>pt &amp; undepleted_bit &gt; 0</code> -&gt; this point is undepleted</li><li><code>pt &amp; bubble_bit &gt; 0</code>     -&gt; this point is in an &quot;bubble&quot;-area/volume. So an undepleted region which is not in contact with an electrode (fixed points).</li><li><code>pt &amp; pn_junction_bit &gt; 0</code>  -&gt; this point to the solid state detector. So it is in the volume of the n-type or p-type material.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Types/point_type.jl#L1-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.extent_2D_grid_to_3D!-Tuple{CylindricalGrid,Int64}" href="#SolidStateDetectors.extent_2D_grid_to_3D!-Tuple{CylindricalGrid,Int64}"><code>SolidStateDetectors.extent_2D_grid_to_3D!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extent_2D_grid_to_3D!(grid::CylindricalGrid, n::Int)::Nothing</code></pre><p>This function extend a 2-dimensional grid (only one tick in φ) to an 3-dimensional grid with n ticks in φ (symmetrically distributed up to 2π).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Grids/CylindricalGrid.jl#L380-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.extent_2D_grid_to_3D-Tuple{CylindricalGrid,Int64}" href="#SolidStateDetectors.extent_2D_grid_to_3D-Tuple{CylindricalGrid,Int64}"><code>SolidStateDetectors.extent_2D_grid_to_3D</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extent_2D_grid_to_3D(grid::CylindricalGrid, n::Int)::CylindricalGrid</code></pre><p>This function returns a extended grid of a 2-dimensional grid <code>grid</code>. The extended grid has n ticks in φ (symmetrically distributed up to 2π).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/Grids/CylindricalGrid.jl#L359-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.get_path_to_example_config_files-Tuple{}" href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_path_to_example_config_files()::String</code></pre><p>Returns the path to example config files provided by the package.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/examples.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.read_from_hdf5-Tuple{Any,Type{CylindricalGrid}}" href="#SolidStateDetectors.read_from_hdf5-Tuple{Any,Type{CylindricalGrid}}"><code>SolidStateDetectors.read_from_hdf5</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read_from_hdf5(input, ::Type{ElectricPotential})::ElectricPotential</code></pre><p><code>input</code> should be and <code>HDF5.HDF5Group</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/IO/IO.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.read_from_hdf5-Tuple{Any,Type{PointTypes}}" href="#SolidStateDetectors.read_from_hdf5-Tuple{Any,Type{PointTypes}}"><code>SolidStateDetectors.read_from_hdf5</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">read_from_hdf5(input, ::Type{PointTypes})::PointTypes</code></pre><p><code>input</code> should be and <code>HDF5.HDF5Group</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/IO/IO.jl#L47-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.write_to_hdf5-Tuple{Any,CylindricalGrid}" href="#SolidStateDetectors.write_to_hdf5-Tuple{Any,CylindricalGrid}"><code>SolidStateDetectors.write_to_hdf5</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">write_to_hdf5(output, ep::ElectricPotential)</code></pre><p><code>output</code> should be and <code>HDF5.HDF5Group</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/IO/IO.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolidStateDetectors.write_to_hdf5-Tuple{Any,PointTypes}" href="#SolidStateDetectors.write_to_hdf5-Tuple{Any,PointTypes}"><code>SolidStateDetectors.write_to_hdf5</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">write_to_hdf5(output, ep::PointTypes)</code></pre><p><code>output</code> should be and <code>HDF5.HDF5Group</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaHEP/SolidStateDetectors.jl/blob/b57f1877afb2bad6b939357108d9c448b77a4d8f/src/IO/IO.jl#L34-L38">source</a></section><footer><hr/><a class="previous" href="../man/IO/"><span class="direction">Previous</span><span class="title">IO</span></a><a class="next" href="../LICENSE/"><span class="direction">Next</span><span class="title">LICENSE</span></a></footer></article></body></html>
