<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inactive layer simulation: True coaxial detector · SolidStateDetectors.jl</title><meta name="title" content="Inactive layer simulation: True coaxial detector · SolidStateDetectors.jl"/><meta property="og:title" content="Inactive layer simulation: True coaxial detector · SolidStateDetectors.jl"/><meta property="twitter:title" content="Inactive layer simulation: True coaxial detector · SolidStateDetectors.jl"/><meta name="description" content="Documentation for SolidStateDetectors.jl."/><meta property="og:description" content="Documentation for SolidStateDetectors.jl."/><meta property="twitter:description" content="Documentation for SolidStateDetectors.jl."/><meta property="og:url" content="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/tutorials/dead_layer_simulation/"/><meta property="twitter:url" content="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/tutorials/dead_layer_simulation/"/><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/tutorials/dead_layer_simulation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="SolidStateDetectors.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SolidStateDetectors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/installation/">Installation</a></li><li><a class="tocitem" href="../../man/config_files/">Configuration Files</a></li><li><a class="tocitem" href="../../man/csg/">Constructive Solid Geometry (CSG)</a></li><li><a class="tocitem" href="../../man/grids/">Grids</a></li><li><a class="tocitem" href="../../man/electric_potential/">Electric Potential</a></li><li><a class="tocitem" href="../../man/electric_field/">Electric Field</a></li><li><a class="tocitem" href="../../man/charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../../man/capacitances/">Capacitances</a></li><li><a class="tocitem" href="../../man/IO/">IO</a></li><li><a class="tocitem" href="../../man/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../complete_simulation_chain_IVC/">Simulation Chain: Inverted Coax Detector</a></li><li><a class="tocitem" href="../custom_impurity_density_pn_junction/">Advanced Example: Custom Impurity Profile</a></li><li><a class="tocitem" href="../geant4_ssd/">Geant4 Support</a></li><li class="is-active"><a class="tocitem" href>Inactive layer simulation: True coaxial detector</a><ul class="internal"><li><a class="tocitem" href="#Set-the-physical-models-for-the-inactive-layer-(dead-layer)-simulation-with-YAML"><span>Set the physical models for the inactive layer (dead layer) simulation with YAML</span></a></li><li><a class="tocitem" href="#Display-the-impurity-profile-defined"><span>Display the impurity profile defined</span></a></li><li><a class="tocitem" href="#Dispaly-the-mobility-curve"><span>Dispaly the mobility curve</span></a></li><li><a class="tocitem" href="#Calculate-the-electric-field"><span>Calculate the electric field</span></a></li><li><a class="tocitem" href="#Pulse-shape-and-CCE-simulation"><span>Pulse shape and CCE simulation</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Inactive layer simulation: True coaxial detector</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inactive layer simulation: True coaxial detector</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/main/docs/src/tutorials/dead_layer_simulation_lit.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Inactive-layer-simulation:-True-coaxial-detector"><a class="docs-heading-anchor" href="#Inactive-layer-simulation:-True-coaxial-detector">Inactive layer simulation: True coaxial detector</a><a id="Inactive-layer-simulation:-True-coaxial-detector-1"></a><a class="docs-heading-anchor-permalink" href="#Inactive-layer-simulation:-True-coaxial-detector" title="Permalink"></a></h1><h2 id="Set-the-physical-models-for-the-inactive-layer-(dead-layer)-simulation-with-YAML"><a class="docs-heading-anchor" href="#Set-the-physical-models-for-the-inactive-layer-(dead-layer)-simulation-with-YAML">Set the physical models for the inactive layer (dead layer) simulation with YAML</a><a id="Set-the-physical-models-for-the-inactive-layer-(dead-layer)-simulation-with-YAML-1"></a><a class="docs-heading-anchor-permalink" href="#Set-the-physical-models-for-the-inactive-layer-(dead-layer)-simulation-with-YAML" title="Permalink"></a></h2><ul><li>using drift model for the inactive layer</li><li>using constant lifetime trapping model</li><li>using mobility-tied diffusion model (by calling the <code>calculate_mobility</code> function with the drift model)</li></ul><pre><code class="language-julia hljs">using Plots
using Unitful
using SolidStateDetectors
T = Float64;</code></pre><p>the geometry parameters of the model for following display</p><pre><code class="language-julia hljs">det_rin = 1u&quot;mm&quot;
det_z = det_r = 10u&quot;mm&quot;
z_draw = det_z/2
pn_r = 8.957282u&quot;mm&quot; # this one was calculated by searching the zero impurity point (displayed in the following section)

sim = Simulation{T}(SSD_examples[:TrueCoaxial])
cfn = SSD_examples[:TrueCoaxial]
print(open(f -&gt; read(f, String), cfn))
plot(sim.detector, xunit = u&quot;mm&quot;, yunit = u&quot;mm&quot;, zunit = u&quot;mm&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">name: TrueCoaxial
units:
  length: mm
  angle: deg
  potential: V
  temperature: K
grid:
  coordinates: cylindrical
  axes:
    r:
      to: 10.01
      boundaries: inf
    phi:
      from: 0
      to: 0
      boundaries:
        left: periodic
        right: periodic
    z:
      from: -0.01
      to: 10.01
      boundaries:
        left: inf
        right: inf
medium: vacuum
detectors:
- semiconductor:
    material: HPGe
    temperature: 90
    impurity_density:
      name: PtypePNjunction
      lithium_annealing_temperature: 623K
      lithium_annealing_time: 18minute
      doped_contact_id: 2
      bulk_impurity_density:
        name: constant
        value: -1e10cm^-3
    charge_drift_model:
      model: InactiveLayerChargeDriftModel
      temperature: 90K
      neutral_impurity_density:
        name: constant
        value: 5.6769e15cm^-3
      # # Uncomment the following lines if you want to use different bulk and surface impurity densities in the charge_drift_model section
      # bulk_impurity_density:
      #   name: constant
      #   value: -1e10cm^-3
      # surface_impurity_density:
      #   name: li_diffusion
      #   lithium_annealing_temperature: 623K
      #   lithium_annealing_time: 18minute
      #   doped_contact_id: 2
    charge_trapping_model:
      model: ConstantLifetime
      parameters:
        τh: 1ms
        τe: 1ms
      model_inactive: ConstantLifetime
      parameters_inactive:
        τh: 1μs
        τe: 1μs
      inactive_layer_geometry:
        tube:
          r:
            from: 8.957282 # set to the depth of the pn junction boundary when lithium diffusion temperature is 623 K, time is 18 minutes
            to: 10.0
          h: 10.0
          origin:
            z: 5.0
    geometry:
      tube:
        r:
          from: 1.0
          to: 10.0
        h: 10.0
        origin:
          z: 5.0
  contacts:
    - name: &quot;P⁺&quot;
      id: 1
      material: HPGe
      potential: -500
      geometry:
        tube:
          r:
            from: 1.0
            to: 1.0
          h: 10.0
          origin:
            z: 5.0
    - name: &quot;N⁺&quot;
      id: 2
      material: HPGe
      potential: 0
      geometry:
        tube:
          r:
            from: 10.0
            to: 10.0
          h: 10.0
          origin:
            z: 5.0</code></pre><p><a href="../tutorial_det_dl.pdf"><img src="../tutorial_det_dl.svg" alt="tutorial_det_dl"/></a></p><blockquote><p>In the configuration file shown above, the position of the PN junction boundary <code>pn_r</code> was calculated as the position  where the density is zero.</p></blockquote><h2 id="Display-the-impurity-profile-defined"><a class="docs-heading-anchor" href="#Display-the-impurity-profile-defined">Display the impurity profile defined</a><a id="Display-the-impurity-profile-defined-1"></a><a class="docs-heading-anchor-permalink" href="#Display-the-impurity-profile-defined" title="Permalink"></a></h2><pre><code class="language-julia hljs">r_list = 0u&quot;mm&quot;:0.01u&quot;mm&quot;:det_r
imp_list = map(r -&gt; let pt::CylindricalPoint{T} = CylindricalPoint(r, 0u&quot;°&quot;, z_draw)
    SolidStateDetectors.get_impurity_density(sim.detector.semiconductor.impurity_density_model, pt) * 1e-6u&quot;cm^-3&quot;
end, r_list)
plot(r_list, imp_list, xlabel = &quot;r / mm&quot;, ylabel = &quot;Impurity density / cm\$^{-3}\$&quot;, unitformat = :nounit, label = &quot;&quot;,
    color = :darkblue, lw = 2, grid = :on, xlims = (0, 10), ylims = (-2e10, 1e11))
vline!([pn_r], lw = 2, ls = :dash, color = :darkred, label = &quot;PN junction boundary&quot;)</code></pre><p><a href="../tutorial_imp_dl.pdf"><img src="../tutorial_imp_dl.svg" alt="tutorial_imp_dl"/></a></p><h2 id="Dispaly-the-mobility-curve"><a class="docs-heading-anchor" href="#Dispaly-the-mobility-curve">Dispaly the mobility curve</a><a id="Dispaly-the-mobility-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Dispaly-the-mobility-curve" title="Permalink"></a></h2><pre><code class="language-julia hljs">using SolidStateDetectors: Electron, Hole
cdm = sim.detector.semiconductor.charge_drift_model
depth_list = 0u&quot;mm&quot;:0.01u&quot;mm&quot;:(det_r-pn_r)
mobility_list = map(depth -&gt; let pt::CartesianPoint{T} = CartesianPoint(det_r - depth, 0, z_draw)
    (µe = SolidStateDetectors.calculate_mobility(cdm, pt, Hole) * 10000u&quot;cm^2/(V*s)&quot;,
     µh = SolidStateDetectors.calculate_mobility(cdm, pt, Electron) * 10000u&quot;cm^2/(V*s)&quot;)
end, depth_list)
plot(depth_list,  getfield.(mobility_list, :µh), label = &quot;Hole&quot;, lw = 4)
plot!(depth_list, getfield.(mobility_list, :µe), label = &quot;Electron&quot;, lw = 4)
plot!(xlabel = &quot;Depth to surface / mm&quot;, ylabel = &quot;Mobility / cm\$^2\$/Vs&quot;, unitformat = :nounit, legend = :topleft, xlims = (0u&quot;mm&quot;, det_r-pn_r))</code></pre><p><a href="../tutorial_mob_dl.pdf"><img src="../tutorial_mob_dl.svg" alt="tutorial_mob_dl"/></a></p><h2 id="Calculate-the-electric-field"><a class="docs-heading-anchor" href="#Calculate-the-electric-field">Calculate the electric field</a><a id="Calculate-the-electric-field-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-the-electric-field" title="Permalink"></a></h2><p>To simulate the inactive layer, we need to calculate the electric field on a very fine grid.</p><pre><code class="language-julia hljs">calculate_electric_potential!(sim, max_n_iterations = 10, grid = Grid(sim), verbose = false, depletion_handling = true)
g = sim.electric_potential.grid
ax1, ax2, ax3 = g.axes
bulk_tick_dis = 0.05u&quot;mm&quot;
dl_tick_dis   = 0.01u&quot;mm&quot;
user_additional_ticks_ax1 = sort(vcat(ax1.interval.left*u&quot;m&quot;:bulk_tick_dis:pn_r, pn_r:dl_tick_dis:ax1.interval.right*u&quot;m&quot;))
user_ax1 = typeof(ax1)(ax1.interval, SolidStateDetectors.to_internal_units.(user_additional_ticks_ax1))
user_g = typeof(g)((user_ax1, ax2, ax3))
calculate_electric_potential!(sim, refinement_limits = 0.1, grid = user_g, depletion_handling = true)
calculate_electric_field!(sim)
calculate_weighting_potential!(sim, 1, depletion_handling = true)
calculate_weighting_potential!(sim, 2, depletion_handling = true);
plot(
    begin
        imp = plot(sim.imp_scale, φ = 0, xunit = u&quot;mm&quot;, yunit = u&quot;mm&quot;, title = &quot;impurity scale&quot;)
        vline!([pn_r], lw = 2, ls = :dash, color = :darkred, label = &quot;PN junction boundary&quot;, legendfontsize = 6)
    end,
    begin
        plot(sim.point_types, φ = 0, xunit = u&quot;mm&quot;, yunit = u&quot;mm&quot;, title = &quot;point types&quot;)
        vline!([pn_r], lw = 2, ls = :dash, color = :darkred, label = &quot;PN junction boundary&quot;, legendfontsize = 6)
    end,
    begin
        plot(sim.electric_potential, xunit = u&quot;mm&quot;, yunit = u&quot;mm&quot;, title = &quot;electric potential&quot;)
        vline!([pn_r], lw = 2, ls = :dash, color = :darkred, label = &quot;PN junction boundary&quot;, legendfontsize = 6)
    end,
    begin
        plot(sim.electric_field, xunit = u&quot;mm&quot;, yunit = u&quot;mm&quot;, title = &quot;electric field&quot;, clims = (0, 100*2000))
        vline!([pn_r], lw = 2, ls = :dash, color = :darkred, label = &quot;PN junction boundary&quot;, legendfontsize = 6)
    end,
    size = (800, 600), layout = (2, 2),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation: TrueCoaxial
Electric Potential Calculation
Bias voltage: 500.0 V
φ symmetry: Detector is φ-symmetric -&gt; 2D computation.
Precision: Float64
Device: CPU
Max. CPU Threads: 4
Coordinate system: Cylindrical
N Refinements: -&gt; 1
Convergence limit: 1.0e-7  =&gt; 5.0e-5 V
Initial grid size: (286, 1, 16)

Grid size: (286, 1, 16) - using 4 threads now
<span class="sgr36"><span class="sgr1">┌ Info: </span></span>	In electric field calculation: Keyword `n_points_in_φ` not set.
<span class="sgr36"><span class="sgr1">└ </span></span>		Default is `n_points_in_φ = 36`. 2D field will be extended to 36 points in φ.
Simulation: TrueCoaxial
Weighting Potential Calculation - ID: 1
φ symmetry: Detector is φ-symmetric -&gt; 2D computation.
Precision: Float64
Device: CPU
Max. CPU Threads: 4
Coordinate system: Cylindrical
N Refinements: -&gt; 3
Convergence limit: 1.0e-7
Initial grid size: (12, 1, 16)

Grid size: (16, 1, 16) - using 4 threads now
Grid size: (24, 1, 16) - using 4 threads now
Grid size: (38, 1, 16) - using 4 threads now
Simulation: TrueCoaxial
Weighting Potential Calculation - ID: 2
φ symmetry: Detector is φ-symmetric -&gt; 2D computation.
Precision: Float64
Device: CPU
Max. CPU Threads: 4
Coordinate system: Cylindrical
N Refinements: -&gt; 3
Convergence limit: 1.0e-7
Initial grid size: (12, 1, 16)

Grid size: (16, 1, 16) - using 4 threads now
Grid size: (24, 1, 16) - using 4 threads now
Grid size: (38, 1, 16) - using 4 threads now</code></pre><p><a href="../tutorial_ef_dl.pdf"><img src="../tutorial_ef_dl.svg" alt="tutorial_ef_dl"/></a></p><h2 id="Pulse-shape-and-CCE-simulation"><a class="docs-heading-anchor" href="#Pulse-shape-and-CCE-simulation">Pulse shape and CCE simulation</a><a id="Pulse-shape-and-CCE-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Pulse-shape-and-CCE-simulation" title="Permalink"></a></h2><pre><code class="language-julia hljs">depth_list = 0.1u&quot;mm&quot;:0.1u&quot;mm&quot;:(det_r-pn_r)
totTime = 5u&quot;µs&quot;
totEnergy = 1u&quot;keV&quot; # --&gt; simulating ~339 carrier pairs
N = Int(totEnergy÷2.95u&quot;eV&quot;)

pulse_plot = plot()
eff_list = map(depth -&gt; begin
    r = det_r-depth
    energy_depos = fill(2.95u&quot;eV&quot;, N)
    starting_positions = repeat([CartesianPoint(r, 0, z_draw)], N)
    evt = Event(starting_positions, energy_depos)
    simulate!(evt, sim, Δt = 1u&quot;ns&quot;, max_nsteps = round(Int, totTime / 1u&quot;ns&quot;), diffusion = true, end_drift_when_no_field = false, self_repulsion = false)
    pulse = evt.waveforms[1]
    plot!(pulse_plot, pulse, label = &quot;Depth: $(round(typeof(depth), depth, digits = 1))&quot;, lw = 2, yunit = u&quot;eV/V&quot;)
    maximum(pulse.signal)/N
end, depth_list)
plot!(pulse_plot, legend = :topright, xlabel = &quot;Time / ns&quot;, ylabel = &quot;Amplitude / e&quot;, unitformat = :nounit)
cce_plot = plot(depth_list, eff_list, xlabel = &quot;Depth to surface / mm&quot;, ylabel = &quot;Charge collection efficiency&quot;, lw = 2, color = :black, label = &quot;&quot;, unitformat = :nounit)
plot(pulse_plot, cce_plot, layout = (1, 2), size = (1000, 400), margin = 5Plots.mm)</code></pre><p><a href="../tutorial_pulse_cce_dl.pdf"><img src="../tutorial_pulse_cce_dl.svg" alt="tutorial_pulse_cce_dl"/></a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../geant4_ssd/">« Geant4 Support</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 17 February 2026 04:18">Tuesday 17 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
