<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SolidStateDetectors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SolidStateDetectors.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/installation/">Installation</a></li><li><a class="tocitem" href="../man/config_files/">Configuration Files</a></li><li><a class="tocitem" href="../man/csg/">Constructive Solid Geometry (CSG)</a></li><li><a class="tocitem" href="../man/Grids/">Grids</a></li><li><a class="tocitem" href="../man/electric_potential/">Electric Potential</a></li><li><a class="tocitem" href="../man/electric_field/">Electric Field</a></li><li><a class="tocitem" href="../man/charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../man/weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../man/capacitances/">Capacitances</a></li><li><a class="tocitem" href="../man/IO/">IO</a></li><li><a class="tocitem" href="../man/plotting/">Plotting</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/complete_simulation_chain_IVC/">Simulation Chain: Inverted Coax Detector</a></li><li><a class="tocitem" href="../tutorials/custom_impurity_density_pn_junction/">Advanced Example: Custom Impurity Profile</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Dictionaries"><span>Dictionaries</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Dictionaries"><a class="docs-heading-anchor" href="#Dictionaries">Dictionaries</a><a id="Dictionaries-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionaries" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.SSD_examples"><code>SolidStateDetectors.SSD_examples</code></a></li></ul><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.ADLChargeDriftModel"><code>SolidStateDetectors.ADLChargeDriftModel</code></a></li><li><a href="#SolidStateDetectors.AbstractChargeDensity"><code>SolidStateDetectors.AbstractChargeDensity</code></a></li><li><a href="#SolidStateDetectors.AbstractImpurityDensity"><code>SolidStateDetectors.AbstractImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.CarrierParameters"><code>SolidStateDetectors.CarrierParameters</code></a></li><li><a href="#SolidStateDetectors.ConstantChargeDensity"><code>SolidStateDetectors.ConstantChargeDensity</code></a></li><li><a href="#SolidStateDetectors.ConstantImpurityDensity"><code>SolidStateDetectors.ConstantImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Box"><code>SolidStateDetectors.ConstructiveSolidGeometry.Box</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Cone"><code>SolidStateDetectors.ConstructiveSolidGeometry.Cone</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid"><code>SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface"><code>SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Plane"><code>SolidStateDetectors.ConstructiveSolidGeometry.Plane</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Polygon"><code>SolidStateDetectors.ConstructiveSolidGeometry.Polygon</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism"><code>SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.Torus"><code>SolidStateDetectors.ConstructiveSolidGeometry.Torus</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle</code></a></li><li><a href="#SolidStateDetectors.Contact"><code>SolidStateDetectors.Contact</code></a></li><li><a href="#SolidStateDetectors.CylindricalChargeDensity"><code>SolidStateDetectors.CylindricalChargeDensity</code></a></li><li><a href="#SolidStateDetectors.CylindricalImpurityDensity"><code>SolidStateDetectors.CylindricalImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.DeadVolume"><code>SolidStateDetectors.DeadVolume</code></a></li><li><a href="#SolidStateDetectors.DielectricDistribution"><code>SolidStateDetectors.DielectricDistribution</code></a></li><li><a href="#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a></li><li><a href="#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T"><code>SolidStateDetectors.DiscreteAxis</code></a></li><li><a href="#SolidStateDetectors.EffectiveChargeDensity"><code>SolidStateDetectors.EffectiveChargeDensity</code></a></li><li><a href="#SolidStateDetectors.ElectricField"><code>SolidStateDetectors.ElectricField</code></a></li><li><a href="#SolidStateDetectors.ElectricFieldChargeDriftModel"><code>SolidStateDetectors.ElectricFieldChargeDriftModel</code></a></li><li><a href="#SolidStateDetectors.ElectricPotential"><code>SolidStateDetectors.ElectricPotential</code></a></li><li><a href="#SolidStateDetectors.Event"><code>SolidStateDetectors.Event</code></a></li><li><a href="#SolidStateDetectors.GeometricalAzimutalAxisWeights"><code>SolidStateDetectors.GeometricalAzimutalAxisWeights</code></a></li><li><a href="#SolidStateDetectors.GeometricalCartesianAxisWeights"><code>SolidStateDetectors.GeometricalCartesianAxisWeights</code></a></li><li><a href="#SolidStateDetectors.GeometricalRadialAxisWeights"><code>SolidStateDetectors.GeometricalRadialAxisWeights</code></a></li><li><a href="#SolidStateDetectors.Grid-Union{Tuple{Simulation{T, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.Grid</code></a></li><li><a href="#SolidStateDetectors.Grid"><code>SolidStateDetectors.Grid</code></a></li><li><a href="#SolidStateDetectors.ImpurityScale"><code>SolidStateDetectors.ImpurityScale</code></a></li><li><a href="#SolidStateDetectors.LinearChargeDensity"><code>SolidStateDetectors.LinearChargeDensity</code></a></li><li><a href="#SolidStateDetectors.LinearImpurityDensity"><code>SolidStateDetectors.LinearImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Type{PT}}} where {T, PT&lt;:SolidStateDetectors.ParticleType}"><code>SolidStateDetectors.NBodyChargeCloud</code></a></li><li><a href="#SolidStateDetectors.NBodyChargeCloud"><code>SolidStateDetectors.NBodyChargeCloud</code></a></li><li><a href="#SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Integer}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Integer, Type{PT}}} where {T, PT&lt;:SolidStateDetectors.ParticleType}"><code>SolidStateDetectors.NBodyChargeCloud</code></a></li><li><a href="#SolidStateDetectors.ParticleType"><code>SolidStateDetectors.ParticleType</code></a></li><li><a href="#SolidStateDetectors.Passive"><code>SolidStateDetectors.Passive</code></a></li><li><a href="#SolidStateDetectors.PointCharge"><code>SolidStateDetectors.PointCharge</code></a></li><li><a href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a></li><li><a href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a></li><li><a href="#SolidStateDetectors.PotentialCalculationSetup"><code>SolidStateDetectors.PotentialCalculationSetup</code></a></li><li><a href="#SolidStateDetectors.SSDInterval"><code>SolidStateDetectors.SSDInterval</code></a></li><li><a href="#SolidStateDetectors.Semiconductor"><code>SolidStateDetectors.Semiconductor</code></a></li><li><a href="#SolidStateDetectors.Simulation"><code>SolidStateDetectors.Simulation</code></a></li><li><a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetectors.SolidStateDetector</code></a></li><li><a href="#SolidStateDetectors.VelocityParameters"><code>SolidStateDetectors.VelocityParameters</code></a></li><li><a href="#SolidStateDetectors.WeightingPotential"><code>SolidStateDetectors.WeightingPotential</code></a></li><li><a href="#SolidStateDetectors.World"><code>SolidStateDetectors.World</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><ul><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.extreme_points</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP} where TP&lt;:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP} where TP&lt;:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.Plane{T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a></li><li><a href="#SolidStateDetectors.add_baseline_and_extend_tail-Union{Tuple{UV}, Tuple{TV}, Tuple{U}, Tuple{T}, Tuple{RadiationDetectorSignals.RDWaveform{T, U, TV, UV}, Int64, Int64}} where {T, U, TV, UV}"><code>SolidStateDetectors.add_baseline_and_extend_tail</code></a></li><li><a href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a></li><li><a href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Grid{T}}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>SolidStateDetectors.apply_initial_state!</code></a></li><li><a href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Grid{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a></li><li><a href="#SolidStateDetectors.calc_new_potential_by_neighbors_3D-Union{Tuple{T}, Tuple{T, NTuple{6, T}, NTuple{6, T}}} where T"><code>SolidStateDetectors.calc_new_potential_by_neighbors_3D</code></a></li><li><a href="#SolidStateDetectors.calculate_capacitance_matrix-Union{Tuple{Simulation{T}}, Tuple{T}} where T"><code>SolidStateDetectors.calculate_capacitance_matrix</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>SolidStateDetectors.calculate_electric_field!</code></a></li><li><a href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_potential!</code></a></li><li><a href="#SolidStateDetectors.calculate_mutual_capacitance-Tuple{Simulation, Tuple{Int64, Int64}}"><code>SolidStateDetectors.calculate_mutual_capacitance</code></a></li><li><a href="#SolidStateDetectors.calculate_stored_energy-Tuple{Simulation}"><code>SolidStateDetectors.calculate_stored_energy</code></a></li><li><a href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_weighting_potential!</code></a></li><li><a href="#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.drift_charges!</code></a></li><li><a href="#SolidStateDetectors.estimate_depletion_voltage-Union{Tuple{Simulation{T}}, Tuple{T}, Tuple{Simulation{T}, T}, Tuple{Simulation{T}, T, T}} where T&lt;:AbstractFloat"><code>SolidStateDetectors.estimate_depletion_voltage</code></a></li><li><a href="#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.get_active_volume</code></a></li><li><a href="#SolidStateDetectors.get_charge_density"><code>SolidStateDetectors.get_charge_density</code></a></li><li><a href="#SolidStateDetectors.get_electron_and_hole_contribution-Union{Tuple{S}, Tuple{T}, Tuple{Event{T}, Simulation{T, S}, Int64}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>SolidStateDetectors.get_electron_and_hole_contribution</code></a></li><li><a href="#SolidStateDetectors.get_impurity_density"><code>SolidStateDetectors.get_impurity_density</code></a></li><li><a href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a></li><li><a href="#SolidStateDetectors.get_signals!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_signals!</code></a></li><li><a href="#SolidStateDetectors.get_sor_kernel-Tuple{Type{Cylindrical}, Any, Any, Vararg{Any}}"><code>SolidStateDetectors.get_sor_kernel</code></a></li><li><a href="#SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes-Union{Tuple{SolidStateDetectors.ImpurityScale{T, 3}}, Tuple{T}} where T"><code>SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes</code></a></li><li><a href="#SolidStateDetectors.get_ticks_at_positions_of_large_gradient-Union{Tuple{ElectricPotential{T, 3}}, Tuple{T}} where T"><code>SolidStateDetectors.get_ticks_at_positions_of_large_gradient</code></a></li><li><a href="#SolidStateDetectors.handle_depletion-Union{Tuple{T}, Tuple{T, T, NTuple{6, T}, T, T}} where T"><code>SolidStateDetectors.handle_depletion</code></a></li><li><a href="#SolidStateDetectors.is_depleted-Tuple{PointTypes}"><code>SolidStateDetectors.is_depleted</code></a></li><li><a href="#SolidStateDetectors.merge_second_order_important_ticks-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T"><code>SolidStateDetectors.merge_second_order_important_ticks</code></a></li><li><a href="#SolidStateDetectors.parse_config_file-Tuple{AbstractString}"><code>SolidStateDetectors.parse_config_file</code></a></li><li><a href="#SolidStateDetectors.plot_electron_and_hole_contribution"><code>SolidStateDetectors.plot_electron_and_hole_contribution</code></a></li><li><a href="#SolidStateDetectors.readsiggen-Tuple{String}"><code>SolidStateDetectors.readsiggen</code></a></li><li><a href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a></li><li><a href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{ElectricPotential}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a></li><li><a href="#SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T}}, Tuple{T}} where T"><code>SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region</code></a></li><li><a href="#SolidStateDetectors.siggentodict-Tuple{Dict}"><code>SolidStateDetectors.siggentodict</code></a></li><li><a href="#SolidStateDetectors.simulate!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate!</code></a></li><li><a href="#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>SolidStateDetectors.simulate!</code></a></li><li><a href="#SolidStateDetectors.simulate_waveforms-Union{Tuple{T}, Tuple{TypedTables.Table, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate_waveforms</code></a></li><li><a href="#SolidStateDetectors.ssd_read"><code>SolidStateDetectors.ssd_read</code></a></li><li><a href="#SolidStateDetectors.ssd_write"><code>SolidStateDetectors.ssd_write</code></a></li><li><a href="#SolidStateDetectors.update!-Union{Tuple{_is_weighting_potential}, Tuple{only_2d}, Tuple{depletion_handling_enabled}, Tuple{T}, Tuple{SolidStateDetectors.PotentialCalculationSetup{T, S, N1, DATN1, N2, AT, DATN2, DATPT, DATGW, DATSOR} where {S, N1, DATN1&lt;:AbstractArray{T, N1}, N2, AT, DATN2&lt;:AbstractArray{T, N2}, DATPT&lt;:AbstractArray{UInt8, N2}, DATGW&lt;:AbstractMatrix{T}, DATSOR&lt;:AbstractVector{T}}, Nothing, Any}} where {T, depletion_handling_enabled, only_2d, _is_weighting_potential}"><code>SolidStateDetectors.update!</code></a></li><li><a href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a></li><li><a href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a></li></ul><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.SSD_examples" href="#SolidStateDetectors.SSD_examples"><code>SolidStateDetectors.SSD_examples</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">SSD_examples::Dict{Symbol,String}</code></pre><p>Dictionary with the paths to the example detector configuration files provided by the package.</p><p>Find the possible keys of the dictionary with <code>keys(SSD_examples)</code>.</p><p>The example detector configuration files can be loaded via</p><pre><code class="nohighlight hljs">path_to_config_file = SSD_examples[:InvertedCoax]
sim = Simulation(path_to_config_file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/examples.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ADLChargeDriftModel" href="#SolidStateDetectors.ADLChargeDriftModel"><code>SolidStateDetectors.ADLChargeDriftModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ADLChargeDriftModel{T &lt;: SSDFloat, M &lt;: AbstractDriftMaterial, N, TM &lt;: AbstractTemperatureModel{T}} &lt;: AbstractChargeDriftModel{T}</code></pre><p>Charge drift model for electrons and holes based on the AGATA Detector Library. Find a detailed description of the calculations in <a href="../man/charge_drift/#ADL-Charge-Drift-Model">ADL Charge Drift Model</a>.</p><p><strong>Fields</strong></p><ul><li><code>electrons::CarrierParameters{T}</code>: Parameters to describe the electron drift along the &lt;100&gt; and &lt;111&gt; axes.</li><li><code>holes::CarrierParameters{T}</code>: Parameters to describe the hole drift along the &lt;100&gt; and &lt;111&gt; axes.</li><li><code>crystal_orientation::SMatrix{3,3,T,9}</code>: Rotation matrix that transforms the global coordinate system to the crystal coordinate system given by the &lt;100&gt;, &lt;010&gt; and &lt;001&gt; axes of the crystal.</li><li><code>γ::SVector{N,SMatrix{3,3,T,9}}</code>: Reciprocal mass tensors to the <code>N</code> valleys of the conduction band.</li><li><code>parameters::ADLParameters{T}</code>: Parameters needed for the calculation of the electron drift velocity.</li><li><code>temperaturemodel::TM</code>: Models to scale the resulting drift velocities with respect to temperature</li></ul><p>See also <a href="#SolidStateDetectors.CarrierParameters"><code>CarrierParameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDriftModels/ADLChargeDriftModel/ADLChargeDriftModel.jl#L121-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractChargeDensity" href="#SolidStateDetectors.AbstractChargeDensity"><code>SolidStateDetectors.AbstractChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractChargeDensity{T &lt;: SSDFloat} end</code></pre><p>Struct defining the charge density inside a <a href="#SolidStateDetectors.Passive"><code>Passive</code></a>.</p><p>For each charge density, there should be a method <a href="#SolidStateDetectors.get_charge_density"><code>get_charge_density</code></a>  which returns the charge density in SI units (C/m³) at a given point <code>pt</code>.</p><p><strong>Examples</strong></p><ul><li><a href="#SolidStateDetectors.ConstantChargeDensity"><code>ConstantChargeDensity</code></a></li><li><a href="#SolidStateDetectors.LinearChargeDensity"><code>LinearChargeDensity</code></a></li><li><a href="#SolidStateDetectors.CylindricalChargeDensity"><code>CylindricalChargeDensity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDensities/ChargeDensities.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.AbstractImpurityDensity" href="#SolidStateDetectors.AbstractImpurityDensity"><code>SolidStateDetectors.AbstractImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractImpurityDensity{T &lt;: SSDFloat} end</code></pre><p>Struct defining an impurity density inside a <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a>.</p><p>For each impurity density, there should be a method <a href="#SolidStateDetectors.get_impurity_density"><code>get_impurity_density</code></a> which returns the impurity density in SI units (1/m³) at a given point.</p><p><strong>Examples</strong></p><ul><li><a href="#SolidStateDetectors.ConstantImpurityDensity"><code>ConstantImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.LinearImpurityDensity"><code>LinearImpurityDensity</code></a></li><li><a href="#SolidStateDetectors.CylindricalImpurityDensity"><code>CylindricalImpurityDensity</code></a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The sign of the impurity density is important. It is taken into account in the conversion to a charge density and, thus, defines where the semiconductor is n-type or p-type. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ImpurityDensities/ImpurityDensities.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.CarrierParameters" href="#SolidStateDetectors.CarrierParameters"><code>SolidStateDetectors.CarrierParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CarrierParameters{T &lt;: SSDFloat}</code></pre><p>Parameters needed to describe the electron or hole drift along the &lt;100&gt; and &lt;111&gt; axes.</p><p><strong>Fields</strong></p><ul><li><code>axis100::VelocityParameters{T}</code>: Parameters to describe the charge drift along the &lt;100&gt; axis.</li><li><code>axis111::VelocityParameters{T}</code>: Parameters to describe the charge drift along the &lt;111&gt; axis.</li></ul><p>See also <a href="#SolidStateDetectors.VelocityParameters"><code>VelocityParameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDriftModels/ADLChargeDriftModel/ADLChargeDriftModel.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstantChargeDensity" href="#SolidStateDetectors.ConstantChargeDensity"><code>SolidStateDetectors.ConstantChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantChargeDensity{T &lt;: SSDFloat} &lt;: AbstractChargeDensity{T}</code></pre><p>Charge density model that assumes a constant charge density everywhere.</p><p><strong>Fields</strong></p><ul><li><code>ρ::T</code>: the constant value of the charge density.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>ConstantChargeDensity</code> is defined in the configuration file through the field <code>charge_density</code>  (of a <code>passive</code> or <code>surrounding</code>) with <code>name: constant</code> and a <code>value</code> for <code>ρ</code>.</p><p>An example definition of a constant charge density looks like this:</p><pre><code class="language-yaml hljs">charge_density:
  name: constant
  value: 1.0e-10 # C/m³</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDensities/ConstantChargeDensity.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstantImpurityDensity" href="#SolidStateDetectors.ConstantImpurityDensity"><code>SolidStateDetectors.ConstantImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstantImpurityDensity{T &lt;: SSDFloat} &lt;: AbstractImpurityDensity{T}</code></pre><p>Impurity density model that assumes a constant impurity density everywhere.</p><p><strong>Fields</strong></p><ul><li><code>ρ::T</code>: the constant value of the impurity density.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>ConstantImpurityDensity</code> is defined in the configuration file through the field <code>impurity_density</code>  (of a <code>semiconductor</code>) with <code>name: constant</code> and a <code>value</code> for <code>ρ</code>.</p><p>An example definition of a constant impurity density looks like this:</p><pre><code class="language-yaml hljs">impurity_density:
  name: constant
  value: 1.0e10 # 1/m³</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ImpurityDensities/ConstantImpurityDensity.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Contact" href="#SolidStateDetectors.Contact"><code>SolidStateDetectors.Contact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Contact{T, G, MT} &lt;: AbstractContact{T}</code></pre><p>Contact of a <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a>.</p><p>For the simulation of the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>, all contacts are fixed to a constant potential value.</p><p><strong>Parametric types:</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>G</code>: Type of <code>geometry</code>.</li><li><code>MT</code>: Type of <code>material</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>potential::T</code>: Potential (in V) to which the contact will be fixed during the calculation of the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>.</li><li><code>material::MT</code>: Material of the contact.</li><li><code>id::Int</code>: Unique id that will unambiguously identify the contact.</li><li><code>name::String</code>: Custom name for the contact, relevant for plotting.</li><li><code>geometry::G</code>: Geometry of the contact, see <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>Contact</code> is defined in the configuration file through an entry in the <code>contacts</code> array of a detector. It needs <code>id</code>, <code>potential</code> and <code>geometry</code> and can optionally be given a <code>name</code> and <code>material</code>.</p><p>An example definition of contacts looks like this:</p><pre><code class="language-yaml hljs">contacts:
  - name: &quot;n+ contact&quot;
    id: 1
    potential: 5000V
    material: HPGe # optional
    geometry: # ....
  - name: &quot;p+ contact&quot;
    id: 2
    potential: 0
    material: HPGe #optional
    geometry: # ....</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/SolidStateDetector/Contacts.jl#L4-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.CylindricalChargeDensity" href="#SolidStateDetectors.CylindricalChargeDensity"><code>SolidStateDetectors.CylindricalChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalChargeDensity{T &lt;: SSDFloat} &lt;: AbstractChargeDensity{T}</code></pre><p>Charge density model which assumes a linear gradient in charge density in each spatial dimension  of a cylindrical coordinate system.</p><p><strong>Fields</strong></p><ul><li><code>offsets::NTuple{3,T}</code>: charge density values at the origin of each dimension.</li><li><code>gradients::NTuple{3,T}</code>: linear slopes in <code>r</code> and <code>z</code> direction.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>CylindricalChargeDensity</code> is defined in the configuration file through the field <code>charge_density</code>  (of a <code>passive</code> or <code>surrounding</code>) with <code>name: cylindrical</code> and optional fields <code>r</code> and <code>z</code> that can each contain <code>init</code> for initial values at 0 and <code>gradient</code> for gradients in that dimension.</p><p>An example definition of a cylindrical charge density looks like this:</p><pre><code class="language-yaml hljs">charge_density:
  name: cylindrical
  r:  # impurity profile with linear gradient in r
    init: 1.0e-10     # C/m³
    gradient: 1.0e-11 # C/m⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDensities/CylindricalChargeDensity.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.CylindricalImpurityDensity" href="#SolidStateDetectors.CylindricalImpurityDensity"><code>SolidStateDetectors.CylindricalImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalImpurityDensity{T &lt;: SSDFloat} &lt;: AbstractImpurityDensity{T}</code></pre><p>Impurity density model which assumes a linear gradient in impurity density in each spatial dimension  of a cylindrical coordinate system.</p><p><strong>Fields</strong></p><ul><li><code>offsets::NTuple{3,T}</code>: impurity density values at the origin of each dimension.</li><li><code>gradients::NTuple{3,T}</code>: linear slopes in <code>r</code> and <code>z</code> direction.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>CylindricalImpurityDensity</code> is defined in the configuration file through the field <code>impurity_density</code>  (of a <code>passive</code> or <code>surrounding</code>) with <code>name: cylindrical</code> and optional fields <code>r</code> and <code>z</code> that can each contain <code>init</code> for initial values at 0 and <code>gradient</code> for gradients in that dimension.</p><p>An example definition of a cylindrical impurity density looks like this:</p><pre><code class="language-yaml hljs">impurity_density:
  name: cylindrical
  r:  # impurity profile with linear gradient in r
    init: 1.0e10     # 1/m³
    gradient: 1.0e11 # 1/m⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ImpurityDensities/CylindricalImpurityDensity.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DeadVolume" href="#SolidStateDetectors.DeadVolume"><code>SolidStateDetectors.DeadVolume</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DeadVolume{T, G} &lt;: AbstractVirtualVolume{T}</code></pre><p>Volume inside which the charge drift is set to zero.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>G</code>: Type of <code>geometry</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Name of the dead volume, relevant for plotting.</li><li><code>geometry::G</code>: Geometry of the dead volume, see <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>DeadVolume</code> is defined through an entry in the <code>virtual_drift_volumes</code> array of a detector with <code>model: dead</code>. It needs a <code>geometry</code> and can optionally be given a <code>name</code>.</p><p>An example definition of dead volumes looks like this:</p><pre><code class="language-yaml hljs">virtual_drift_volume:
  - name: Volume 1
    model: dead
    geometry: # ...
  - name: Volume 2
    model: dead
    geometry: # ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/SolidStateDetector/VirtualVolumes.jl#L10-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DielectricDistribution" href="#SolidStateDetectors.DielectricDistribution"><code>SolidStateDetectors.DielectricDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DielectricDistribution{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Dielectric distribution, or distribution of the relative permittivity, <span>$\epsilon_r$</span>,  needed to calculate the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>. The dielectric distribution is unitless.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>data</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.  </li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{T, N}</code>: Array containing the values of the dielectric distribution at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points at which the electric potential is determined.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>data</code> array contains the values of the dielectric distribution at the discrete points  between the points defined by the axes ticks of the extended grid of <code>grid</code>.</p><p>Thus, <code>size(data) == size(grid) .+ 1</code> !</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/DielectricDistribution.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DiscreteAxis" href="#SolidStateDetectors.DiscreteAxis"><code>SolidStateDetectors.DiscreteAxis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteAxis{T, BL, BR, I} &lt;: AbstractAxis{T, BL, BR, I}</code></pre><p>Axis with discrete ticks which is used to define a dimension of a <a href="#SolidStateDetectors.Grid"><code>Grid</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Type of ticks</li><li><code>BL</code>: Boundary condition at the left endpoint.</li><li><code>BR</code>: Boundary condition at the right endpoint.</li><li><code>I</code>: IntervalSets.Interval (closed or open boundaries)</li></ul><p>The boundary conditions of a <code>DiscreteAxis</code> can be <code>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}</code>.</p><p><strong>Fields</strong></p><ul><li><code>interval::I</code>: Interval that defines the range of the axis.</li><li><code>ticks::Vector{T}</code>: Array of values that correspond to the discrete ticks of the axis.</li></ul><p>See also <a href="#SolidStateDetectors.Grid"><code>Grid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Axes/DiscreteAxis.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T" href="#SolidStateDetectors.DiscreteAxis-Union{Tuple{T}, Tuple{T, T, Symbol, Symbol, Symbol, Symbol, AbstractVector{T}}} where T"><code>SolidStateDetectors.DiscreteAxis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteAxis(left_endpoint::T, right_endpoint::T, BL::Symbol, BR::Symbol, L::Symbol, R::Symbol, ticks::AbstractVector{T}) where {T}</code></pre><p>Constructor of a <code>DiscreteAxis</code>.</p><p><strong>Arguments</strong></p><ul><li><code>left_endpoint::T</code>: Left endpoint of the interval of the <code>DiscreteAxis</code>.</li><li><code>right_endpoint::T</code>: Right endpoint of the interval of the <code>DiscreteAxis</code>.</li><li><code>BL::Symbol</code>: Boundary condition at the left endpoint.</li><li><code>BR::Symbol</code>: Boundary condition at the right endpoint.</li><li><code>L::Symbol</code>: Boundary type of the left endpoint.</li><li><code>R::Symbol</code>: Boundary type of the right endpoint.</li><li><code>ticks::AbstractVector{T}</code>: Array of values that correspond to the discrete ticks of the axis.</li></ul><p>The boundary conditions of a <code>DiscreteAxis</code> can be <code>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}</code>.</p><p>The boundary types of a <code>DiscreteAxis</code> can be <code>L, R ∈ {:closed, :open}</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">DiscreteAxis(-2.0, 2.0, :infinite, :infinite, :closed, :closed, collect(-2:0.1:2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Axes/DiscreteAxis.jl#L38-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.EffectiveChargeDensity" href="#SolidStateDetectors.EffectiveChargeDensity"><code>SolidStateDetectors.EffectiveChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EffectiveChargeDensity{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Effective charge density needed to calculate the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>. The effective charge density is the charge density (in C/m³) times the volume of the voxel of the respective grid point (in m³). Thus, the unit of the effective charge density is Coulomb (C).</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>data</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.  </li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{T, N}</code>: Array containing the values of the effective charge density at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points at which the electric potential is determined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/EffectiveChargeDensity.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricField" href="#SolidStateDetectors.ElectricField"><code>SolidStateDetectors.ElectricField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ElectricField{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Electric field of the simulation in units of volt per meter (V/m).</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>grid.axes</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.</li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{&lt;:StaticArray{Tuple{N}, T}, N}</code>: Array containing the field vectors of the electric field at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points for which the electric field is determined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ElectricField/ElectricField.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricFieldChargeDriftModel" href="#SolidStateDetectors.ElectricFieldChargeDriftModel"><code>SolidStateDetectors.ElectricFieldChargeDriftModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ElectricFieldChargeDriftModel{T &lt;: SSDFloat} &lt;: AbstractChargeDriftModel{T}</code></pre><p>Charge drift model in which the electrons and holes drift along the electric field with a mobility of ± 1m²/Vs.</p><p>This model is the default when no charge drift model is defined in the configuration file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDriftModels/ElectricFieldChargeDriftModel/ElectricFieldChargeDriftModel.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ElectricPotential" href="#SolidStateDetectors.ElectricPotential"><code>SolidStateDetectors.ElectricPotential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ElectricPotential{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Electric potential of the simulation in units of volt (V).</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>data</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.  </li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{T, N}</code>: Array containing the values of the electric potential at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points for which the electric potential is determined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/ElectricPotential.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Event" href="#SolidStateDetectors.Event"><code>SolidStateDetectors.Event</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Event{T &lt;: SSDFloat}</code></pre><p>Collection struct for individual events.  This (mutable) struct is meant to be used to look at individual events, not to process a huge amount of events.</p><p><strong>Fields</strong></p><ul><li><code>locations::VectorOfArrays{CartesianPoint{T}}</code>: Vector of the positions of all hits of the event.</li><li><code>energies::VectorOfArrays{T}</code>: Vector of energies corresponding to the hits of the event.</li><li><code>drift_paths::Union{Vector{EHDriftPath{T}}, Missing}</code>: Calculated drift paths of each hit position. </li><li><code>waveforms::Union{Vector{&lt;:Any}, Missing}</code>: Generated signals (waveforms) of the event.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.GeometricalAzimutalAxisWeights" href="#SolidStateDetectors.GeometricalAzimutalAxisWeights"><code>SolidStateDetectors.GeometricalAzimutalAxisWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GeometricalAzimutalAxisWeights{T} &lt;: AbstractGeometricalAxisWeights{T}</code></pre><p><code>GeometricalAzimutalAxisWeights</code> stores certain precalculated (in its construction) fixed values of the azimulal (or polar) axis, <code>ax</code>, of an cylindrical grid on which the field calculation is performed.  These precalculated values are further used in the field calculation  to calculate the six weights for the neighboring grid points in the SOR. </p><p><code>GeometricalAzimutalAxisWeights</code> has only one field: <code>weights::Array{T}, 2</code>, which is  of size <code>(4, length(ax.ticks))</code>. Each row holding the 4 precalculated values for one axis tick.</p><p>Axis ticks, <code>t = ax.ticks</code>, and midpoints, <code>mp = midpoints(get_extended_ticks(ax))</code>,<br/>(the middle points between to axis ticks) inbetween:<br/><code>... t[i-1] --- mp[i] --- t[i] --- mp[i+1] --- t[i+1] ...</code><br/>are required for the understanding of the precalculated values.</p><p>The columns store the following quantities:</p><ul><li><code>weights[1, i]</code>: <code>(mp[i+1] - t[i])</code> / <code>weights[3, i]</code></li><li><code>weights[2, i]</code>: <code>(t[i] - mp[i])</code> / <code>weights[3, i]</code></li><li><code>weights[3, i]</code>: <code>mp[i+1] - mp[i]</code></li><li><code>weights[4, i]</code>: <code>inv(t[i] - t[i-1])</code></li><li><code>weights[5, i]</code>: <code>normalize(wφ[3, 1:2:end], 1)</code></li><li><code>weights[6, i]</code>: <code>normalize(wφ[3, 2:2:end], 1)</code></li></ul><p>Developer note: This actually seems to be the same as <code>GeometricalCartesianAxisWeights</code>. Thus, we actually could remove that. Or change this into an alias.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/GeometricalWeights.jl#L39-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.GeometricalCartesianAxisWeights" href="#SolidStateDetectors.GeometricalCartesianAxisWeights"><code>SolidStateDetectors.GeometricalCartesianAxisWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GeometricalCartesianAxisWeights{T} &lt;: AbstractGeometricalAxisWeights{T}</code></pre><p><code>GeometricalCartesianAxisWeights</code> stores certain precalculated (in its construction) fixed values of one of the cartesian (linear) axes, <code>ax</code>, of the grid on which the field calculation is performed.  These precalculated values are further used in the field calculation  to calculate the six weights for the neighboring grid points in the SOR. </p><p><code>GeometricalCartesianAxisWeights</code> has only one field: <code>weights::Array{T}, 2</code>, which is  of size <code>(4, length(ax.ticks))</code>. Each row holding the 4 precalculated values for one axis tick.</p><p>Axis ticks, <code>t = ax.ticks</code>, and midpoints, <code>mp = midpoints(get_extended_ticks(ax))</code>,<br/>(the middle points between to axis ticks) inbetween:<br/><code>... t[i-1] --- mp[i] --- t[i] --- mp[i+1] --- t[i+1] ...</code><br/>are required for the understanding of the precalculated values.</p><p>The columns store the following quantities:</p><ul><li><code>weights[1, i]</code>: <code>(mp[i+1] - t[i])</code> / <code>weights[3, i]</code></li><li><code>weights[2, i]</code>: <code>(t[i] - mp[i])</code> / <code>weights[3, i]</code></li><li><code>weights[3, i]</code>: <code>mp[i+1] - mp[i]</code></li><li><code>weights[4, i]</code>: <code>inv(t[i] - t[i-1])</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/GeometricalWeights.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.GeometricalRadialAxisWeights" href="#SolidStateDetectors.GeometricalRadialAxisWeights"><code>SolidStateDetectors.GeometricalRadialAxisWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GeometricalRadialAxisWeights{T} &lt;: AbstractGeometricalAxisWeights{T}</code></pre><p><code>GeometricalRadialAxisWeights</code> stores certain precalculated (in its construction) fixed values of the radial axis, <code>ax</code>, of an cylindrical grid on which the field calculation is performed.  These precalculated values are further used in the field calculation  to calculate the six weights for the neighboring grid points in the SOR. </p><p><code>GeometricalRadialAxisWeights</code> has only one field: <code>weights::Array{T}, 2</code>, which is  of size <code>(6, length(ax.ticks))</code>. Each row holding the 6 precalculated values for one axis tick.</p><p>Axis ticks, <code>t = ax.ticks</code>, and midpoints, <code>mp = midpoints(get_extended_ticks(ax))</code>,<br/>(the middle points between to axis ticks) inbetween:<br/><code>... t[i-1] --- mp[i] --- t[i] --- mp[i+1] --- t[i+1] ...</code><br/>are required for the understanding of the precalculated values.</p><p>The columns store the following quantities:</p><ul><li><code>weights[1, i]</code>: <code>(mp[i+1] - t[i])</code> / <code>weights[3, i]</code></li><li><code>weights[2, i]</code>: <code>(t[i] - mp[i])</code> / <code>weights[3, i]</code></li><li><code>weights[3, i]</code>: <code>(mp[i+1] - mp[i]) / t[i]</code></li><li><code>weights[4, i]</code>: <code>mp[i+1] / (t[i+1] - t[i])</code></li><li><code>weights[5, i]</code>: <code>mp[i] / (t[i] - t[i-1])</code><br/># Developer note: maybe this one could be removed as it basically stores the same as <code>weights[4, i-1]</code></li><li><code>weights[6, i]</code>: <code>(mp[i+1]^2 - mp[i]^2)/2</code></li></ul><p>Developer note: Some of the weights for <code>i == 1</code> are set manually as <code>r = 0</code> requires some special treatment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/GeometricalWeights.jl#L70-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Grid" href="#SolidStateDetectors.Grid"><code>SolidStateDetectors.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Grid{T, N, S &lt;: AbstractCoordinateSystem, AT} &lt;: AbstractGrid{T, N}</code></pre><p>Collection of <code>N</code> axes that define the dimensions of the grid needed to calculate  <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>, <a href="#SolidStateDetectors.ElectricField"><code>ElectricField</code></a> or <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Tick type (element type) of the axes.</li><li><code>N</code>: Dimension of the grid.</li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.</li></ul><p><strong>Fields</strong></p><ul><li><code>axes::AT</code>: Tuple of length <code>N</code> containing <code>DiscreteAxis</code> for each dimension of the grid.</li></ul><p>See also <a href="#SolidStateDetectors.DiscreteAxis"><code>DiscreteAxis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Grids/Grids.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Grid-Union{Tuple{Simulation{T, Cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.Grid-Union{Tuple{Simulation{T, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.Grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid(sim::Simulation{T, Cartesian}; kwargs...)
Grid(sim::Simulation{T, Cylindrical}; kwargs...)</code></pre><p>Initializes a <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> based on the objects defined in a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a>.</p><p>The important points of all objects are sampled and added to the ticks of the grid. The grid initialization can be tuned using a set of keyword arguments listed below.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T, S}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the grid will be defined.</li></ul><p><strong>Keywords</strong></p><ul><li><code>max_tick_distance = missing</code>: Maximum distance between neighbouring ticks of the grid.   Additional grid ticks will be added if two neighbouring ticks are too far apart.   <code>max_tick_distance</code> can either be a <code>Quantity</code>, e.g. <code>1u&quot;mm&quot;</code>, or a Tuple of <code>Quantity</code>,    e.g. <code>(1u&quot;mm&quot;, 15u&quot;°&quot;, 3u&quot;mm&quot;)</code>,   to set it for each axis of the <code>Grid</code> separately. Note that a <code>CartesianGrid3D</code> requires a    <code>Tuple{LengthQuantity, LengthQuantity, LengthQuantity}</code> while a <code>CylindricalGrid</code> requires a   <code>Tuple{LengthQuantity, AngleQuantity, LengthQuantity}</code>.   If <code>max_tick_distance</code> is <code>missing</code>, one fourth of the axis length is used.</li><li><code>max_distance_ratio::Real = 5</code>: If the ratio between a tick and its left and right neighbour  is greater than <code>max_distance_ratio</code>, additional ticks are added between the ticks that are  further apart. This prevents the ticks from being too unevenly spaced.</li><li><code>add_ticks_between_important_ticks::Bool = true</code>: If set to <code>true</code>, additional points   will be added in between the important points obtained from sampling the objects of the   simulation. If some objects are too close together, this will ensure a noticeable gap   between them in the calculation of potentials and fields.</li><li><code>for_weighting_potential::Bool = false</code>: Grid will be optimized for the calculation of    an <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> if set to <code>true</code>, and of a <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a>   if set to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L200-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ImpurityScale" href="#SolidStateDetectors.ImpurityScale"><code>SolidStateDetectors.ImpurityScale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ImpurityScale{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Impurity scalar field of the simulation. It is kinda an alpha map for the impurity density of semiconductors. It can takes values between <code>0</code> and <code>1</code>:</p><ul><li><p><code>1</code>: The impurity density has its full value. For grid points in depleted region of the semiconductor. </p></li><li><p><code>]0,1[</code>: The impurity density is scaled down but not zero. For grid points at the edge of the depleted region which are partially depleted.</p></li><li><p><code>0</code>: The impurity density is set to <code>0</code>. For grid points in undepleted regions of the semiconductor.</p></li></ul><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>data</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.  </li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{T, N}</code>: Array containing the values of the impurity scale at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points for which the impurity scale is determined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/ImpurityScale.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.LinearChargeDensity" href="#SolidStateDetectors.LinearChargeDensity"><code>SolidStateDetectors.LinearChargeDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LinearChargeDensity{T &lt;: SSDFloat} &lt;: AbstractChargeDensity{T}</code></pre><p>Charge density model which assumes a linear gradient in charge density in each dimension of a Cartesian coordinate system.</p><p><strong>Fields</strong></p><ul><li><code>offsets::NTuple{3,T}</code>: charge density values at the origin of each dimension.</li><li><code>gradients::NTuple{3,T}</code>: linear slopes in <code>x</code>, <code>y</code> and <code>z</code> direction.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>LinearChargeDensity</code> is defined in the configuration file through the field <code>charge_density</code>  (of a <code>passive</code> or <code>surrounding</code>) with <code>name: linear</code> and optional fields <code>x</code>, <code>y</code> and <code>z</code> that can each contain <code>init</code> for initial values at 0 and <code>gradient</code> for gradients in that dimension.</p><p>An example definition of a linear charge density looks like this:</p><pre><code class="language-yaml hljs">charge_density:
  name: cylindrical
  x:  # impurity profile with linear gradient in x
    init: 1.0e-10     # C/m³
    gradient: 1.0e-11 # C/m⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDensities/LinearChargeDensity.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.LinearImpurityDensity" href="#SolidStateDetectors.LinearImpurityDensity"><code>SolidStateDetectors.LinearImpurityDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LinearImpurityDensity{T &lt;: SSDFloat} &lt;: AbstractImpurityDensity{T}</code></pre><p>Impurity density model which assumes a linear gradient in impurity density in each dimension of a Cartesian coordinate system.</p><p><strong>Fields</strong></p><ul><li><code>offsets::NTuple{3,T}</code>: impurity density values at the origin of each dimension.</li><li><code>gradients::NTuple{3,T}</code>: linear slopes in <code>x</code>, <code>y</code> and <code>z</code> direction.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>LinearImpurityDensity</code> is defined in the configuration file through the field <code>impurity_density</code>  (of a <code>passive</code> or <code>surrounding</code>) with <code>name: linear</code> and optional fields <code>x</code>, <code>y</code> and <code>z</code> that can each contain <code>init</code> for initial values at 0 and <code>gradient</code> for gradients in that dimension.</p><p>An example definition of a linear impurity density looks like this:</p><pre><code class="language-yaml hljs">impurity_density:
  name: cylindrical
  x:  # impurity profile with linear gradient in x
    init: 1.0e10     # 1/m³
    gradient: 1.0e11 # 1/m⁴</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ImpurityDensities/LinearImpurityDensity.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.NBodyChargeCloud" href="#SolidStateDetectors.NBodyChargeCloud"><code>SolidStateDetectors.NBodyChargeCloud</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NBodyChargeCloud{T, N, SH} &lt;: AbstractChargeCloud</code></pre><p>Struct which defines a charge cloud consisting of multiple point-like charge carriers, initially distributed around a given center.</p><p><strong>Parametric Types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>N</code>: Number of shells.</li><li><code>SH</code>: Geometry of the shells.</li></ul><p><strong>Fields</strong></p><ul><li><code>locations::Vector{CartesianPoint{T}}</code>: Positions of the charge carriers that are part of the charge cloud.</li><li><code>energies::Vector{T}</code>: Energies of the respective charge carriers, in the same order as <code>locations</code>.</li><li><code>shell_structure::SH</code>: Initial geometry of the charge carriers around the <code>center</code> point, relevant for plotting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeCloudModels/ChargeCloudModels.jl#L6-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Integer}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Integer, Type{PT}}} where {T, PT&lt;:SolidStateDetectors.ParticleType}" href="#SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Integer}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Integer, Type{PT}}} where {T, PT&lt;:SolidStateDetectors.ParticleType}"><code>SolidStateDetectors.NBodyChargeCloud</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NBodyChargeCloud(center::CartesianPoint{T}, energy::T, N::Integer, particle_type::Type{PT} = Gamma; kwargs...)</code></pre><p>Returns an <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a> for a given <code>energy</code> deposition at a position that defines the <code>center</code> of the charge cloud, given by a center charge surrounded by shells of approximately <code>N</code> point charges equally distributed on the surface of a sphere. Find the algorithm to create the shells <a href="https://www.cmu.edu/biolphys/deserno/pdf/sphere_equi.pdf">here</a>.</p><p><strong>Arguments</strong></p><ul><li><code>center::CartesianPoint{T}</code>: Center position of the <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a>.</li><li><code>energy::RealQuantity</code>: Deposited energy with units. If no units are given, the value is parsed in units of eV.</li><li><code>N::Integer</code>: Approximate number of charges in the <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a> (might vary by around 1%).</li><li><code>particle_type</code>: <a href="#SolidStateDetectors.ParticleType"><code>ParticleType</code></a> of the particle that deposited the energy. Default is <code>Gamma</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>radius::T</code>: Estimate for the radius of the <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a>. Default is determined from <code>particle_type</code> via <code>radius_guess</code>.</li><li><code>number_of_shells::Int</code>: Number of shells around the <code>center</code> point. Default is <code>2</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">center = CartesianPoint{T}([0,0,0])
energy = 1460u&quot;keV&quot;
NBodyChargeCloud(center, energy, 200, number_of_shells = 3)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using values with units for <code>energy</code> requires the package <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeCloudModels/ChargeCloudModels.jl#L97-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Type{PT}}} where {T, PT&lt;:SolidStateDetectors.ParticleType}" href="#SolidStateDetectors.NBodyChargeCloud-Union{Tuple{PT}, Tuple{T}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real}, Tuple{CartesianPoint{T}, Union{Unitful.Quantity{&lt;:var&quot;#s37&quot;}, var&quot;#s37&quot;} where var&quot;#s37&quot;&lt;:Real, Type{PT}}} where {T, PT&lt;:SolidStateDetectors.ParticleType}"><code>SolidStateDetectors.NBodyChargeCloud</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NBodyChargeCloud(center::CartesianPoint{T}, energy::T, particle_type::Type{PT} = Gamma; kwargs...)</code></pre><p>Returns an <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a> for a given <code>energy</code> deposition at a position that defines the <code>center</code> of the charge cloud, given by a center charge surrounded by shells consisting of platonic solids.</p><p><strong>Arguments</strong></p><ul><li><code>center::CartesianPoint{T}</code>: Center position of the <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a>.</li><li><code>energy::RealQuantity</code>: Deposited energy with units. If no units are given, the value is parsed in units of eV.</li><li><code>particle_type</code>: <a href="#SolidStateDetectors.ParticleType"><code>ParticleType</code></a> of the particle that deposited the energy. Default is <code>Gamma</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>radius::T</code>: Estimate for the radius of the <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a>. Default is determined from <code>particle_type</code> via <code>radius_guess</code>.</li><li><code>number_of_shells::Int</code>: Number of shells around the <code>center</code> point. Default is <code>2</code>.</li><li><code>shell_structure</code>: Geometry with which the charges are distributed in the shells. Default is <code>Dodecahedron</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">center = CartesianPoint{T}([0,0,0])
energy = 1460u&quot;keV&quot;
NBodyChargeCloud(center, energy, number_of_shells = 3, shell_structure = SolidStateDetectors.Icosahedron)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using values with units for <code>energy</code> requires the package <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeCloudModels/ChargeCloudModels.jl#L29-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ParticleType" href="#SolidStateDetectors.ParticleType"><code>SolidStateDetectors.ParticleType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ParticleType</code></pre><p>Type of a particle that deposits energy in a <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a>. Currently defined are <code>Alpha</code>, <code>Beta</code> and <code>Gamma</code>.</p><p><code>ParticleType</code> is used to determine the radius of an <a href="#SolidStateDetectors.NBodyChargeCloud"><code>NBodyChargeCloud</code></a>, where the default radius for <code>Alpha</code> is 0.1mm and the default radius for <code>Beta</code> and <code>Gamma</code> is 0.5mm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeCloudModels/ParticleTypes.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Passive" href="#SolidStateDetectors.Passive"><code>SolidStateDetectors.Passive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Passive{T,G,MT,CDM} &lt;: AbstractPassive{T}</code></pre><p>Passive object, assigned to a <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a>.</p><p>For the calculation of the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> and <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a>,  passives can be fixed to a constant potential. They can additionally have a charge density  profile that has an influence on the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>G</code>: Type of <code>geometry</code>.</li><li><code>MT</code>: Type of <code>material</code>.</li><li><code>CDM</code>: Type of <code>charge_density_model</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Custom name for the passive, relevant for plotting.</li><li><code>id::Int</code>: Unique id that will unambiguously identify the passive.</li><li><code>potential::T</code>: Potential (in V) to which the passive will be fixed during the calculation of the electric potential.   For floating passives, the <code>potential</code> value is <code>NaN</code>.</li><li><code>temperature::T</code>: Temperature (in K) of the passive.</li><li><code>material::MT</code>: Material of the passive.</li><li><code>charge_density_model::CDM</code>: Charge density model for the points inside the passive.</li><li><code>geometry::G</code>: Geometry of the passive, see <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>Passive</code> is defined through an entry in the <code>passives</code> array of a detector or an entry in the <code>surroundings</code> array in the configuration file. It needs <code>material</code> and <code>geometry</code> and can optionally be given a <code>name</code>, <code>id</code>, <code>potential</code>, <code>temperature</code> and <code>charge_density</code>.</p><p>An example definition of passives looks like this:</p><pre><code class="language-yaml hljs">passives:
  - name: Passivated Surface
    material: HPGe
    charge_density: # ...
    geometry: # ...
  - name: Cryostat
    id: 3
    potential: 0
    temperature: 293K
    material: Al
    geometry: # ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/SolidStateDetector/Passive.jl#L3-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointCharge" href="#SolidStateDetectors.PointCharge"><code>SolidStateDetectors.PointCharge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PointCharge{T} &lt;: AbstractChargeCloud</code></pre><p>Struct which defines a single point-like charge carrier.</p><p><strong>Fields</strong></p><ul><li><code>locations::SVector{1, CartesianPoint{T}}</code>: Position of the charge carrier, saved as single entry of a <code>Vector</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">center = CartesianPoint{T}(0,0,0)
pc = PointCharge(center) # Constructor: creates a PointCharge around (0,0,0)
pc.locations             # Array that only contains the center point</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeCloudModels/PlatonicSolids/PlatonicSolids.jl#L25-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointType" href="#SolidStateDetectors.PointType"><code>SolidStateDetectors.PointType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PointType = UInt8</code></pre><p>Stores certain information about a grid point via bit-flags. </p><p>Right now, there are:</p><pre><code class="nohighlight hljs">const update_bit      = 0x01
const undepleted_bit  = 0x02
const pn_junction_bit = 0x04
const bulk_bit     = 0x08</code></pre><p><strong>Examples</strong></p><p>How to get information out of a <code>PointType</code> variable <code>point_type</code>:</p><ol><li><code>point_type &amp; update_bit == 0</code> -&gt; do not update this point (for fixed points)     </li><li><code>point_type &amp; update_bit &gt;  0</code> -&gt; do update this point    </li><li><code>point_type &amp; undepleted_bit &gt; 0</code> -&gt; this point is undepleted</li><li><code>point_type &amp; pn_junction_bit &gt; 0</code> -&gt; this point belongs to the solid state detector, meaning that it is in the volume of the n-type or p-type material.</li><li><code>point_type &amp; bulk_bit &gt; 0</code> -&gt; this point is only surrounded by points marked as <code>pn_junction_bit</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/PointTypes.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PointTypes" href="#SolidStateDetectors.PointTypes"><code>SolidStateDetectors.PointTypes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PointTypes{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Information about the grid points used to calculate the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> stored via bit-flags. Data is stored as <a href="#SolidStateDetectors.PointType"><code>PointType</code></a> which is an <code>UInt8</code>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>grid.axes</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.  </li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{PointType, N}</code>: Array containing the point type values at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points for which the point types are determined.</li></ul><p>See also <a href="#SolidStateDetectors.PointType"><code>PointType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/PointTypes.jl#L33-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.PotentialCalculationSetup" href="#SolidStateDetectors.PotentialCalculationSetup"><code>SolidStateDetectors.PotentialCalculationSetup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PotentialCalculationSetup</code></pre><p><code>PotentialCalculationSetup</code> holds the grid, fields and certain precalculated fixed parameters for the field calculation. This struct will be calculated after each refinement as is depends on the grid. </p><p><code>grid</code>: The 3-dimensional grid, either Cartesian or cylindrical, on which the field will be calculated. </p><p>The fields:</p><ul><li><code>potential</code>: This is the 4-dimensional array of the extended 3D potential array. </li></ul><p>The fourth dimensions comes from the red-black (even-odd) division in order to parallelize the field calculation.  Extended means that the grid holds one additional tick at both sides of all axes necessary for boundary handling (reflecting, fixed, ...) at the ends of the grid.</p><ul><li><code>point_types</code>: Also a 4-dimensional array. Same structure as the <code>potential</code>-array.</li><li><code>volume_weights</code>: Also a 4-dimensional array. Same structure as the <code>potential</code>-array.</li><li><code>q_eff_imp</code>: Also a 4-dimensional array. Same structure as the <code>potential</code>-array.</li><li><code>imp_scale</code>: Also a 4-dimensional array. Same structure as the <code>potential</code>-array.</li><li><code>q_eff_fix</code>: Also a 4-dimensional array. Same structure as the <code>potential</code>-array.</li><li><code>ϵ_r</code>: Normal 3-dimensional array! In order to calculate the final 6 weights for each grid point in the SOR, </li></ul><p>the eight values of the dielectric permittivity (of each octant) around the grid point needs to be loaded.  Here not special division is possible for the red-black (even-odd) division. </p><p>Precalculated parameters:</p><ul><li><code>geom_weights</code>: The parts of the calculation of the six weights in the SOR can be precalculated. Those are stored here for each axis/dimension.</li><li><code>sor_const</code>: Vector holding the SOR constants. In the cartesian case only the first entry is used. As the optimal value for the SOR constant</li></ul><p>depends on the grid, the constant is linear increased and the array holds the respective value for each radial axis tick. </p><ul><li><code>bias_voltage</code>: <code>maximum_applied_potential - minimum_applied_potential</code>. Used for depletion handling, but might be obsolete by now. </li><li><code>maximum_applied_potential</code>: Used for depletion handling, but might be obsolete by now. </li><li><code>minimum_applied_potential</code>: Used for depletion handling, but might be obsolete by now. </li><li><code>grid_boundary_factors</code>: Used in the application of boundary conditions in the field calculation for decaying (infinite) boundary conditions </li></ul><p>to approximate the decay of the potential (depending on the grid).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/PotentialCalculationSetup/PotentialCalculationSetup.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.SSDInterval" href="#SolidStateDetectors.SSDInterval"><code>SolidStateDetectors.SSDInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SSDInterval{T &lt;: SSDFloat, L, R, BL, BR} &lt;: IntervalSets.TypedEndpointsInterval{L,R,T}</code></pre><p>Interval containing boundary conditions of left and right boundary as parametric type (<code>BL</code> and <code>BR</code>).</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>L</code>: Boundary type of the left endpoint.</li><li><code>R</code>: Boundary type of the right endpoint.</li><li><code>BL</code>: Boundary condition at the left endpoint.</li><li><code>BR</code>: Boundary condition at the right endpoint.</li></ul><p>The boundary types of an <code>SSDInterval</code> can be <code>L, R ∈ {:closed, :open}</code>.</p><p>The boundary conditions of an <code>SSDInterval</code> can be <code>BL, BR ∈ {:periodic, :reflecting, :infinite, :r0, :fixed}</code>.</p><p><strong>Fields</strong></p><ul><li><code>left::T</code>: Value of the left endpoint.</li><li><code>right::T</code>: Value of the right endpoint.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/World/World.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Semiconductor" href="#SolidStateDetectors.Semiconductor"><code>SolidStateDetectors.Semiconductor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Semiconductor{T,G,MT,CDM,IDM} &lt;: AbstractSemiconductor{T}</code></pre><p>Semiconductor bulk of a <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a>.</p><p>This is the volume in which electrons and holes will drift during the signal development.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>G</code>: Type of <code>geometry</code>.</li><li><code>MT</code>: Type of <code>material</code>.</li><li><code>CDM</code>: Type of <code>charge_drift_model</code>.</li><li><code>IDM</code>: Type of <code>impurity_density_model</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>temperature::T</code>: Temperature (in K) of the semiconductor.</li><li><code>material::MT</code>: Material of the semiconductor.</li><li><code>impurity_density_model::IDM</code>: Impurity density model for the points inside the semiconductor.</li><li><code>charge_drift_model::CDM</code>: Model that describes the drift of electrons and holes inside the semiconductor.</li><li><code>geometry::G</code>: Geometry of the semiconductor, see <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>Semiconductor</code> is defined through the <code>semiconductor</code> field of a detector. It needs <code>material</code> and <code>geometry</code>, and can optionally be given a <code>temperature</code>, <code>impurity_density</code> and <code>charge_drift_model</code>.</p><p>An example definition of a semiconductor looks like this:</p><pre><code class="language-yaml hljs">semiconductor:
  material: HPGe
  temperature: 78
  impurity_density: # ...
  charge_drift_model: # ...
  geometry: # ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/SolidStateDetector/Semiconductor.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.Simulation" href="#SolidStateDetectors.Simulation"><code>SolidStateDetectors.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Simulation{T &lt;: SSDFloat, CS &lt;: AbstractCoordinateSystem} &lt;: AbstractSimulation{T}</code></pre><p>Collection of all parts of a simulation of a <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>CS</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li></ul><p><strong>Fields</strong></p><ul><li><code>config_dict::Dict</code>: Dictionary (parsed configuration file) which initialized the simulation.</li><li><code>input_units::NamedTuple</code>: Units with which the <code>config_dict</code> should be parsed.</li><li><code>medium::NamedTuple</code>: Medium of the world.</li><li><code>detector::Union{SolidStateDetector{T}, Missing}</code>: The <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a> of the simulation.</li><li><code>world::World{T, 3, CS}</code>: The <a href="#SolidStateDetectors.World"><code>World</code></a> of the simulation.</li><li><code>q_eff_imp::Union{EffectiveChargeDensity{T}, Missing}</code>: Effective charge resulting from the impurites in the <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a> of the <code>detector</code>.</li><li><code>imp_scale::Union{ImpurityScale{T}, Missing}</code>: Scale (alpha channel) of the impurity density (for depletion handling).  </li><li><code>q_eff_fix::Union{EffectiveChargeDensity{T}, Missing}</code>: Fixed charge resulting from fixed space charges in <a href="#SolidStateDetectors.Passive"><code>Passive</code></a> of the <code>detector</code>.</li><li><code>ϵ_r::Union{DielectricDistribution{T}, Missing}</code>: The <a href="#SolidStateDetectors.DielectricDistribution"><code>DielectricDistribution</code></a> of the simulation.</li><li><code>point_types::Union{PointTypes{T}, Missing}</code>: The <a href="#SolidStateDetectors.PointTypes"><code>PointTypes</code></a> of the simulation.</li><li><code>electric_potential::Union{ElectricPotential{T}, Missing}</code>: The <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> of the simulation.</li><li><code>weighting_potentials::Vector{Any}</code>: The <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> for each <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> of the <code>detector</code> in the simulation.</li><li><code>electric_field::Union{ElectricField{T}, Missing}</code>: The <a href="#SolidStateDetectors.ElectricField"><code>ElectricField</code></a> of the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.SolidStateDetector" href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetectors.SolidStateDetector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SolidStateDetector{T,SC,CT,PT,VDM} &lt;: AbstractConfig{T}</code></pre><p>Struct to describe all parts of a solid state detector, i.e. the <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a>, a set of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> and (optionally) <a href="#SolidStateDetectors.Passive"><code>Passive</code></a> and virtual drift volumes.</p><p>The properties of the parts (charge densities, fixed potentials, relative permittivity of the materials) will be used as input to the calculation of <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> and  <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> in the <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>SC</code>: Type of the <code>semiconductor</code>.</li><li><code>CT</code>: Type of the <code>contacts</code>.</li><li><code>PT</code>: Type of the <code>passives</code>.</li><li><code>VDM</code>: Type of the <code>virtual_drift_volumes</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Name of the detector.</li><li><code>semiconductor::SC</code>: <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a> of the detector. </li><li><code>contacts::CT</code>: Vector of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> of the detector. </li><li><code>passives::PT</code>: Vector of <a href="#SolidStateDetectors.Passive"><code>Passive</code></a> objects, e.g. holding structures around the detector. </li><li><code>virtual_drift_volumes::VDM</code>: Vector of virtual drift volumes in which the drift can be modulated   by user-defined methods for <code>modulate_driftvector</code>, e.g. <a href="#SolidStateDetectors.DeadVolume"><code>DeadVolume</code></a>.</li></ul><p>See also <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a>, <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>, <a href="#SolidStateDetectors.Passive"><code>Passive</code></a> and <a href="#SolidStateDetectors.DeadVolume"><code>DeadVolume</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/SolidStateDetector/SolidStateDetector.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.VelocityParameters" href="#SolidStateDetectors.VelocityParameters"><code>SolidStateDetectors.VelocityParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VelocityParameters{T &lt;: SSDFloat}</code></pre><p>Values needed to parametrize the longitudinal drift velocity of electrons or hole along a crystal axis as a function of the electric field strength.</p><p><strong>Background information</strong></p><p>The parameterization for the longitudinal drift velocity, <span>$v_l$</span>, as a function of the electric  field strength, <span>$E$</span>, was proposed by <a href="https://ieeexplore.ieee.org/document/1448053">D.M. Caughey and R.E. Thomas</a> and later expanded by <a href="https://www.sciencedirect.com/science/article/pii/S0168900299012863">L. Mihailescu et al.</a>:</p><p class="math-container">\[v_l = \frac{\mu_0 E}{(1 + (E/E_0 )^{\beta})^{1/ \beta}} - \mu_{n} E.\]</p><p>with the four parameters, <span>$\mu_0$</span>, <span>$\beta$</span>, <span>$E_0$</span> and <span>$\mu_n$</span>, which are different for electrons and holes and for the different crystal axes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parameter <span>$\mu_n$</span> accounts for the Gunn effects for electrons and should be 0 for holes.</p></div></div><p><strong>Fields</strong></p><ul><li><code>mu0::T</code>: Parameter <span>$\mu_0$</span> in the parameterization shown above.</li><li><code>beta::T</code>: Parameter <span>$\beta$</span> in the parameterization shown above.</li><li><code>E0::T</code>: Parameter <span>$E_0$</span> in the parameterization shown above.</li><li><code>mun::T</code>: Parameter <span>$\mu_n$</span> in the parameterization shown above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDriftModels/ADLChargeDriftModel/ADLChargeDriftModel.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.WeightingPotential" href="#SolidStateDetectors.WeightingPotential"><code>SolidStateDetectors.WeightingPotential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WeightingPotential{T, N, S, AT} &lt;: AbstractArray{T, N}</code></pre><p>Weighting potential for a given <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> which is a unitless potential.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Element type of <code>data</code>.</li><li><code>N</code>: Dimension of the <code>grid</code> and <code>data</code> array.  </li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li><li><code>AT</code>: Axes type.  </li></ul><p><strong>Fields</strong></p><ul><li><code>data::Array{T, N}</code>: Array containing the values of the weighting potential at the discrete points of the <code>grid</code>.</li><li><code>grid::Grid{T, N, S, AT}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> defining the discrete points for which the weighting potential is determined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/WeightingPotential.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.World" href="#SolidStateDetectors.World"><code>SolidStateDetectors.World</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct World{T &lt;: SSDFloat, N, S} &lt;: AbstractWorld{T, N}</code></pre><p>Definition of the finite volume on which a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> is performed.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>N</code>: Dimensions of the world.</li><li><code>S</code>: Coordinate system (<code>Cartesian</code> or <code>Cylindrical</code>).</li></ul><p><strong>Fields</strong></p><ul><li><code>intervals::NTuple{N, SSDInterval{T}}</code>: A set of <a href="#SolidStateDetectors.SSDInterval"><code>SSDInterval</code></a> defining the dimensions of the world.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/World/World.jl#L43-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.add_baseline_and_extend_tail-Union{Tuple{UV}, Tuple{TV}, Tuple{U}, Tuple{T}, Tuple{RadiationDetectorSignals.RDWaveform{T, U, TV, UV}, Int64, Int64}} where {T, U, TV, UV}" href="#SolidStateDetectors.add_baseline_and_extend_tail-Union{Tuple{UV}, Tuple{TV}, Tuple{U}, Tuple{T}, Tuple{RadiationDetectorSignals.RDWaveform{T, U, TV, UV}, Int64, Int64}} where {T, U, TV, UV}"><code>SolidStateDetectors.add_baseline_and_extend_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_baseline_and_extend_tail(wv::RadiationDetectorSignals.RDWaveform{T,U,TV,UV}, n_baseline_samples::Int, total_waveform_length::Int) where {T,U,TV,UV}</code></pre><p>Adds a zero-valued baseline in front of the waveform <code>wv</code> and extends (or cuts off) the waveform at the end with the last value of <code>wv</code>. A waveform of length <code>total_waveform_length</code> is returned.</p><p><strong>Arguments</strong></p><ul><li><code>wv::RadiationDetectorSignals.RDWaveform{T,U,TV,UV}</code>: A waveform (signal over time).</li><li><code>n_baseline_samples::Int</code>: Number of samples added in front of the waveform with values 0. </li><li><code>total_waveform_length::Int</code>: Number of samples of the extended waveform which is returned.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">add_baseline_and_extend_tail(wv, 1000, 5000)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This functions assumes that the time steps between the samples of the input waveform <code>wv</code> are the same. Thus, that the input waveform is sampled with a fixed frequency. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L239-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.add_fano_noise" href="#SolidStateDetectors.add_fano_noise"><code>SolidStateDetectors.add_fano_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_fano_noise(E_dep::RealQuantity, E_ionisation::RealQuantity, f_fano::Real)::RealQuantity</code></pre><p>Adds Fano noise to an energy deposition <code>E_dep</code>, assuming a detector material ionisation energy <code>E_ionisation</code> and a Fano factor <code>f_fano</code>.</p><p><strong>Arguments</strong></p><ul><li><code>E_dep::RealQuantity</code>: Energy deposited in a semiconductor material.</li><li><code>E_ionisation</code>: Energy needed to create one electron-hole-pair in the semiconductor material.</li><li><code>f_fano</code>: Fano factor of the material.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">add_fano_noise(100u&quot;keV&quot;, 2.95u&quot;eV&quot;, 0.129)</code></pre><p>Some material properties are stored in <code>SolidStateDetectors.material_properties</code> and can be used here:</p><pre><code class="language-julia hljs">material = SolidStateDetectors.material_properties[:HPGe]
add_fano_noise(100u&quot;keV&quot;, material.E_ionisation, material.f_fano)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using values with units for <code>E_dep</code> or <code>E_ionisation</code> requires the package <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeStatistics/ChargeStatistics.jl#L4-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.apply_initial_state!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Grid{T}}} where {T&lt;:Union{Float16, Float32, Float64}, CS}" href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Grid{T}}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>SolidStateDetectors.apply_initial_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_initial_state!(sim::Simulation{T}, ::Type{ElectricPotential}, grid::Grid{T} = Grid(sim);
        not_only_paint_contacts::Bool = true, paint_contacts::Bool = true)::Nothing where {T &lt;: SSDFloat}</code></pre><p>Applies the initial state for the calculation of the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>. It overwrites <code>sim.electric_potential</code>, <code>sim.q_eff_imp</code>, <code>sim.q_eff_fix</code>, <code>sim.ϵ</code> and <code>sim.point_types</code> with the material properties and fixed potentials defined in <code>sim.detector</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the initial state should be applied.</li><li><code>grid::Grid{T}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> to apply the initial state on. If no <code>grid</code> is given,    a default <code>Grid</code> is determined from <code>sim</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">apply_initial_state!(sim, ElectricPotential, paint_contacts = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L467-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Grid{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.apply_initial_state!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Grid{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.apply_initial_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_initial_state!(sim::Simulation{T}, ::Type{WeightingPotential}, contact_id::Int, grid::Grid{T} = Grid(sim))::Nothing</code></pre><p>Applies the initial state for the calculation of the <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> for the [<code>Contact</code>}(@ref) with the id <code>contact_id</code>. It overwrites <code>sim.weighting_potentials[contact_id]</code> with the fixed values on the [<code>Contact</code>}(@ref).</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the initial state should be applied.</li><li><code>contact_id::Int</code>: The <code>id</code> of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> for which the <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> is to be calculated.</li><li><code>grid::Grid{T}</code>: <a href="#SolidStateDetectors.Grid"><code>Grid</code></a> to apply the initial state on. If no <code>grid</code> is given,    a default <code>Grid</code> is determined from <code>sim</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">apply_initial_state!(sim, WeightingPotential, 1) # =&gt;  applies initial state for weighting potential of contact with id 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L508-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calc_new_potential_by_neighbors_3D-Union{Tuple{T}, Tuple{T, NTuple{6, T}, NTuple{6, T}}} where T" href="#SolidStateDetectors.calc_new_potential_by_neighbors_3D-Union{Tuple{T}, Tuple{T, NTuple{6, T}, NTuple{6, T}}} where T"><code>SolidStateDetectors.calc_new_potential_by_neighbors_3D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function calc_new_potential_by_neighbors_3D(
    volume_weight::T,
    weights::NTuple{6,T},
    neighbor_potentials::NTuple{6,T},
) where {T}</code></pre><p>Calculates and returns the new potential value of a grid point given the potential values of the six neighbouring grid points (2 in each dimension) <code>neighbor_potentials</code>, the weights corresponding to those six potentials of the neighboring grid points, the weight due to the volume of the grid point itself (the voxel around it).</p><p>For more detailed information see Chapter 5.2.2 &quot;Calculation of the Electric Potential&quot; Eqs. 5.31 to 5.37 in https://mediatum.ub.tum.de/doc/1620954/1620954.pdf.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/SuccessiveOverRelaxation/SOR.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_capacitance_matrix-Union{Tuple{Simulation{T}}, Tuple{T}} where T" href="#SolidStateDetectors.calculate_capacitance_matrix-Union{Tuple{Simulation{T}}, Tuple{T}} where T"><code>SolidStateDetectors.calculate_capacitance_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_capacitance_matrix(sim::Simulation{T}; consider_multiplicity::Bool = true) where {T}</code></pre><p>Calculates the Maxwell Capacitance <code>N×N</code>-Matrix in units of pF, where <code>N</code> is the number of contacts of <code>sim.detector</code>. The individual elements, <span>$c_{i,j}$</span>, are calculated via  <a href="#SolidStateDetectors.calculate_mutual_capacitance-Tuple{Simulation, Tuple{Int64, Int64}}"><code>calculate_mutual_capacitance(sim::Simulation, (i,j)::Tuple{Int,Int})</code></a>. The matrix should be symmetric. The difference of <code>C[i,j]</code> and <code>C[j,i]</code> are due  to numerical precision in the integration due to the different grids of the two weighting potentials.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the capacitance matrix is calculated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>consider_multiplicity::Bool = true</code>: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the <code>x-axis</code> going from <code>[0, x_max]</code> and the <code>y-axis</code> going from <code>[0, y_max]</code> the multiplicity is 4   and, if <code>consider_multiplicity == true</code>, the returned value is already multiplied by 4.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Capacitance.jl#L104-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_field!-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, CS}" href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>SolidStateDetectors.calculate_electric_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_electric_field!(sim::Simulation{T}; n_points_in_φ::Union{Missing, Int} = missing)::Nothing</code></pre><p>Calculates the <a href="#SolidStateDetectors.ElectricField"><code>ElectricField</code></a> from the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> stored in <code>sim.electric_potential</code> and stores it in <code>sim.electric_field</code>. </p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which <code>sim.electric_potential</code> has already been calculated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>n_points_in_φ::Union{Missing, Int}</code>: For a 2D <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> (cylindrical coordinates and symmetric in <code>φ</code>), <code>sim.electric_potential</code>   is extended to <code>n_points_in_φ</code> &quot;layers&quot; in <code>φ</code> in order to calculate a 3D [<code>ElectricField</code>]. If <code>n_points_in_φ</code> is <code>missing</code>, the    default value is <code>36</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">calculate_electric_field!(sim, n_points_in_φ = 32)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method only works if <code>sim.electric_potential</code> has already been calculated and is not <code>missing</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L1148-L1167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_electric_potential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_electric_potential!(sim::Simulation{T}; kwargs...)::Nothing</code></pre><p>Calculates the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> for a given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> <code>sim</code> on an adaptive grid through successive over relaxation and stores it in <code>sim.electric_potential</code>.</p><p>There are several keyword arguments which can be used to tune the calculation.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a> is calculated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>1e-7</code> (times bias voltage).</li><li><code>refinement_limits</code>: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.<ul><li><code>rl::Real</code> -&gt; One refinement with <code>rl</code> equal in all 3 dimensions.</li><li><code>rl::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code> -&gt; One refinement with <code>rl</code> set individual for each dimension.</li><li><code>rl::Vector{&lt;:Real}</code> -&gt; <code>length(l)</code> refinements with <code>rl[i]</code> being the limit for the i-th refinement. </li><li><code>rl::Vector{&lt;:Real,&lt;:Real,&lt;:Real}}</code> -&gt; <code>length(rl)</code> refinements with <code>rl[i]</code> being the limits for the <code>i</code>-th refinement.</li></ul></li><li><code>min_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is <code>1e-5</code> for linear axes and <code>1e-5 / (0.25 * r_max)</code> for the polar axis in case of a cylindrical <code>grid</code>.</li><li><code>max_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.</li><li><code>max_distance_ratio::Real</code>: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than <code>max_distance_ratio</code>.       Default is <code>5</code>.</li><li><code>grid::Grid</code>: Initial grid used to start the simulation. Default is <code>Grid(sim)</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is <code>false</code>.</li><li><code>use_nthreads::Union{Int, Vector{Int}}</code>: If <code>&lt;:Int</code>, <code>use_nthreads</code> defines the maximum number of threads to be used in the computation.    Fewer threads might be used depending on the current grid size due to threading overhead. Default is <code>Base.Threads.nthreads()</code>.   If <code>&lt;:Vector{Int}</code>, <code>use_nthreads[i]</code> defines the number of threads used for each grid (refinement) stage of the field simulation.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be <code>∈ [1.0, 2.0]</code>. Default is <code>[1.4, 1.85]</code>.   In case of Cartesian coordinates, only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">calculate_electric_potential!(sim, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L1086-L1142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_mutual_capacitance-Tuple{Simulation, Tuple{Int64, Int64}}" href="#SolidStateDetectors.calculate_mutual_capacitance-Tuple{Simulation, Tuple{Int64, Int64}}"><code>SolidStateDetectors.calculate_mutual_capacitance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_mutual_capacitance(sim::Simulation, ij::Tuple{Int, Int}; consider_multiplicity::Bool = true)</code></pre><p>Returns the mutual capacitance between the contacts with ID <code>i = ij[1]</code> and <code>j = ij[2]</code>. It is calculated via the weighting potentials of the contacts, <span>$\Phi_i^w(\vec{r})$</span> and <span>$\Phi_j^w(\vec{r})$</span>:</p><p class="math-container">\[c_{ij} = \epsilon_0 \int_{World} \nabla \Phi_i^w(\vec{r}) ϵ_r(\vec{r}) \nabla \Phi_j^w(\vec{r}) d\vec{r}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These are elements of the Mawell Capcitance Matrix. Look up <a href="../man/capacitances/#Capacitances">Capacitances</a> for more information.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The electric potential as well as the two weighting potentials of both contacts have to be calculated.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the capacitance matrix is calculated.</li><li><code>ij::Tuple{Int,Int}</code>: Tuple of indices of the contacts for which the capacitance should be calculated. </li></ul><p><strong>Keywords</strong></p><ul><li><code>consider_multiplicity::Bool = true</code>: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the <code>x-axis</code> going from <code>[0, x_max]</code> and the <code>y-axis</code> going from <code>[0, y_max]</code> the multiplicity is 4   and, if <code>consider_multiplicity == true</code>, the returned value is already multiplied by 4.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Capacitance.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_stored_energy-Tuple{Simulation}" href="#SolidStateDetectors.calculate_stored_energy-Tuple{Simulation}"><code>SolidStateDetectors.calculate_stored_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_stored_energy(sim::Simulation; consider_multiplicity::Bool = true)</code></pre><p>Calculates and returns the energy stored in the <a href="#SolidStateDetectors.ElectricField"><code>ElectricField</code></a> of a  <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a> in a given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> in units of J.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> with <code>sim.detector</code> for which the stored energy is calculated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>consider_multiplicity::Bool = true</code>: Whether symmetries of the system should be taken into account.    For example, in case of true coaxial detector center around the origin and calculated on a cartesian grid    with the <code>x-axis</code> going from <code>[0, x_max]</code> and the <code>y-axis</code> going from <code>[0, y_max]</code> the multiplicity is 4   and, if <code>consider_multiplicity == true</code>, the returned value is already multiplied by 4.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/ElectricFieldEnergy.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.calculate_weighting_potential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_weighting_potential!(sim::Simulation{T}, contact_id::Int; kwargs...)::Nothing</code></pre><p>Calculates the <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> for a <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> with <code>contact_id</code>  given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> <code>sim</code> on an adaptive grid through successive over relaxation  and stores it in <code>sim.weighting_potentials[contact_id]</code>.</p><p>There are several keyword arguments which can be used to tune the calculation.</p><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>1e-7</code>.</li><li><code>refinement_limits</code>: Defines the maximum relative allowed differences    of the potential value of neighbored grid points    in each dimension for each refinement.<ul><li><code>rl::Real</code> -&gt; One refinement with <code>rl</code> equal in all 3 dimensions.</li><li><code>rl::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code> -&gt; One refinement with <code>rl</code> set individual for each dimension.</li><li><code>rl::Vector{&lt;:Real}</code> -&gt; <code>length(l)</code> refinements with <code>rl[i]</code> being the limit for the i-th refinement. </li><li><code>rl::Vector{&lt;:Real,&lt;:Real,&lt;:Real}}</code> -&gt; <code>length(rl)</code> refinements with <code>rl[i]</code> being the limits for the <code>i</code>-th refinement.</li></ul></li><li><code>min_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is <code>1e-5</code> for linear axes and <code>1e-5 / (0.25 * r_max)</code> for the polar axis in case of a cylindrical <code>grid</code>.</li><li><code>max_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.</li><li><code>max_distance_ratio::Real</code>: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than <code>max_distance_ratio</code>.       Default is <code>5</code>.</li><li><code>grid::Grid</code>: Initial grid used to start the simulation. Default is <code>Grid(sim)</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is <code>false</code>. This is an experimental feature:   In undepleted regions (determined in <code>calculate_electric_potential!(sim; depletion_handling = true)</code>), the dielectric permittivity   of the semiconductor is scaled up to mimic conductive behavior. The scale factor can be tuned via    the function <a href="#SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T}}, Tuple{T}} where T"><code>scaling_factor_for_permittivity_in_undepleted_region</code></a>.</li><li><code>use_nthreads::Union{Int, Vector{Int}}</code>: If <code>&lt;:Int</code>, <code>use_nthreads</code> defines the maximum number of threads to be used in the computation.    Fewer threads might be used depending on the current grid size due to threading overhead. Default is <code>Base.Threads.nthreads()</code>.   If <code>&lt;:Vector{Int}</code>, <code>use_nthreads[i]</code> defines the number of threads used for each grid (refinement) stage of the field simulation.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be <code>∈ [1.0, 2.0]</code>. Default is <code>[1.4, 1.85]</code>.   In case of Cartesian coordinates, only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">calculate_weighting_potential!(sim, 1, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L1023-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.drift_charges!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">drift_charges!(evt::Event{T}, sim::Simulation{T}; kwargs...)::Nothing where {T &lt;: SSDFloat}</code></pre><p>Calculates the electron and hole drift paths for the given <a href="#SolidStateDetectors.Event"><code>Event</code></a> and <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a>     and stores them in <code>evt.drift_paths</code>.</p><p><strong>Arguments</strong></p><ul><li><code>evt::Event{T}</code>: <a href="#SolidStateDetectors.Event"><code>Event</code></a> for which the charges should be drifted.</li><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> which defines the setup in which the charges in <code>evt</code> should drift.</li></ul><p><strong>Keywords</strong></p><ul><li><code>max_nsteps::Int = 1000</code>: Maximum number of steps in the drift of each hit. </li><li><code>Δt::RealQuantity = 5u&quot;ns&quot;</code>: Time step used for the drift.</li><li><code>diffusion::Bool = false</code>: Activate or deactive diffusion of charge carriers via random walk.</li><li><code>self_repulsion::Bool = false</code>: Activate or deactive self-repulsion of charge carriers of the same type.</li><li><code>verbose = true</code>: Activate or deactivate additional info output.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">drift_charges!(evt, sim, Δt = 1u&quot;ns&quot;, verbose = false)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using values with units for <code>Δt</code> requires the package <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L126-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.estimate_depletion_voltage-Union{Tuple{Simulation{T}}, Tuple{T}, Tuple{Simulation{T}, T}, Tuple{Simulation{T}, T, T}} where T&lt;:AbstractFloat" href="#SolidStateDetectors.estimate_depletion_voltage-Union{Tuple{Simulation{T}}, Tuple{T}, Tuple{Simulation{T}, T}, Tuple{Simulation{T}, T, T}} where T&lt;:AbstractFloat"><code>SolidStateDetectors.estimate_depletion_voltage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_depletion_voltage(sim::Simulation{T},
    Umin::T = minimum(broadcast(c -&gt; c.potential, sim.detector.contacts)),
    Umax::T = maximum(broadcast(c -&gt; c.potential, sim.detector.contacts));
    contact_id::Int = determine_bias_voltage_contact_id(sim.detector),
    tolerance::AbstractFloat = 1e-1,
    verbose::Bool = true) where {T &lt;: AbstractFloat}</code></pre><p>Estimates the potential needed to fully deplete the detector in a given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> at the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> with id <code>contact_id</code> by bisection method. The default <code>contact_id</code> is determined automatically via <code>determine_bias_voltage_contact_id(sim.detector)</code>. The default searching range of potentials is set by the extrema of contact potentials.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the depletion voltage should be determined.</li><li><code>Umin::T</code>: The minimum value of the searching range.</li><li><code>Umax::T</code>: The maximum value of the searching range.</li></ul><p><strong>Keywords</strong></p><ul><li><code>contact_id::Int</code>: The <code>id</code> of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> at which the potential is applied.</li><li><code>tolerance::AbstractFloat</code>: The acceptable accuracy of results. Default is 1e-1.</li><li><code>verbose::Bool = true</code>: Activate or deactivate additional info output. Default is <code>true</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using SolidStateDetectors
sim = Simulation(SSD_examples[:InvertedCoax])
calculate_electric_potential!(sim)
estimate_depletion_voltage(sim)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The accuracy of the result depends on the precision of the initial simulation.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function performs two 2D or 3D field calculations, depending on <code>sim</code>.<br/>Thus, keep in mind that is might consume some memory. </p></div></div><p>See also <a href="#SolidStateDetectors.is_depleted-Tuple{PointTypes}"><code>is_depleted</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/DepletionVoltage.jl#L21-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical}}, Tuple{T}} where T" href="#SolidStateDetectors.get_active_volume-Union{Tuple{PointTypes{T, 3, Cylindrical}}, Tuple{T}} where T"><code>SolidStateDetectors.get_active_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_active_volume(point_types::PointTypes{T}) where {T}</code></pre><p>Returns an approximation of the active volume of the detector by summing up the cell volumes of all cells marked as depleted.</p><p><strong>Arguments</strong></p><ul><li><code>point_types::PointTypes{T}</code>: Point types of a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">get_active_volume(sim.point_types)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only <code>φ</code>-symmetries are taken into account.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/PointTypes.jl#L109-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_charge_density" href="#SolidStateDetectors.get_charge_density"><code>SolidStateDetectors.get_charge_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_charge_density(cd::AbstractChargeDensity, pt::AbstractCoordinatePoint)</code></pre><p>Returns the charge density at a given point, <code>pt</code>, based on the charge density model <code>cd</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cd::AbstractChargeDensity</code>: The <a href="#SolidStateDetectors.AbstractChargeDensity"><code>AbstractChargeDensity</code></a> defining the charge density inside a <a href="#SolidStateDetectors.Passive"><code>Passive</code></a>.</li><li><code>pt::AbstractCoordinatePoint</code>: The point at which <code>cd</code> is to be evaluated.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The value returned by <code>get_charge_density</code> is in units of C/m³ (SI units).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ChargeDensities/ChargeDensities.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_electron_and_hole_contribution-Union{Tuple{S}, Tuple{T}, Tuple{Event{T}, Simulation{T, S}, Int64}} where {T&lt;:Union{Float16, Float32, Float64}, S}" href="#SolidStateDetectors.get_electron_and_hole_contribution-Union{Tuple{S}, Tuple{T}, Tuple{Event{T}, Simulation{T, S}, Int64}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>SolidStateDetectors.get_electron_and_hole_contribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_electron_and_hole_contribution(evt::Event{T}, sim::Simulation{T}, contact_id::Int)</code></pre><p>Returns the electron and hole contribution to the waveform of a <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> with a given <code>contact_id</code> of an <a href="#SolidStateDetectors.Event"><code>Event</code></a> as a <code>NamedTuple</code> with two entries:  <code>electron_contribution</code> and <code>hole_contribution</code>.</p><p><strong>Arguments</strong></p><ul><li><code>evt::Event{T}</code>: <a href="#SolidStateDetectors.Event"><code>Event</code></a> in which the charges have already been drifted.</li><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> which defines the setup in which the charges in <code>evt</code> were drifted.</li><li><code>contact_id::Int</code>: The <code>id</code> of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> for which the waveform should be split into electron and hole contribution.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Plots
using SolidStateDetector
T = Float32

simulation = Simulation{T}(SSD_examples[:InvertedCoax])
simulate!(simulation)
event = Event([CartesianPoint{T}(0.02,0.01,0.05)])
simulate!(event, simulation)

contact_id = 1
wf = get_electron_and_hole_contribution(evt, sim, contact_id)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The drift paths in <code>evt</code> need to be calculated using <a href="#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>drift_charges!</code></a> before calling this function.</p></div></div><p>See also <a href="#SolidStateDetectors.plot_electron_and_hole_contribution"><code>plot_electron_and_hole_contribution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L275-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_impurity_density" href="#SolidStateDetectors.get_impurity_density"><code>SolidStateDetectors.get_impurity_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_impurity_density(id::AbstractImpurityDensity, pt::AbstractCoordinatePoint)</code></pre><p>Returns the impurity density at a given point, <code>pt</code>, based on the impurity density model <code>id</code>.</p><p><strong>Arguments</strong></p><ul><li><code>id::AbstractImpurityDensity</code>: The <a href="#SolidStateDetectors.AbstractImpurityDensity"><code>AbstractImpurityDensity</code></a> defining the impurity density inside a <a href="#SolidStateDetectors.Semiconductor"><code>Semiconductor</code></a>.</li><li><code>pt::AbstractCoordinatePoint</code>: The point at which <code>id</code> is to be evaluated.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The value returned by <code>get_impurity_density</code> is in units of 1/m³ (SI Units).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ImpurityDensities/ImpurityDensities.jl#L24-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_path_to_example_config_files-Tuple{}" href="#SolidStateDetectors.get_path_to_example_config_files-Tuple{}"><code>SolidStateDetectors.get_path_to_example_config_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_path_to_example_config_files()::String</code></pre><p>Returns the path to the example detector configuration files provided by the package.</p><p>See also <a href="#SolidStateDetectors.SSD_examples"><code>SSD_examples</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/examples.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_signals!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.get_signals!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.get_signals!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_signals!(evt::Event{T}, sim::Simulation{T}; Δt::RealQuantity = 5u&quot;ns&quot;)::Nothing where {T &lt;: SSDFloat}</code></pre><p>Generates the signals/waveforms from the drift paths of an <a href="#SolidStateDetectors.Event"><code>Event</code></a> for each <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>, for which a <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> is specified in <code>sim.weighting_potentials</code>.</p><p>The output is stored in <code>evt.waveforms</code>.</p><p><strong>Arguments</strong></p><ul><li><code>evt::Event{T}</code>: <a href="#SolidStateDetectors.Event"><code>Event</code></a> for which the waveforms should be generated.</li><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> which defines the setup in which the waveforms are generated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>Δt::RealQuantity = 5u&quot;ns&quot;</code>: Time steps with which the drift paths were calculated.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">get_signals!(evt, sim, Δt = 1u&quot;ns&quot;) # if evt.drift_paths were calculated in time steps of 1ns</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method only works if <code>evt.drift_paths</code> has already been calculated and is not <code>missing</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L167-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_sor_kernel-Tuple{Type{Cylindrical}, Any, Any, Vararg{Any}}" href="#SolidStateDetectors.get_sor_kernel-Tuple{Type{Cylindrical}, Any, Any, Vararg{Any}}"><code>SolidStateDetectors.get_sor_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_sor_kernel(::Type{S}, args...)</code></pre><p>where S is either Cartesian or Cylindrical. </p><p>Developer notes: Currently (February 2022), there are some limitations to the <code>@kernel</code> macro  of the package KernelAbstractions.jl. Especially, regarding usage of dispatch. </p><p>Thus, we have to write two kernel functions right now for the Cartesian &amp; Cylindrical case: <code>sor_cyl_gpu!</code> and <code>sor_car_gpu!</code>.</p><p>Inside kernel functions, everything is (and has to be) inlined and we can make use of multiple dispatch.  So in the end we only have to write one function for the kernel, <code>sor_kernel</code>,  which is then inlined inside the two kernel functions.</p><p>We can also use most of the CPU functions with the restriction that all  types have to be independent on the GPU-indices of the kernel.  E.g., making use of <code>i23_is_even_t = Val(iseven(i2 + i3))</code> and other similar statements is not possible, which are used in the CPU implementation for optimization. On the GPU (currently) those statements have to be calculated and booleans have to be passed. Maybe this will change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/SuccessiveOverRelaxation/GPU_kernel.jl#L142-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes-Union{Tuple{SolidStateDetectors.ImpurityScale{T, 3}}, Tuple{T}} where T" href="#SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes-Union{Tuple{SolidStateDetectors.ImpurityScale{T, 3}}, Tuple{T}} where T"><code>SolidStateDetectors.get_ticks_at_positions_of_edge_of_depleted_volumes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ticks_at_positions_of_edge_of_depleted_volumes(impscale::ImpurityScale{T, 3})</code></pre><p>The impurity scale field is analyzed in order to find and return ticks where the gradient is strong, which is the case at the surface of the depleted volume of a semiconductor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/ImpurityScale.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.get_ticks_at_positions_of_large_gradient-Union{Tuple{ElectricPotential{T, 3}}, Tuple{T}} where T" href="#SolidStateDetectors.get_ticks_at_positions_of_large_gradient-Union{Tuple{ElectricPotential{T, 3}}, Tuple{T}} where T"><code>SolidStateDetectors.get_ticks_at_positions_of_large_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ticks_at_positions_of_large_gradient(epot::ElectricPotential)</code></pre><p>The electric potential is analyzed in order to find and return ticks where the gradient (electric field) is strong (relativ to its maximum).</p><p>In the 1D case of a pn-junction, the electric field strength is the largest at the position of the pn-junction. Thus, this function is likely to return ticks which are located close to the pn-junction of a semiconductor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/ElectricPotential.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.handle_depletion-Union{Tuple{T}, Tuple{T, T, NTuple{6, T}, T, T}} where T" href="#SolidStateDetectors.handle_depletion-Union{Tuple{T}, Tuple{T, T, NTuple{6, T}, T, T}} where T"><code>SolidStateDetectors.handle_depletion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function handle_depletion(
    new_potential::T, 
    imp_scale::T,
    neighbor_potentials::NTuple{6,T}, 
    q_eff_imp::T, 
    volume_weight::T,
)::Tuple{T, PointType} where {T}</code></pre><p>This function handles the grid points with volumes which are not fully depleted. The decision depends on the proposal for the new potential value, <code>new_potential_proposal</code>,  for the respective grid point in that iteration and the potential values of the neighboring grid points, <code>neighbor_potentials</code>.</p><p>If <code>vmin = minimum(neighbor_potentials) &lt; new_potential_proposal &lt; vmax = maximum(neighbor_potentials)</code> =&gt; fully depleted =&gt; imp_scale = 1</p><p>If it undershoots or overshoots, the impurity density in the grid point is scaled down via reducing <code>imp_scale ∈ [0, 1]</code> of this grid point.</p><p>This decision is based on the fact that the potential inside a solid-state  detector increases monotonically from a <code>p+</code>-contact towards an <code>n+</code>-contact. Thus, there cannot be local extrema. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If a fixed charge impurity is present, e.g. due to a charged passivated surface, this handling is probably not valid anymore as the potential between a  <code>p+</code>-contact towards an <code>n+</code>-contact is not required to change monotonically anymore.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/SuccessiveOverRelaxation/SOR.jl#L30-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.is_depleted-Tuple{PointTypes}" href="#SolidStateDetectors.is_depleted-Tuple{PointTypes}"><code>SolidStateDetectors.is_depleted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_depleted(point_types::PointTypes)::Bool</code></pre><p>Returns <code>true</code> if all <a href="#SolidStateDetectors.PointType"><code>PointType</code></a> values of the <a href="#SolidStateDetectors.PointTypes"><code>PointTypes</code></a> of a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> are marked as depleted and <code>false</code> if any point in the <a href="#SolidStateDetectors.PointTypes"><code>PointTypes</code></a> is marked as undepleted.</p><p>It can be used to determine whether the <a href="#SolidStateDetectors.SolidStateDetector"><code>SolidStateDetector</code></a> is depleted at the provided bias voltage.</p><p><strong>Arguments</strong></p><ul><li><code>point_types::PointTypes</code>: <a href="#SolidStateDetectors.PointTypes"><code>PointTypes</code></a> of a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">is_depleted(sim.point_types)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ScalarPotentials/PointTypes.jl#L87-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.merge_second_order_important_ticks-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T" href="#SolidStateDetectors.merge_second_order_important_ticks-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T"><code>SolidStateDetectors.merge_second_order_important_ticks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_second_order_important_ticks(imp::Vector{T}, imp_second_order::Vector{T}; min_diff::T = T(1e-6)) where {T}</code></pre><p>Merge all elements of the second vector, <code>imp_second_order</code>, into the first vector, <code>imp</code>,  if they are not too close (via <code>min_diff</code>) to elements of the first vector. Returns the merged vector sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Axes/DiscreteAxis.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.parse_config_file-Tuple{AbstractString}" href="#SolidStateDetectors.parse_config_file-Tuple{AbstractString}"><code>SolidStateDetectors.parse_config_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_config_file(filename::AbstractString)::Dict where {T &lt;: SSDFloat}</code></pre><p>Reads in a configuration file and returns a parsed dictionary which holds all the information specified in the configuration file.</p><p>Find detailed information on configuration files in <a href="../man/config_files/#Configuration-Files">Configuration Files</a>.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: File name of the configuration file. If the file is not   in the same directory, a path to the file is required.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently supported formats for the configuration files:     - <a href="https://github.com/JuliaData/YAML.jl">YAML</a>: <code>filename</code> ends with <code>.yaml</code>.     - <a href="https://github.com/JuliaIO/JSON.jl">JSON</a>: <code>filename</code> ends with <code>.json</code>.     - <a href="https://github.com/radforddc/icpc_siggen">SigGen</a>: <code>filename</code> ends with <code>.config</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/IO/ParseConfigFiles.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.plot_electron_and_hole_contribution" href="#SolidStateDetectors.plot_electron_and_hole_contribution"><code>SolidStateDetectors.plot_electron_and_hole_contribution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_electron_and_hole_contribution(evt::Event{T}, sim::Simulation{T}, contact_id::Int)</code></pre><p>Plots the waveform as well as the electron and hole contribution to the waveform  of a <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> with a given <code>contact_id</code> of an <a href="#SolidStateDetectors.Event"><code>Event</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>evt::Event{T}</code>: <a href="#SolidStateDetectors.Event"><code>Event</code></a> in which the charges have already been drifted.</li><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> which defines the setup in which the charges in <code>evt</code> were drifted.</li><li><code>contact_id::Int</code>: The <code>id</code> of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> for which the waveform should be split into electron and hole contribution.</li></ul><p><strong>Keywords</strong></p><ul><li><code>n_samples::Int</code>: Number of samples with which the waveforms will be plotted. The default is the number of samples of the original waveform.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Plots
using SolidStateDetector
T = Float32

simulation = Simulation{T}(SSD_examples[:InvertedCoax])
simulate!(simulation)
event = Event([CartesianPoint{T}(0.02,0.01,0.05)])
simulate!(event, simulation)

contact_id = 1
plot_electron_and_hole_contribution(evt, sim, contact_id, n_samples = 300)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The drift paths in <code>evt</code> need to be calculated using <a href="#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>drift_charges!</code></a> before calling this function.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method requires to load the package <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</p></div></div><p>See also <a href="#SolidStateDetectors.get_electron_and_hole_contribution-Union{Tuple{S}, Tuple{T}, Tuple{Event{T}, Simulation{T, S}, Int64}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>get_electron_and_hole_contribution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L336-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.readsiggen-Tuple{String}" href="#SolidStateDetectors.readsiggen-Tuple{String}"><code>SolidStateDetectors.readsiggen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readsiggen(file_path::String; T::Type)</code></pre><p>Reads a <a href="https://github.com/radforddc/icpc_siggen">SigGen</a> configuration file (ending in <code>.config</code>) in &#39;file_path&#39; and returns a dictionary of all parameters. Non-existing parameteres are set to <code>0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>file_path::String</code>: File path leading to the <a href="https://github.com/radforddc/icpc_siggen">SigGen</a> configuration file.</li></ul><p><strong>Keywords</strong></p><ul><li><code>T::Type</code>: Type of the parameters in the output dictionary. Default is <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/IO/SigGenInterface.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{ElectricPotential}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{ElectricPotential}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{ElectricPotential}, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine!(sim::Simulation{T}, ::Type{ElectricPotential}, max_diffs::Tuple, minimum_distances::Tuple, kwargs...)</code></pre><p>Takes the current state of <code>sim.electric_potential</code> and refines it with respect to the input arguments <code>max_diffs</code> and <code>minimum_distances</code> by</p><ol><li>extending the <code>grid</code> of <code>sim.electric_potential</code> to be a closed grid in all dimensions,</li><li>refining the axis of the grid based on <code>max_diffs</code> and <code>minimum_distances</code>: Insert new ticks between two existing ticks such that the potential difference between each tick becomes smaller than <code>max_diff[i]</code> (<code>i</code> -&gt; dimension) but that the distances between the ticks stays larger than <code>minimum_distances[i]</code>, and</li><li>creating the new data array for the refined grid and fill it by interpolation of the the initial <code>grid</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which <code>sim.electric_potential</code> will be refined.</li><li><code>max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code>: Maximum potential difference between two discrete ticks of <code>sim.electric_potential.grid</code> after refinement.</li><li><code>minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code>: Minimum distance (in SI Units) between two discrete ticks of <code>sim.electric_potential.grid</code> after refinement.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">SolidStateDetectors.refine!(sim, ElectricPotential, max_diffs = (100, 100, 100), minimum_distances = (0.01, 0.02, 0.01))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L739-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.refine!-Union{Tuple{T}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}}, Tuple{Simulation{T}, Type{WeightingPotential}, Int64, Tuple{Real, Real, Real}, Tuple{Real, Real, Real}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.refine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine!(sim::Simulation{T}, ::Type{WeightingPotential}, max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}, minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real})</code></pre><p>Takes the current state of <code>sim.weighting_potentials[contact_id]</code> and refines it with respect to the input arguments <code>max_diffs</code> and <code>minimum_distances</code> by</p><ol><li>extending the <code>grid</code> of <code>sim.weighting_potentials[contact_id]</code> to be a closed grid in all dimensions,</li><li>refining the axis of the grid based on <code>max_diffs</code> and <code>minimum_distances</code>: Insert new ticks between two existing ticks such that the potential difference between each tick becomes smaller than <code>max_diff[i]</code> (<code>i</code> -&gt; dimension) but that the distances between the ticks stays larger than <code>minimum_distances[i]</code>, and</li><li>creating the new data array for the refined grid and fill it by interpolation of the the initial <code>grid</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which <code>sim.weighting_potentials[contact_id]</code> will be refined.</li><li><code>contact_id::Int</code>: The <code>id</code> of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> for which the <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> is refined.</li><li><code>max_diffs::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code>: Maximum potential difference between two discrete ticks of <code>sim.weighting_potentials[contact_id].grid</code> after refinement.</li><li><code>minimum_distances::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code>: Minimum distance (in SI Units) between two discrete ticks of <code>sim.weighting_potentials[contact_id].grid</code> after refinement.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">SolidStateDetectors.refine!(sim, WeightingPotential, 1, max_diffs = (0.01, 0.01, 0.01), minimum_distances = (0.01, 0.02, 0.01))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L784-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T}}, Tuple{T}} where T" href="#SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T}}, Tuple{T}} where T"><code>SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaling_factor_for_permittivity_in_undepleted_region(sc::Semiconductor{T})::T where {T}</code></pre><p>This function is called in the calculations of weighting potentials of undepleted detectors.  The electric permittivity, <span>$ϵ_{r}$</span>, is scaled with this function in areas where the detector is undepleted. A value between <code>[0, +Inf]</code> should be returned. However, <code>Inf</code> should not be returned but instead a very high value should be returned in order to mimic perfect conductivity if that is desired. </p><p><strong>Arguments</strong></p><ul><li><code>sc::Semiconductor{T}</code>: Semiconductor for which the dielectric permittivity should be scaled up.</li></ul><div class="admonition is-danger"><header class="admonition-header">Experimental feature!</header><div class="admonition-body"><p>This feature is under research. The goal is to study the properties / signal response of undepleted detector.  This function is indented to be overwritten by the user to study the response. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/SolidStateDetector/Semiconductor.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.siggentodict-Tuple{Dict}" href="#SolidStateDetectors.siggentodict-Tuple{Dict}"><code>SolidStateDetectors.siggentodict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siggentodict(config::Dict; units::Dict)</code></pre><p>Converts the dictionary containing the parameters from a <a href="https://github.com/radforddc/icpc_siggen">SigGen</a> configuration file to a dictionary that can be understood by SolidStateDetectors.jl. </p><p><strong>Arguments</strong></p><ul><li><code>config::Dict</code>: Dictionary containing <a href="https://github.com/radforddc/icpc_siggen">SigGen</a> parameters (output of <code>readsiggen()</code>`).</li></ul><p><strong>Keywords</strong></p><ul><li><code>units::Dict</code>: Units used in <a href="https://github.com/radforddc/icpc_siggen">SigGen</a> configuration file (set to <code>&quot;mm&quot;</code>, <code>&quot;deg&quot;</code>, <code>&quot;V&quot;</code> and <code>&quot;K&quot;</code>).   The dictionary needs the fields <code>&quot;length&quot;</code>, <code>&quot;angle&quot;</code>, <code>&quot;potential&quot;</code> and <code>&quot;temperature&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/IO/SigGenInterface.jl#L102-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, S}" href="#SolidStateDetectors.simulate!-Union{Tuple{Simulation{T, S}}, Tuple{S}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, S}"><code>SolidStateDetectors.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate!( sim::Simulation{T}; kwargs...) where {T, S}</code></pre><p>Performs a full chain simulation for a given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> by</p><ol><li>calculating the <a href="#SolidStateDetectors.ElectricPotential"><code>ElectricPotential</code></a>,</li><li>calculating the <a href="#SolidStateDetectors.ElectricField"><code>ElectricField</code></a>,</li><li>calculating the <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> for each <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>.</li></ol><p>The output is stored in <code>sim.electric_potential</code>, <code>sim.electric_field</code> and <code>sim.weighting_potentials</code>, respectively.</p><p>There are several keyword arguments which can be used to tune the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which the full chain simulation should be performed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default of <code>convergence_limit</code> is <code>1e-7</code> (times bias voltage).</li><li><code>refinement_limits</code>: Defines the maximum relative (to applied bias voltage) allowed differences    of the potential value of neighboured grid points    in each dimension for each refinement.<ul><li><code>rl::Real</code> -&gt; One refinement with <code>rl</code> equal in all 3 dimensions.</li><li><code>rl::Tuple{&lt;:Real,&lt;:Real,&lt;:Real}</code> -&gt; One refinement with <code>rl</code> set individual for each dimension.</li><li><code>rl::Vector{&lt;:Real}</code> -&gt; <code>length(l)</code> refinements with <code>rl[i]</code> being the limit for the i-th refinement. </li><li><code>rl::Vector{&lt;:Real,&lt;:Real,&lt;:Real}}</code> -&gt; <code>length(rl)</code> refinements with <code>rl[i]</code> being the limits for the <code>i</code>-th refinement.</li></ul></li><li><code>min_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the minimum allowed distance between    two grid ticks for each dimension. It prevents the refinement to make the grid too fine.   Default is <code>1e-5</code> for linear axes and <code>1e-5 / (0.25 * r_max)</code> for the polar axis in case of a cylindrical <code>grid</code>.</li><li><code>max_tick_distance::Tuple{&lt;:Quantity, &lt;:Quantity, &lt;:Quantity}</code>: Tuple of the maximum allowed distance between    two grid ticks for each dimension used in the initialization of the grid.   Default is 1/4 of size of the world of the respective dimension.</li><li><code>max_distance_ratio::Real</code>: Maximum allowed ratio between the two distances in any dimension to the two neighbouring grid points.        If the ratio is too large, additional ticks are generated such that the new ratios are smaller than <code>max_distance_ratio</code>.       Default is <code>5</code>.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is <code>false</code>.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be <code>∈ [1.0, 2.0]</code>. Default is <code>[1.4, 1.85]</code>.   In case of Cartesian coordinates, only one value is taken.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>10000</code>. If set to <code>-1</code> there will be no limit.</li><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul><p>See also <a href="#SolidStateDetectors.calculate_electric_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_electric_potential!</code></a>, <a href="#SolidStateDetectors.calculate_electric_field!-Union{Tuple{Simulation{T, CS}}, Tuple{CS}, Tuple{T}} where {T&lt;:Union{Float16, Float32, Float64}, CS}"><code>calculate_electric_field!</code></a> and <a href="#SolidStateDetectors.calculate_weighting_potential!-Union{Tuple{T}, Tuple{Simulation{T}, Int64, Vararg{Any}}} where T&lt;:Union{Float16, Float32, Float64}"><code>calculate_weighting_potential!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">simulate!(sim, refinement_limits = [0.3, 0.1, 0.05], max_distance_ratio = 4, max_n_iterations = 20000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L1218-L1279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.simulate!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.simulate!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate!(evt::Event{T}, sim::Simulation{T}; kwargs...)::Nothing where {T &lt;: SSDFloat}</code></pre><p>Simulates the waveforms for the <a href="#SolidStateDetectors.Event"><code>Event</code></a> for a given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> by</p><ol><li>calculating the drift paths of all energy hits, at <code>evt.locations</code> and </li><li>generating the waveforms for each <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>, for which a <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> is specified in <code>sim.weighting_potentials</code>.</li></ol><p>The output is stored in <code>evt.drift_paths</code> and <code>evt.waveforms</code>.</p><p><strong>Arguments</strong></p><ul><li><code>evt::Event{T}</code>: <a href="#SolidStateDetectors.Event"><code>Event</code></a> for which the charges should be drifted.</li><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> which defines the setup in which the charges in <code>evt</code> should drift.</li></ul><p><strong>Keywords</strong></p><ul><li><code>max_nsteps::Int = 1000</code>: Maximum number of steps in the drift of each hit. </li><li><code>Δt::RealQuantity = 5u&quot;ns&quot;</code>: Time step used for the drift.</li><li><code>diffusion::Bool = false</code>: Activate or deactive diffusion of charge carriers via random walk.</li><li><code>self_repulsion::Bool = false</code>: Activate or deactive self-repulsion of charge carriers of the same type.</li><li><code>verbose = true</code>: Activate or deactivate additional info output.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">simulate!(evt, sim, Δt = 1u&quot;ns&quot;, verbose = false)</code></pre><p>See also <a href="#SolidStateDetectors.drift_charges!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>drift_charges!</code></a> and <a href="#SolidStateDetectors.get_signals!-Union{Tuple{T}, Tuple{Event{T}, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>get_signals!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Event/Event.jl#L204-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.simulate_waveforms-Union{Tuple{T}, Tuple{TypedTables.Table, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}" href="#SolidStateDetectors.simulate_waveforms-Union{Tuple{T}, Tuple{TypedTables.Table, Simulation{T}}} where T&lt;:Union{Float16, Float32, Float64}"><code>SolidStateDetectors.simulate_waveforms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simulate_waveforms( mcevents::TypedTables.Table, sim::Simulation{T}; kwargs...)
simulate_waveforms( mcevents::TypedTables.Table, sim::Simulation{T}, output_dir::AbstractString, output_base_name::AbstractString; kwargs...)</code></pre><p>Simulates the waveforms for all events defined in <code>mcevents</code> for a given <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> by</p><ol><li>calculating the drift paths of all energy hits defined in <code>mcevents</code>,</li><li>determining the signal (waveforms) for each <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>,   for which a <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> is specified in <code>sim.weighting_potentials</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>mcevents::TypedTables.Table</code>: Table with information about events in the simulated setup.</li><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> which defines the setup in which the charges in <code>mcevents</code> should drift.</li></ul><p>If <a href="https://github.com/JuliaIO/HDF5.jl">HDF5.jl</a> is loaded, this function has additional arguments. </p><p><strong>Additional Arguments (HDF5)</strong></p><ul><li><code>output_dir::AbstractString</code>: Directory where the HDF5 output file is saved.</li><li><code>output_base_name::AbstractString</code>: Basename of the HDF5 output file, default is <code>&quot;generated_waveforms&quot;</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>max_nsteps::Int = 1000</code>: Maximum number of steps in the drift of each hit. </li><li><code>Δt::RealQuantity = 4u&quot;ns&quot;</code>: Time step used for the drift.</li><li><code>diffusion::Bool = false</code>: Activate or deactive diffusion of charge carriers via random walk.</li><li><code>self_repulsion::Bool = false</code>: Activate or deactive self-repulsion of charge carriers of the same type.</li><li><code>number_of_carriers::Int = 1</code>: Number of charge carriers to be used in the N-Body simulation of an energy deposition. </li><li><code>number_of_shells::Int = 1</code>: Number of shells around the <code>center</code> point of the energy deposition.</li><li><code>verbose = false</code>: Activate or deactivate additional info output.</li><li><code>chunk_n_physics_events::Int = 1000</code> (HDF5 only): Number of events that should be saved in a single HDF5 output file.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">simulate_waveforms(mcevents, sim, Δt = 1u&quot;ns&quot;, verbose = false)
# =&gt; returns the input table `mcevents` with an additional column `waveform` in which the generated waveforms are stored</code></pre><pre><code class="language-julia hljs">import HDF5
simulate_waveforms(mcevents, sim, &quot;output_dir&quot;, &quot;my_basename&quot;, Δt = 1u&quot;ns&quot;, verbose = false)
# =&gt; simulates the charge drift and saves the output to &quot;output_dir/my_basename_evts_xx.h5&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The drift paths are just calculated temporarily and not returned.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using values with units for <code>Δt</code> requires the package <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/MCEventsProcessing/MCEventsProcessing.jl#L3-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ssd_read" href="#SolidStateDetectors.ssd_read"><code>SolidStateDetectors.ssd_read</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ssd_read(filename::AbstractString, ::Type{Simulation})</code></pre><p>Reads a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> from a HDF5 file with a given <code>filename</code>  using <a href="https://github.com/legend-exp/LegendHDF5IO.jl">LegendHDF5IO.jl</a>.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: Filename of the HDF5 file.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using HDF5 
using LegendHDF5IO
using SolidStateDetectors
sim = ssd_read(&quot;example_sim.h5&quot;, Simulation)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In order to use this method, the packages <a href="https://github.com/JuliaIO/HDF5.jl">HDF5.jl</a> and  <a href="https://github.com/legend-exp/LegendHDF5IO.jl">LegendHDF5IO.jl</a> have to be loaded before loading SolidStateDetectors.jl.</p></div></div><p>See also <a href="#SolidStateDetectors.ssd_write"><code>ssd_write</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/IO/IO.jl#L44-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ssd_write" href="#SolidStateDetectors.ssd_write"><code>SolidStateDetectors.ssd_write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ssd_write(filename::AbstractString, sim::Simulation)</code></pre><p>Converts a <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> to a <code>NamedTuple</code> and writes it to a HDF5 file  with a given <code>filename</code> using <a href="https://github.com/legend-exp/LegendHDF5IO.jl">LegendHDF5IO.jl</a>.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: Filename of the HDF5 file.</li><li><code>sim::Simulation</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> that should be written to the HDF5 file.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using HDF5 
using LegendHDF5IO
using SolidStateDetectors
sim = Simulation(SSD_examples[:InvertedCoax])
simulate!(sim)
ssd_write(&quot;example_sim.h5&quot;, sim)</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>If a file with <code>filename</code> already exists, it will be overwritten by this method.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In order to use this method, the packages <a href="https://github.com/JuliaIO/HDF5.jl">HDF5.jl</a> and  <a href="https://github.com/legend-exp/LegendHDF5IO.jl">LegendHDF5IO.jl</a> have to be loaded before loading SolidStateDetectors.jl.</p></div></div><p>See also <a href="#SolidStateDetectors.ssd_read"><code>ssd_read</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/IO/IO.jl#L10-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update!-Union{Tuple{_is_weighting_potential}, Tuple{only_2d}, Tuple{depletion_handling_enabled}, Tuple{T}, Tuple{SolidStateDetectors.PotentialCalculationSetup{T, S, N1, DATN1, N2, AT, DATN2, DATPT, DATGW, DATSOR} where {S, N1, DATN1&lt;:AbstractArray{T, N1}, N2, AT, DATN2&lt;:AbstractArray{T, N2}, DATPT&lt;:AbstractArray{UInt8, N2}, DATGW&lt;:AbstractMatrix{T}, DATSOR&lt;:AbstractVector{T}}, Nothing, Any}} where {T, depletion_handling_enabled, only_2d, _is_weighting_potential}" href="#SolidStateDetectors.update!-Union{Tuple{_is_weighting_potential}, Tuple{only_2d}, Tuple{depletion_handling_enabled}, Tuple{T}, Tuple{SolidStateDetectors.PotentialCalculationSetup{T, S, N1, DATN1, N2, AT, DATN2, DATPT, DATGW, DATSOR} where {S, N1, DATN1&lt;:AbstractArray{T, N1}, N2, AT, DATN2&lt;:AbstractArray{T, N2}, DATPT&lt;:AbstractArray{UInt8, N2}, DATGW&lt;:AbstractMatrix{T}, DATSOR&lt;:AbstractVector{T}}, Nothing, Any}} where {T, depletion_handling_enabled, only_2d, _is_weighting_potential}"><code>SolidStateDetectors.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function update!(   
    pcs::PotentialCalculationSetup{T}; 
    ::Nothing, # these two unused arguments are used such that the method
    ::Any;     # is similar to the GPU method for it.
    use_nthreads::Int = Base.Threads.nthreads(), 
    depletion_handling::Val{depletion_handling_enabled} = Val{false}(), 
    is_weighting_potential::Val{_is_weighting_potential} = Val{false}(),
    only2d::Val{only_2d} = Val{false}()</code></pre><p>)::Nothing where {T, depletion<em>handling</em>enabled, only<em>2d, _is</em>weighting_potential}</p><p>This function performs one iteration of the SOR. One iteration consists out of 4 steps:</p><pre><code class="nohighlight hljs">1) Iterate in parallel over all even points and update their potential. 
2) Apply the boundary conditions at the ends of the grid for all even points. 
3) Iterate in parallel over all odd points and update their potential. 
4) Apply the boundary conditions at the ends of the grid for all odd points.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/PotentialCalculation/SuccessiveOverRelaxation/CPU_update.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}" href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{ElectricPotential}}, Tuple{Simulation{T, CS}, Type{ElectricPotential}, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_till_convergence!( sim::Simulation{T} ::Type{ElectricPotential}, convergence_limit::Real; kwargs...)::T</code></pre><p>Takes the current state of <code>sim.electric_potential</code> and updates it until it has converged.</p><p>There are several keyword arguments which can be used to tune the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which <code>sim.electric_potential</code> will be updated.</li><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default is <code>1e-7</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>n_iterations_between_checks::Int</code>: Number of iterations between checks. Default is set to <code>500</code>.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>-1</code>. If set to <code>-1</code> there will be no limit.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is <code>false</code>.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be <code>∈ [1.0, 2.0]</code>. Default is <code>[1.4, 1.85]</code>.   In case of Cartesian coordinates, only one value is taken.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">SolidStateDetectors.update_till_convergence!(sim, ElectricPotential, 1e-6, depletion_handling = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L550-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}" href="#SolidStateDetectors.update_till_convergence!-Union{Tuple{CS}, Tuple{T}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64}, Tuple{Simulation{T, CS}, Type{WeightingPotential}, Int64, Real}} where {T&lt;:Union{Float16, Float32, Float64}, CS&lt;:SolidStateDetectors.ConstructiveSolidGeometry.AbstractCoordinateSystem}"><code>SolidStateDetectors.update_till_convergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_till_convergence!( sim::Simulation{T} ::Type{WeightingPotential}, contact_id::Int, convergence_limit::Real; kwargs...)::T</code></pre><p>Takes the current state of <code>sim.weighting_potentials[contact_id]</code> and updates it until it has converged.</p><p>There are several keyword arguments which can be used to tune the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation{T}</code>: <a href="#SolidStateDetectors.Simulation"><code>Simulation</code></a> for which <code>sim.weighting_potentials[contact_id]</code> will be updated.</li><li><code>contact_id::Int</code>: The <code>id</code> of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> for which the <a href="#SolidStateDetectors.WeightingPotential"><code>WeightingPotential</code></a> is to be calculated.</li><li><code>convergence_limit::Real</code>: <code>convergence_limit</code> times the bias voltage sets the convergence limit of the relaxation.   The convergence value is the absolute maximum difference of the potential between two iterations of all grid points.   Default is <code>1e-7</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>n_iterations_between_checks::Int</code>: Number of iterations between checks. Default is set to <code>500</code>.</li><li><code>max_n_iterations::Int</code>: Set the maximum number of iterations which are performed after each grid refinement.   Default is <code>-1</code>. If set to <code>-1</code> there will be no limit.</li><li><code>depletion_handling::Bool</code>: Enables the handling of undepleted regions. Default is <code>false</code>. This is an experimental feature:   In undepleted regions (determined in <code>calculate_electric_potential!(sim; depletion_handling = true)</code>), the dielectric permittivity   of the semiconductor is scaled up to mimic conductive behavior. The scale factor can be tuned via    the function <a href="#SolidStateDetectors.scaling_factor_for_permittivity_in_undepleted_region-Union{Tuple{SolidStateDetectors.Semiconductor{T}}, Tuple{T}} where T"><code>scaling_factor_for_permittivity_in_undepleted_region</code></a>.</li><li><code>use_nthreads::Int</code>: Number of threads to use in the computation. Default is <code>Base.Threads.nthreads()</code>.   The environment variable <code>JULIA_NUM_THREADS</code> must be set appropriately before the Julia session was   started (e.g. <code>export JULIA_NUM_THREADS=8</code> in case of bash).</li><li><code>not_only_paint_contacts::Bool = true</code>: Whether to only use the painting algorithm of the surfaces of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a>   without checking if points are actually inside them.   Setting it to <code>false</code> should improve the performance but the points inside of <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> are not fixed anymore.    </li><li><code>paint_contacts::Bool = true</code>: Enable or disable the painting of the surfaces of the <a href="#SolidStateDetectors.Contact"><code>Contact</code></a> onto the <code>grid</code>.</li><li><code>sor_consts::Union{&lt;:Real, NTuple{2, &lt;:Real}}</code>: Two element tuple in case of cylindrical coordinates.   First element contains the SOR constant for <code>r</code> = 0.   Second contains the constant at the outer most grid point in <code>r</code>. A linear scaling is applied in between.   First element should be smaller than the second one and both should be <code>∈ [1.0, 2.0]</code>. Default is <code>[1.4, 1.85]</code>.   In case of Cartesian coordinates, only one value is taken.</li><li><code>verbose::Bool=true</code>: Boolean whether info output is produced or not.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">SolidStateDetectors.update_till_convergence!(sim, WeightingPotential, 1, 1e-6, use_nthreads = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/Simulation/Simulation.jl#L641-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Box" href="#SolidStateDetectors.ConstructiveSolidGeometry.Box"><code>SolidStateDetectors.ConstructiveSolidGeometry.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Box{T, CO} &lt;: AbstractVolumePrimitive{T}</code></pre><p>Volume primitive describing a three-dimensional <a href="../man/csg/#Box">Box</a> with its surfaces being parallel to the <code>xy</code>, <code>xy</code> and <code>yz</code> plane.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>CO</code>: Describes whether the surface belongs to the primitive.    It can be <code>ClosedPrimitive</code>, i.e. the surface points belong to the primitive,   or <code>OpenPrimitive</code>, i.e. the surface points do not belong to the primitive.</li></ul><p><strong>Fields</strong></p><ul><li><code>hX::T</code>: Half of the width in <code>x</code> dimension (in m).</li><li><code>hY::T</code>: Half of the width in <code>y</code> dimension (in m).</li><li><code>hZ::T</code>: Half of the width in <code>z</code> dimension (in m).</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>Box</code>.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>Box</code> around its <code>origin</code>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>Box</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>box</code>.</p><p>Example definitions of a <code>Box</code> looks like this:</p><pre><code class="language-yaml hljs">box:
  widths: [2, 4, 6] # =&gt; hX = 1; hY = 2; hZ = 3;
  origin: [0, 0, 0] # [x, y, z] - Optional; Default: [0, 0, 0]
  rotate: # Optional; Default: no rotation
    Z: 0 </code></pre><p>The halfwidths <code>hX</code>, <code>hY</code> and <code>hZ</code> can also be defined directly in the configuration file:</p><pre><code class="language-yaml hljs">box:
  halfwidths: [1, 2, 3] # =&gt; hX = 1; hY = 2; hZ = 3;</code></pre><p>or</p><pre><code class="language-yaml hljs">box:
  hX: 1
  hY: 2
  hZ: 3</code></pre><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/VolumePrimitives/Box.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference" href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CSGDifference{T, A &lt;: AbstractGeometry{T}, B &lt;: AbstractGeometry{T}} &lt;: AbstractConstructiveGeometry{T}</code></pre><p>A <code>CSGDifference</code> of two geometries <code>a</code> and <code>b</code> is defined as the set of points that are  in <code>a</code> but not in <code>b</code> (<code>a &amp;&amp; !b</code>).</p><p><img src="../../../docs/src/assets/CSGDifference.png" alt="CSGDifference"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <code>b</code> is treated as open primitive. This means that points which are in  <code>a</code> and on the surface of <code>b</code> will still be in the <code>CSGDifference</code> of <code>a</code> and <code>b</code>.</p></div></div><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>A</code>: Type of geometry <code>a</code>.</li><li><code>B</code>: Type of geometry <code>b</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>a::A</code>: Main geometry.</li><li><code>b::B</code>: Geometry to be subtracted from <code>a</code>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>CSGDifference</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>difference</code>, followed by an array of geometries from which the difference is constructed. The first entry of the array is the main geometry,  from which all following geometry entries are subtracted.</p><p>An example definition of a <code>CSGDifference</code> looks like this:</p><pre><code class="language-yaml hljs">difference: # a &amp;&amp; !b
  - tube: # a
      r: 2
      h: 1
  - tube: # b
      r: 1
      h: 1.1</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than two geometries are passed, all entries starting from the second will be subtracted from the first.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Keep in mind that to discard the part of the surface of <code>a</code> which is on the surface of <code>b</code>,  <code>b</code> should be chosen slightly bigger than <code>a</code>.</p></div></div><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/CSG.jl#L122-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection" href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGIntersection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CSGIntersection{T, A &lt;: AbstractGeometry{T}, B &lt;: AbstractGeometry{T}} &lt;: AbstractConstructiveGeometry{T}</code></pre><p>A <code>CSGIntersection</code> of two geometries <code>a</code> and <code>b</code> is defined as the set of points  that are both in <code>a</code> and in <code>b</code> (<code>a &amp;&amp; b</code>).</p><p><img src="../../../docs/src/assets/CSGIntersection.png" alt="CSGIntersection"/></p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>A</code>: Type of geometry <code>a</code>.</li><li><code>B</code>: Type of geometry <code>b</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>a::A</code>: First geometry to build the intersection.</li><li><code>b::B</code>: Second geometry to build the intersection.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>CSGIntersection</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>intersection</code>, followed by an array of geometries from which the intersection is constructed. </p><p>An example definition of a <code>CSGIntersection</code> looks like this:</p><pre><code class="language-yaml hljs">intersection: # a &amp;&amp; b
  - tube: # a
      r: 2
      h: 1
  - tube: # b
      r: 1
      h: 1.5
      origin: 
        z: 0.5</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than two geometries are passed, the <code>intersection</code> is constructed from all of them.</p></div></div><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/CSG.jl#L61-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion" href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion"><code>SolidStateDetectors.ConstructiveSolidGeometry.CSGUnion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CSGUnion{T, A &lt;: AbstractGeometry{T}, B &lt;: AbstractGeometry{T}} &lt;: AbstractConstructiveGeometry{T}</code></pre><p>A <code>CSGUnion</code> of two geometries <code>a</code> and <code>b</code> is defined as the set of points that are in at least  one of either <code>a</code> or <code>b</code> (<code>a || b</code>).</p><p><img src="../../../docs/src/assets/CSGUnion.png" alt="CSGUnion"/></p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>A</code>: Type of geometry <code>a</code>.</li><li><code>B</code>: Type of geometry <code>b</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>a::A</code>: First geometry to build the union.</li><li><code>b::B</code>: Second geometry to build the union.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>CSGUnion</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>union</code>, followed by an array of geometries from which the union is constructed. </p><p>An example definition of a <code>CSGUnion</code> looks like this:</p><pre><code class="language-yaml hljs">union: # a || b
  - tube: # a
      r: 2
      h: 1
  - tube: # b
      r: 1
      h: 1.5
      origin: 
        z: 0.5</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If more than two geometries are passed, the <code>union</code> is constructed from all of them.</p></div></div><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/CSG.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint" href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CartesianPoint{T} &lt;: AbstractCoordinatePoint{T, Cartesian}</code></pre><p>Describes a three-dimensional point in Cartesian coordinates.</p><p><strong>Fields</strong></p><ul><li><code>x</code>: x-coordinate (in m).</li><li><code>y</code>: y-coordinate (in m).</li><li><code>z</code>: z-coordinate (in m).</li></ul><p>See also <a href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint"><code>CylindricalPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/PointsAndVectors/Points.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector" href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CartesianVector{T} &lt;: AbstractCoordinateVector{T, Cartesian}</code></pre><p>Describes a three-dimensional vector in Cartesian coordinates.</p><p><strong>Fields</strong></p><ul><li><code>x</code>: x-coordinate (in m).</li><li><code>y</code>: y-coordinate (in m).</li><li><code>z</code>: z-coordinate (in m).</li></ul><p>See also <a href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector"><code>CylindricalVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/PointsAndVectors/Vectors.jl#L6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Cone" href="#SolidStateDetectors.ConstructiveSolidGeometry.Cone"><code>SolidStateDetectors.ConstructiveSolidGeometry.Cone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Cone{T,CO,TR,TP} &lt;: AbstractVolumePrimitive{T, CO}</code></pre><p>Volume primitive describing a <a href="../man/csg/#Cone">Cone</a> with its top and bottom circular base being aligned with the <code>xy</code> plane (before possible rotations).</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>CO</code>: Describes whether the surface belongs to the primitive.    It can be <code>ClosedPrimitive</code>, i.e. the surface points belong to the primitive,   or <code>OpenPrimitive</code>, i.e. the surface points do not belong to the primitive.</li><li><code>TR</code>: Type of the radius <code>r</code>.<ul><li><code>TR == T</code>: Cylinder (constant radius <code>r</code> at all <code>z</code>).</li><li><code>TR == Tuple{T, T}</code>: Tube (inner radius at <code>r[1]</code>, outer radius at <code>r[2]</code>).</li><li><code>TR == Tuple{Tuple{T}, Tuple{T}}</code>: Varying Cylinder (full cylinder with radius changing linearly in <code>z</code> from <code>r[1]</code> at the bottom to <code>r[2]</code> at the top).</li><li><code>TR == Tuple{Tuple{T, T}, Tuple{T, T}}</code>: Varying Tube (inner radius changes linearly in <code>z</code> from <code>r[1][1]</code> at the bottom to <code>r[1][2]</code> at the top, outer radius changes linearly in <code>z</code> from <code>r[2][1]</code> at the bottom to <code>r[1][2]</code> at the top).</li><li><code>TR == Tuple{Nothing, Tuple{T, T}}</code>: Cone (Tip at the bottom, top is a circular base with inner radius <code>r[2][1]</code> and outer radius <code>r[2][2]</code>).</li><li><code>TR == Tuple{Tuple{T, T}, Nothing}</code>: Cone (Tip at the top, bottom is a circular base with inner radius <code>r[1][1]</code> and outer radius <code>r[1][2]</code>).</li></ul></li><li><code>TP</code>: Type of the angular range <code>φ</code>.<ul><li><code>TP == Nothing</code>: Full 2π Cone.</li><li><code>TP == T</code>: Partial Cone ranging from <code>0</code> to <code>φ</code>.</li></ul></li></ul><p><strong>Fields</strong></p><ul><li><code>r::TR</code>: Definition of the radius of the <code>Cone</code> (in m).</li><li><code>φ::TP</code>: Range in polar angle <code>φ</code> over which the <code>Cone</code> extends (in radians).</li><li><code>hZ::T</code>: Half of the height of the <code>Cone</code> (in m).</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>Cone</code> at the middle height.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>Cone</code> around its <code>origin</code>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>Cone</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>cone</code> (or <code>tube</code>).</p><p>Example definitions of a cylinder looks like this:</p><pre><code class="language-yaml hljs">tube:
  r:
    from: 1.0
    to: 2.0  # =&gt; r = (1.0, 2.0)
  h: 2.0     # =&gt; hZ = 1.0
  origin:
    z: 1.0   # =&gt; origin = [0.0, 0.0, 1.0]</code></pre><p>This is a hollow cylinder with inner radius 1 at outer radius 2 with a height of 2 and extending over full 2π (no <code>phi</code> given), translated 1 along the <code>z</code> axis.</p><p>If the radius is not constant over <code>z</code>, the <code>r</code> entries are divided into <code>bottom</code> and <code>top</code>, where <code>bottom</code> describes the inner and outer  radius at the bottom circular base and <code>top</code> describes the inner and outer radius at the top circular base (before rotations)</p><pre><code class="language-yaml hljs">cone:
  r:
    bottom:
      from: 1.0
      to: 2.0
    top:
      from: 1.0
      to: 4.0     # =&gt; r = ((1.0, 2.0), (1.0, 4.0))
  phi:
    from: 0.0°
    to: 180.0°    # =&gt; φ = π
  h: 2.0          # =&gt; hZ = 1.0</code></pre><p>This is half a Cone (<code>φ</code> goes from 0 to 180°, i.e. only positive <code>y</code> are allowed) with a height of 2, constant inner radius of 1 and an outer radius which increases  from 2 at the bottom to 4 at the top circular base.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The names <code>tube</code> and <code>cone</code> in the configuration files are interchangeable.</p></div></div><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/VolumePrimitives/Cone.jl#L1-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle" href="#SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConeMantle{T,TR,TP,D} &lt;: AbstractCurvedSurfacePrimitive{T}</code></pre><p>Surface primitive describing the mantle of a <a href="#SolidStateDetectors.ConstructiveSolidGeometry.Cone"><code>Cone</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>TR</code>: Type of the radius <code>r</code>.<ul><li><code>TR == T</code>: CylinderMantle (constant radius <code>r</code> at all <code>z</code>).</li><li><code>TR == Tuple{T, T}</code>: VaryingCylinderMantle (bottom radius at <code>r[1]</code>, top radius at <code>r[2]</code>).</li></ul></li><li><code>TP</code>: Type of the angular range <code>φ</code>.<ul><li><code>TP == Nothing</code>: Full 2π Cone.</li><li><code>TP == T</code>: Partial ConeMantle ranging from <code>0</code> to <code>φ</code>.</li></ul></li><li><code>D</code>: Direction in which the normal vector points (<code>:inwards</code> or <code>:outwards</code>).</li></ul><p><strong>Fields</strong></p><ul><li><code>r::TR</code>: Definition of the radius of the <code>ConeMantle</code> (in m).</li><li><code>φ::TP</code>: Range in polar angle <code>φ</code> over which the <code>ConeMantle</code> extends (in radians).</li><li><code>hZ::T</code>: Half of the height of the <code>ConeMantle</code> (in m).</li><li><code>origin::CartesianPoint{T}</code>: Origin of the <code>Cone</code> which has this <code>ConeMantle</code> as surface.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Rotation matrix of the <code>Cone</code> which has this <code>ConeMantle</code> as surface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/ConeMantle.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint" href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalPoint{T} &lt;: AbstractCoordinatePoint{T, Cylindrical}</code></pre><p>Describes a three-dimensional point in cylindrical coordinates. </p><p><strong>Fields</strong></p><ul><li><code>r</code>: Radius (in m).</li><li><code>φ</code>: Polar angle (in rad).</li><li><code>z</code>: <code>z</code>-coordinate (in m).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>φ == 0</code> corresponds to the <code>x</code>-axis in the Cartesian coordinate system.</p></div></div><p>See also <a href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianPoint"><code>CartesianPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/PointsAndVectors/Points.jl#L52-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector" href="#SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector"><code>SolidStateDetectors.ConstructiveSolidGeometry.CylindricalVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CylindricalVector{T} &lt;: AbstractCoordinateVector{T, Cylindrical}</code></pre><p>Describes a three-dimensional vector in cylindrical coordinates. </p><p><strong>Fields</strong></p><ul><li><code>r</code>: Radius (in m).</li><li><code>φ</code>: Polar angle (in rad).</li><li><code>z</code>: <code>z</code>-coordinate (in m).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>φ == 0</code> corresponds to the <code>x</code>-axis in the Cartesian coordinate system.</p></div></div><p>See also <a href="#SolidStateDetectors.ConstructiveSolidGeometry.CartesianVector"><code>CartesianVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/PointsAndVectors/Vectors.jl#L65-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid" href="#SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid"><code>SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ellipsoid{T,CO,TR,TP,TT} &lt;: AbstractVolumePrimitive{T, CO}</code></pre><p>Volume primitive describing an <a href="../man/csg/#Ellipsoid">Ellipsoid</a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>CO</code>: Describes whether the surface belongs to the primitive.    It can be <code>ClosedPrimitive</code>, i.e. the surface points belong to the primitive,   or <code>OpenPrimitive</code>, i.e. the surface points do not belong to the primitive.</li><li><code>TR</code>: Type of the radius <code>r</code>.<ul><li><code>TR == T</code>: Sphere (constant radius <code>r</code> along all axes).</li></ul></li><li><code>TP</code>: Type of the azimuthial angle <code>φ</code>.<ul><li><code>TP == Nothing</code>: Full 2π in <code>φ</code>.</li></ul></li><li><code>TT</code>: Type of the polar angle <code>θ</code>.<ul><li><code>TT == Nothing</code>: Full 2π in <code>θ</code>.</li></ul></li></ul><p><strong>Fields</strong></p><ul><li><code>r::TR</code>: Definition of the radius of the <code>Ellipsoid</code> (in m).</li><li><code>φ::TP</code>: Range in azimuthial angle <code>φ</code> of the <code>Ellipsoid</code>.</li><li><code>θ::TT</code>: Range in polar angle <code>θ</code> of the <code>Ellipsoid</code>.</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>Ellipsoid</code>.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>Ellipsoid</code> around its <code>origin</code>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>So far, the only <code>Ellipsoid</code> implemented so far is a <code>FullSphere</code>. A <code>FullSphere</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>sphere</code>.</p><p>Example definitions of a <code>FullSphere</code> looks like this:</p><pre><code class="language-yaml hljs">sphere:
  r: 2</code></pre><p>This is a full sphere with radius 2.</p><p>To define a sphere with inner cut-out, use <a href="#SolidStateDetectors.ConstructiveSolidGeometry.CSGDifference"><code>CSGDifference</code></a>:</p><pre><code class="language-yaml hljs">difference:
  - sphere:
      r: 2
  - sphere:
      r: 1</code></pre><p>This is a sphere with inner radius 1 and outer radius 2.</p><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/VolumePrimitives/Ellipsoid.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle" href="#SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EllipsoidMantle{T,TR,TP,TT,D} &lt;: AbstractCurvedSurfacePrimitive{T}</code></pre><p>Surface primitive describing the surface of an <a href="#SolidStateDetectors.ConstructiveSolidGeometry.Ellipsoid"><code>Ellipsoid</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>TR</code>: Type of the radius <code>r</code>.<ul><li><code>TR == T</code>: SphereMantle (constant radius <code>r</code> along all axes).</li></ul></li><li><code>TP</code>: Type of the azimuthial angle <code>φ</code>.<ul><li><code>TP == Nothing</code>: Full 2π in <code>φ</code>.</li></ul></li><li><code>TT</code>: Type of the polar angle <code>θ</code>.<ul><li><code>TT == Nothing</code>: Full 2π in <code>θ</code>.</li></ul></li><li><code>D</code>: Direction in which the normal vector points (<code>:inwards</code> or <code>:outwards</code>).</li></ul><p><strong>Fields</strong></p><ul><li><code>r::TR</code>: Definition of the radius of the <code>EllipsoidMantle</code> (in m).</li><li><code>φ::TP</code>: Range in azimuthial angle <code>φ</code> of the <code>EllipsoidMantle</code>.</li><li><code>θ::TT</code>: Range in polar angle <code>θ</code> of the <code>EllipsoidMantle</code>.</li><li><code>origin::CartesianPoint{T}</code>: Origin of the <code>Ellipsoid</code> which has this <code>EllipsoidMantle</code> as surface.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Rotation matrix of the <code>Ellipsoid</code> which has this <code>EllipsoidMantle</code> as surface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/EllipsoidMantle.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface" href="#SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface"><code>SolidStateDetectors.ConstructiveSolidGeometry.EllipticalSurface</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EllipticalSurface{T,TR,TP} &lt;: AbstractPlanarSurfacePrimitive{T}</code></pre><p>Surface primitive describing circular bases, e.g. the top or bottom base of a <a href="#SolidStateDetectors.ConstructiveSolidGeometry.Cone"><code>Cone</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>TR</code>: Type of the radius <code>r</code>.<ul><li><code>TR == T</code>: Full Circle (constant radius <code>r</code>, no cut-out).</li><li><code>TR == Tuple{T, T}</code>: Circular Annulus (inner radius at <code>r[1]</code>, outer radius at <code>r[2]</code>).</li></ul></li><li><code>TP</code>: Type of the angular range <code>φ</code>.<ul><li><code>TP == Nothing</code>: Full 2π Cone.</li><li><code>TP == T</code>: Partial Elliptical Surface ranging from <code>0</code> to <code>φ</code>.</li></ul></li></ul><p><strong>Fields</strong></p><ul><li><code>r::TR</code>: Definition of the radius of the <code>EllipticalSurface</code> (in m).</li><li><code>φ::TP</code>: Range in polar angle <code>φ</code> over which the <code>EllipticalSurface</code> extends (in radians).</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>EllipticalSurface</code>.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>EllipticalSurface</code> around its <code>origin</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/EllipticalSurface.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Plane" href="#SolidStateDetectors.ConstructiveSolidGeometry.Plane"><code>SolidStateDetectors.ConstructiveSolidGeometry.Plane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Plane{T} &lt;: AbstractPlanarSurfacePrimitive{T}</code></pre><p>Surface primitive describing a two-dimensional flat plane in three-dimensional space.</p><p><strong>Fields</strong></p><ul><li><code>origin::CartesianPoint{T}</code>: Point in the <code>Plane</code>.</li><li><code>normal::CartesianVector{T}</code>: Normal vector of the <code>Plane</code>, normalized to length 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/Plane.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Polygon" href="#SolidStateDetectors.ConstructiveSolidGeometry.Polygon"><code>SolidStateDetectors.ConstructiveSolidGeometry.Polygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Polygon{N,T} &lt;: AbstractPlanarSurfacePrimitive{T}</code></pre><p>Surface primitive describing a planar polygon, e.g. the base of a <a href="#SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism"><code>RegularPrism</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>N</code>: Number of vertices of the <code>Polygon</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>points::SVector{N, CartesianPoint{T}}</code>: Vertices of the polygon in the order with which they are connected.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/Polygon.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism" href="#SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism"><code>SolidStateDetectors.ConstructiveSolidGeometry.RegularPrism</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RegularPrism{T,CO,N,TR} &lt;: AbstractVolumePrimitive{T, CO}</code></pre><p>Volume primitive describing a <a href="../man/csg/#Prism">Prism</a> with base plates are regular polygons which are parallel to the <code>xy</code> plane. If the regular polygon base plate is projected to  the <code>xy</code> plane, one of the vertices lays on the <code>x</code> axis.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>CO</code>: Describes whether the surface belongs to the primitive.    It can be <code>ClosedPrimitive</code>, i.e. the surface points belong to the primitive,   or <code>OpenPrimitive</code>, i.e. the surface points do not belong to the primitive.</li><li><code>N</code>: Number of vertices of the regular polygon that defines the base of the prism.</li><li><code>TR</code>: Type of <code>r</code>.<ul><li><code>TR == T</code>: Regular polygon base (all vertices have the same distance to the center).</li></ul></li></ul><p><strong>Fields</strong></p><ul><li><code>r::TR</code>: Distance of the vertices to the center of the regular polygon base (in m).</li><li><code>hZ::T</code>: Half of the width in <code>z</code> dimension (in m).</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>RegularPrism</code>.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>RegularPrism</code> around its <code>origin</code>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>So far, only <code>HexagonalPrism</code> can be defined in the configuration files. A <code>HexagonalPrism</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>HexagonalPrism</code>.</p><p>An example definition of a <code>HexagonalPrism</code> looks like this:</p><pre><code class="language-yaml hljs">HexagonalPrism:
  r: 1.0 # =&gt; r = 1.0
  h: 2.0 # =&gt; hZ = 1.0</code></pre><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/VolumePrimitives/RegularPrism.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.Torus" href="#SolidStateDetectors.ConstructiveSolidGeometry.Torus"><code>SolidStateDetectors.ConstructiveSolidGeometry.Torus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Torus{T,CO,TR,TP,TT,TT1,TT2} &lt;: AbstractVolumePrimitive{T,CO}</code></pre><p>Volume primitive describing a <a href="../man/csg/#Torus">Torus</a>. It is defined as all points that are within a given radius to a circle, parallel to the <code>xy</code> plane, with constant radius around a given origin.</p><p><strong>Parametric types</strong></p><ul><li><code>T</code>: Precision type.</li><li><code>CO</code>: Describes whether the surface belongs to the primitive.    It can be <code>ClosedPrimitive</code>, i.e. the surface points belong to the primitive,   or <code>OpenPrimitive</code>, i.e. the surface points do not belong to the primitive.</li><li><code>TR</code>: Type of <code>r_tube</code>.<ul><li><code>TR == T</code>: Full tube without cutout (constant radius <code>r_tube</code>).</li><li><code>TR == Tuple{T,T}</code>: Hollow tube with cutout (inner radius <code>r_tube[1]</code>, outer radius <code>r_tube[2]</code>).</li></ul></li><li><code>TP</code>: Type of the azimuthial angle <code>φ</code>.<ul><li><code>TP == Nothing</code>: Full 2π in <code>φ</code>.</li><li><code>TP == T</code>: Partial Torus ranging from <code>0</code> to <code>φ</code>.</li></ul></li><li><code>TT</code>: Type of the polar angle <code>θ</code>.<ul><li><code>TT == Nothing</code>: Full 2π in <code>θ</code>.</li><li><code>TP == Tuple{T,T}</code>: Partial Torus ranging from <code>θ[1]</code> to <code>θ[2]</code>.</li></ul></li><li><code>TT1</code>: Type of the surface at <code>θ[1]</code> (<code>:inwards</code>, <code>:outwards</code> or <code>:flat</code>).</li><li><code>TT2</code>: Type of the surface at <code>θ[2]</code> (<code>:inwards</code>, <code>:outwards</code> or <code>:flat</code>).</li></ul><p><strong>Fields</strong></p><ul><li><code>r_torus::T</code>: Distance of the center of the <code>Torus</code> to the center of the tube (in m).</li><li><code>r_tube::TR</code>: Radius of the tube of the <code>Torus</code> (in m).</li><li><code>φ::TP</code>: Range in azimuthial angle <code>φ</code> of the <code>Torus</code>.</li><li><code>θ::TT</code>: Range in polar angle <code>θ</code> of the <code>Torus</code>.</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>Torus</code>.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>Torus</code> around its <code>origin</code>.</li></ul><p><strong>Definition in Configuration File</strong></p><p>A <code>Torus</code> is defined in the configuration file as part of the <code>geometry</code> field  of an object through the field <code>torus</code>.</p><p>Example definitions of a <code>Torus</code> looks like this:</p><pre><code class="language-yaml hljs">torus:
  r_torus: 10.0   # =&gt; r_torus = 10.0
  r_tube: 2       # =&gt; r_tube = 2.0
  phi: 
      from: 0.0°
      to: 360.0°  # =&gt; φ = nothing
  theta: 
      from: 0.0°
      to: 360.0°  # =&gt; θ = nothing</code></pre><p>The fields <code>phi</code> and <code>theta</code> do not need to defined if they are full 2π.</p><p>Example definition of a <code>Torus</code> with an inner cut-out:</p><pre><code class="language-yaml hljs">torus:
  r_torus: 10.0   # =&gt; r_torus = 10.0
  r_tube: 
      from: 1.0
      to: 2.0     # =&gt; r_tube = (1.0, 2.0)
  phi: 
      from: 0.0°
      to: 360.0°  # =&gt; φ = nothing
  theta: 
      from: 0.0°
      to: 360.0°  # =&gt; θ = nothing</code></pre><p>This is a <code>Torus</code> with <code>r_tube</code> having an inner radius of 1 and an outer radius of 2.</p><p>See also <a href="../man/csg/#Constructive-Solid-Geometry-(CSG)">Constructive Solid Geometry (CSG)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/VolumePrimitives/Torus.jl#L1-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle" href="#SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle"><code>SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TorusMantle{T,TP,TT,D} &lt;: AbstractCurvedSurfacePrimitive{T}</code></pre><p>Surface primitive describing the mantle of a <a href="#SolidStateDetectors.ConstructiveSolidGeometry.Torus"><code>Torus</code></a>.</p><p><strong>Parametric types</strong></p><ul><li><p><code>T</code>: Precision type.</p></li><li><p><code>TP</code>: Type of the azimuthial angle <code>φ</code>.</p><ul><li><code>TP == Nothing</code>: Full 2π in <code>φ</code>.</li><li><code>TP == T</code>: Partial Torus Mantle ranging from <code>0</code> to <code>φ</code>.</li></ul></li><li><p><code>TT</code>: Type of the polar angle <code>θ</code>.</p><ul><li><code>TT == Nothing</code>: Full 2π in <code>θ</code>.</li><li><code>TP == Tuple{T,T}</code>: Partial Torus Mantle ranging from <code>θ[1]</code> to <code>θ[2]</code>.</li></ul></li><li><p><code>D</code>: Direction in which the normal vector points (<code>:inwards</code> or <code>:outwards</code>).</p></li></ul><p><strong>Fields</strong></p><ul><li><code>r_torus::T</code>: Distance of the center of the <code>TorusMantle</code> to the center of the tube (in m).</li><li><code>r_tube::T</code>: Radius of the tube of the <code>TorusMantle</code> (in m).</li><li><code>φ::TP</code>: Range in azimuthial angle <code>φ</code> of the <code>TorusMantle</code>.</li><li><code>θ::TT</code>: Range in polar angle <code>θ</code> of the <code>TorusMantle</code>.</li><li><code>origin::CartesianPoint{T}</code>: The position of the center of the <code>TorusMantle</code>.</li><li><code>rotation::SMatrix{3,3,T,9}</code>: Matrix that describes a rotation of the <code>TorusMantle</code> around its <code>origin</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/TorusMantle.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.extreme_points-Union{Tuple{SolidStateDetectors.ConstructiveSolidGeometry.AbstractPrimitive{T}}, Tuple{T}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.extreme_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extreme_points(es::AbstractPrimitive{T}) where {T}</code></pre><p>Generic fallback of <code>extreme_points</code> for any primitive.  Returns 6 <code>CartesianPoint</code>s in both directions of each cartesian axes (x, y and z) around the origin of the primitive with distance determined by <code>extremum(es)</code>, which returns the maximum distance of an primitive to its origin.</p><p><strong>Arguments</strong></p><ul><li><code>es::AbstractPrimitive{T}</code>: Any primitive, e.g. a <code>Box</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/ConstructiveSolidGeometry.jl#L85-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP} where TP&lt;:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.ConeMantle{T, Tuple{T, T}, TP} where TP&lt;:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(cm::ConeMantle{T,Tuple{T,T}}, l::Line{T}) where {T}</code></pre><p>Calculates the intersections of a <code>Line</code> with a <code>ConeMantle</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cm::ConeMantle{T,Tuple{T,T}}</code>: The <code>ConeMantle</code>.</li><li><code>l::Line{T}</code>: The <code>Line</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function will always return 2 CartesianPoint&#39;s. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN&#39;s as there coordinates. If the line crosses the mantle only once, two points will be returned. The two points will be the same point (the intersection). If the line lies inside the mantle and is parallel to it. The same point will be returned which is the origin of the line. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/ConeMantle.jl#L176-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.EllipsoidMantle{T, Tuple{T, T, T}}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(em::EllipsoidMantle{T}, l::Line{T}) where {T}</code></pre><p>Calculates the intersections of a <code>Line</code> with a <code>EllipsoidMantle</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cm::EllipsoidMantle{T}</code>: The <code>EllipsoidMantle</code>.</li><li><code>l::Line{T}</code>: The <code>Line</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function will always return 2 CartesianPoint&#39;s. If the line just touches the mantle, the two points will be the same.  If the line does not touch the mantle at all, the two points will have NaN&#39;s as there coordinates.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/EllipsoidMantle.jl#L163-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.Plane{T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.Plane{T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(p::Plane{T}, line::Line{T}) where {T}</code></pre><p>Calculates the intersections of a <code>Line</code> with a <code>Plane</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cm::Plane{T}</code>: The <code>Plane</code>.</li><li><code>l::Line{T}</code>: The <code>Line</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function will always return one Point as a Tuple. If the line is parallel to the plane, the point will have <code>NaN</code>&#39;s/<code>Inf</code>&#39;s as values.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/Plane.jl#L46-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP} where TP&lt;:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T" href="#SolidStateDetectors.ConstructiveSolidGeometry.intersection-Union{Tuple{T}, Tuple{SolidStateDetectors.ConstructiveSolidGeometry.TorusMantle{T, TP} where TP&lt;:Union{Nothing, T}, SolidStateDetectors.ConstructiveSolidGeometry.Line{T}}} where T"><code>SolidStateDetectors.ConstructiveSolidGeometry.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(tm::TorusMantle{T}, l::Line{T}) where {T}</code></pre><p>Calculates the intersections of a <code>Line</code> with a <code>TorusMantle</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cm::TorusMantle{T}</code>: The <code>TorusMantle</code>.</li><li><code>l::Line{T}</code>: The <code>Line</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function will always return 4 CartesianPoint&#39;s. If the line just touches the mantle, the points will be the same.  If the line does not touch the mantle at all, the points will have NaN&#39;s as there coordinates.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/fcf07c1f32784ed47e323b6bc850d76d97d45001/src/ConstructiveSolidGeometry/SurfacePrimitives/TorusMantle.jl#L198-L211">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/custom_impurity_density_pn_junction/">« Advanced Example: Custom Impurity Profile</a><a class="docs-footer-nextpage" href="../LICENSE/">LICENSE »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 July 2023 20:25">Thursday 27 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
